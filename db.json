{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"source/imge/1.png","path":"imge/1.png","modified":1}],"Cache":[{"_id":"source/404.html","shasum":"1473ee1a881fa8392725c7ac06362335aa78c14b","modified":1439030925000},{"_id":"source/_posts/caozuoxitong.md","shasum":"4013f63e2521715c7bc4b6acabee4fed9aa2eb37","modified":1439268092000},{"_id":"source/_posts/Liangxindns.md","shasum":"e5ee352ec8b9f202613b686691e123277b86f674","modified":1439103201000},{"_id":"source/_posts/busybox.md","shasum":"d5c1b3bed05337484c64c4ed2614f9f2df163741","modified":1439101738000},{"_id":"source/_posts/gerenbijidata.md","shasum":"6f16c5773193032baec5c1b3208f24c6bb3d5a00","modified":1439217970000},{"_id":"source/_posts/gerenbijicpp.md","shasum":"a3218ac07134685f926ff8a941f6c59150f79e3d","modified":1439209580000},{"_id":"source/_posts/phpmyadmin.md","shasum":"792910425d357ef2334f52dd55b99d1f7075fb3c","modified":1439099503000},{"_id":"source/_posts/hadoop.md","shasum":"d2b04d758ef30dfadf5dd6b509ca3c7811cadd53","modified":1439100965000},{"_id":"source/_posts/linuxneicunguanli.md","shasum":"8a50f07743441dce949464614bb92d62edecc6de","modified":1439100264000},{"_id":"source/_posts/wangluo.md","shasum":"903e0ccb04003f7d3f6b26193935f5dafed97cf7","modified":1439218284000},{"_id":"source/_posts/yibutongbu.md","shasum":"d17236767e3e701b7496963bc1ae0afacac08611","modified":1439217725000},{"_id":"source/_posts/openwrt.md","shasum":"fd685a5ae56aa8f2e63553b16dd78ab5034a92e1","modified":1439105317000},{"_id":"source/_posts/新建文本文档.txt","shasum":"e287eb0e0fc8966454c4b7b5e99784bb55ac9f5f","modified":1439082816000},{"_id":"source/search/index.md","shasum":"33ba535f337a8bbb12473103dcb0aa5505b36fac","modified":1438998791000},{"_id":"source/_posts/shejimoshi.md","shasum":"46d9535cea87ab2c01f9a8fefa8d25d462c0a8b3","modified":1439189555000},{"_id":"source/_posts/sshreverse.md","shasum":"e1a526ac062ac82bf60e56dc91b4d2cd72a72d39","modified":1439120109000},{"_id":"source/imge/1.png","shasum":"60e066bac07555c56dd4963abd81f59c2daa5785","modified":1439036988000},{"_id":"source/tags/index.md","shasum":"a50cb55ee576e17268c9216edf600ecdd757626a","modified":1438956486000},{"_id":"themes/yilia/_config.yml","shasum":"90139bdcead273fdcc4508838dd01090a09cb3b1","modified":1439119992000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","shasum":"082504c9fd8600306d4ca55f03e3cbb0ddd99dd7","modified":1439087771000},{"_id":"themes/yilia/README.md","shasum":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","shasum":"8dfb6d68aa8a0661d26c32ce1ce1f45815364c3a","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/archive.ejs","shasum":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/footer.ejs","shasum":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/article.ejs","shasum":"ef8dd558f908f293c34123c0b7ff879d2fd0c09f","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/head.ejs","shasum":"963c106412a3ab142871976978ecc9884aeca17a","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/header.ejs","shasum":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","shasum":"70a9951e4e2d30aabba88e75c3fa54b9235ce6a6","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","shasum":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","shasum":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","shasum":"54fab4d3d64cb937d6baec7324ffabf9f202b883","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","shasum":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","shasum":"d19dee2082528e1844bed3aa4e4bd59f15fd7a7a","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","shasum":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","shasum":"da39b4ba0c0ce4e1932fd45c5aee10e8aca41f28","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1439087771000},{"_id":"themes/yilia/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1439087771000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","shasum":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1439087771000},{"_id":"themes/yilia/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1439087771000},{"_id":"themes/yilia/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1439087771000},{"_id":"themes/yilia/layout/layout.ejs","shasum":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1439087771000},{"_id":"themes/yilia/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1439087771000},{"_id":"themes/yilia/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1439087771000},{"_id":"themes/yilia/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1439087771000},{"_id":"themes/yilia/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/archive.styl","shasum":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1439087771000},{"_id":"themes/yilia/package.json","shasum":"00357ef6f24eb049074da81809e98f973f528cca","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/article.styl","shasum":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/footer.styl","shasum":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/highlight.styl","shasum":"8cadf8437ce6f372802d3d28617a1ab97e7c818e","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/instagram.styl","shasum":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/main.styl","shasum":"4268f759920106a576c6037264076b36018ff73b","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","shasum":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/mobile.styl","shasum":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/page.styl","shasum":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/scroll.styl","shasum":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/share.styl","shasum":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","shasum":"af0115de5c6455f899a2e09225b50224982c039d","modified":1439087771000},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","shasum":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1439087771000},{"_id":"themes/yilia/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1439087771000},{"_id":"themes/yilia/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1439087771000},{"_id":"themes/yilia/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1439087771000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1439087771000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1439087771000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","shasum":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1439087771000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1439087771000},{"_id":"themes/yilia/source/css/style.styl","shasum":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","shasum":"a82597493d75ea989ca586e09173cff332efe41e","modified":1439087771000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1439087771000},{"_id":"themes/yilia/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1439087771000},{"_id":"themes/yilia/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1439087771000},{"_id":"themes/yilia/source/img/douban.png","shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1439087771000},{"_id":"themes/yilia/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1439087771000},{"_id":"themes/yilia/source/img/github.png","shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1439087771000},{"_id":"themes/yilia/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1439087771000},{"_id":"themes/yilia/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1439087771000},{"_id":"themes/yilia/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1439087771000},{"_id":"themes/yilia/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1439087771000},{"_id":"themes/yilia/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1439087771000},{"_id":"themes/yilia/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1439087771000},{"_id":"themes/yilia/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1439087771000},{"_id":"themes/yilia/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1439087771000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1439087771000},{"_id":"themes/yilia/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1439087771000},{"_id":"themes/yilia/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1439087771000},{"_id":"themes/yilia/source/img/weibo.png","shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1439087771000},{"_id":"themes/yilia/source/img/zhihu.png","shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1439087771000},{"_id":"themes/yilia/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1439087771000},{"_id":"themes/yilia/source/js/jquery.lazyload.js","shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1439087771000},{"_id":"themes/yilia/source/js/main.js","shasum":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1439087771000},{"_id":"themes/yilia/source/js/mobile.js","shasum":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1439087771000},{"_id":"themes/yilia/source/js/pc.js","shasum":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1439087771000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1439087771000},{"_id":"public/js/pc.js","modified":1439268116130,"shasum":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10"},{"_id":"public/js/mobile.js","modified":1439268116139,"shasum":"b68cc01d24e80973c48205f551da87f3f3427644"},{"_id":"public/js/main.js","modified":1439268116145,"shasum":"0640b68a76fab3c693b3cd1e4d04d14be1e53940"},{"_id":"public/js/jquery.lazyload.js","modified":1439268116147,"shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799"},{"_id":"public/js/instagram.js","modified":1439268116152,"shasum":"f19adbcc0dac33536bc6660598059048ec901882"},{"_id":"public/img/zhihu.png","modified":1439268116162,"shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d"},{"_id":"public/img/weibo.png","modified":1439268116169,"shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b"},{"_id":"public/img/twitter.png","modified":1439268116176,"shasum":"14dbb8e62d056525253bc0de13acd1723da7a934"},{"_id":"public/img/stackoverflow.png","modified":1439268116191,"shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2"},{"_id":"public/img/scrollbar_arrow.png","modified":1439268116196,"shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0"},{"_id":"public/img/rss.png","modified":1439268116201,"shasum":"430fd47340e75214c081abd05cd7410cf7c71b86"},{"_id":"public/img/pinterest.png","modified":1439268116219,"shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630"},{"_id":"public/img/pinboard.png","modified":1439268116228,"shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0"},{"_id":"public/img/mail.png","modified":1439268116233,"shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7"},{"_id":"public/img/linkedin.png","modified":1439268116240,"shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c"},{"_id":"public/img/img-loading.png","modified":1439268116248,"shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031"},{"_id":"public/img/img-err.png","modified":1439268116251,"shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b"},{"_id":"public/img/google.png","modified":1439268116258,"shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d"},{"_id":"public/img/github.png","modified":1439268116260,"shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d"},{"_id":"public/img/facebook.png","modified":1439268116264,"shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54"},{"_id":"public/img/douban.png","modified":1439268116268,"shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e"},{"_id":"public/img/delicious.png","modified":1439268116276,"shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd"},{"_id":"public/img/coderwall.png","modified":1439268116280,"shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1439268116289,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1439268116291,"shasum":"a82597493d75ea989ca586e09173cff332efe41e"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1439268116297,"shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1439268116299,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1439268116305,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1439268116307,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1439268116312,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1439268116314,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1439268116321,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1439268116323,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1439268116332,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1439268116334,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1439268116344,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1439268116346,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1439268116351,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1439268118359,"shasum":"e56554c624d9d49e9429eeeb9222488f8df634ec"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1439268119079,"shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1439268119085,"shasum":"1480b8101b02da9bc4c60341b5e185e63e585064"},{"_id":"public/css/fonts/fontawesome-webfont.svgz","modified":1439268119092,"shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1439268119098,"shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1439268119108,"shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6"},{"_id":"public/imge/1.png","modified":1439268119113,"shasum":"60e066bac07555c56dd4963abd81f59c2daa5785"},{"_id":"public/404.html","modified":1439268119117,"shasum":"5c6699154a8233bf776bcb4fbd3ba078beddccc7"},{"_id":"public/tags/index.html","modified":1439268119246,"shasum":"8ea069056144c60a838b05c5442cd6dc0da0a667"},{"_id":"public/search/index.html","modified":1439268119269,"shasum":"58c5967c81d9fb7a2db730dce63900f5b46d58d8"},{"_id":"public/2015/08/10/shejimoshi/index.html","modified":1439268119368,"shasum":"1a03d378f8e84027276cfc00edc64ed982acccb0"},{"_id":"public/2015/08/01/linuxneicunguanli/index.html","modified":1439268119389,"shasum":"7c77f965bb3673098551c17071146486263481ce"},{"_id":"public/2015/07/25/phpmyadmin/index.html","modified":1439268119411,"shasum":"57f69be7bbec80688c5a0d1ffc41f9e9b5f8c003"},{"_id":"public/2015/07/15/Liangxindns/index.html","modified":1439268119436,"shasum":"a2e9bc4ad07251a39320a15ff85346327d594ee2"},{"_id":"public/2015/05/17/caozuoxitong/index.html","modified":1439268119457,"shasum":"13ca0b551f7206d8411013a72e6b1f6667becbb5"},{"_id":"public/2015/05/11/yibutongbu/index.html","modified":1439268119481,"shasum":"d411e0d3e1184dc5f3c574b6d77ea074727cd511"},{"_id":"public/2015/04/12/wangluo/index.html","modified":1439268119506,"shasum":"0e0ad28b5757daad5943068d6df7ca09894f4140"},{"_id":"public/2015/04/11/busybox/index.html","modified":1439268119539,"shasum":"ab33de35f24cad044ed8de930133b91ab479af38"},{"_id":"public/2015/03/29/gerenbijidata/index.html","modified":1439268119604,"shasum":"e09645a8269af979b54502f9121c00de015d73f9"},{"_id":"public/2015/03/10/gerenbijicpp/index.html","modified":1439268119664,"shasum":"a2234e6dee46174bda280bbb6f7736e5b6fd5b6d"},{"_id":"public/2015/01/11/hadoop/index.html","modified":1439268119715,"shasum":"124a18a51936e2e25e6f3835472f80740a31e33c"},{"_id":"public/2014/10/16/sshreverse/index.html","modified":1439268119741,"shasum":"f85af6204a65c07fee9ac3efa08c3b1cf8aaf06e"},{"_id":"public/2014/10/16/openwrt/index.html","modified":1439268119798,"shasum":"30121e8522715cc475ebc9250e4ea86ae1996bb6"},{"_id":"public/archives/index.html","modified":1439268119850,"shasum":"72aebe611545f88987b7a3a0fc284869066123ce"},{"_id":"public/archives/page/2/index.html","modified":1439268119907,"shasum":"473833e38781fd47eb4a507883e3d54bd7fde4cb"},{"_id":"public/archives/page/3/index.html","modified":1439268119922,"shasum":"f2596a12d38a25038869ff434d7770da8d3c764e"},{"_id":"public/archives/2014/index.html","modified":1439268119945,"shasum":"b00caf492c98ae22e83c07a3e253ec7e6c450b94"},{"_id":"public/archives/2014/10/index.html","modified":1439268119962,"shasum":"5d4fb8233843b9d440ff5c32ed8d6289ca7c224c"},{"_id":"public/archives/2015/index.html","modified":1439268120002,"shasum":"e6b03b425c4aca76b4ab73611d740bea57781d9c"},{"_id":"public/archives/2015/page/2/index.html","modified":1439268120046,"shasum":"f7b2e646785cfcf5000a0cdc3486efeee17041b1"},{"_id":"public/archives/2015/01/index.html","modified":1439268120064,"shasum":"35b84f20ec7e4fae1702379ef7c1b297b1a0cb8b"},{"_id":"public/archives/2015/03/index.html","modified":1439268120087,"shasum":"25e5f441f43f228c3aa040bd64a46e287c7697d5"},{"_id":"public/archives/2015/04/index.html","modified":1439268120119,"shasum":"ded001a11fb006e38e57f8a77a51e5d0a1bb4b29"},{"_id":"public/archives/2015/05/index.html","modified":1439268120138,"shasum":"c5cf54846a868b78fc6dc1ab5002fb4333177347"},{"_id":"public/archives/2015/07/index.html","modified":1439268120157,"shasum":"5767fe71a06c4b820d7c4c743a79f8585be98231"},{"_id":"public/archives/2015/08/index.html","modified":1439268120176,"shasum":"eee3d3019c75275a4b9dc30bfbe947b6d77d124a"},{"_id":"public/sitemap.xml","modified":1439268120180,"shasum":"a3181b89b364c4501d7cb9434d8ab4b84b578cfa"},{"_id":"public/categories/操作系统/index.html","modified":1439268120200,"shasum":"464bd504f3f88303f28f946bca8ca29206260cc3"},{"_id":"public/categories/总结复习/index.html","modified":1439268120231,"shasum":"e688e32b6d6c8594a282511283454b24d54a5d58"},{"_id":"public/categories/网络技术/index.html","modified":1439268120250,"shasum":"283dfac30dc837b4a6c7a36d3244cb710d10977a"},{"_id":"public/categories/程序设计/index.html","modified":1439268120262,"shasum":"c4aa7cf3dd111224f6b1970f878f2f041f7dc5ca"},{"_id":"public/categories/数据库技术/index.html","modified":1439268120279,"shasum":"b5df708743222676013b0eddee043e24dd17c6a2"},{"_id":"public/categories/嵌入式linux/index.html","modified":1439268120298,"shasum":"1b4d21156b68be63d97a842e8378541ac9e47ce0"},{"_id":"public/categories/转载文章/index.html","modified":1439268120320,"shasum":"a190b93c8604a234e9e5d730276a9b167329c038"},{"_id":"public/categories/hadoop/index.html","modified":1439268120341,"shasum":"dd309fa9e9c0572d43c9e22320ba30880f46d5ce"},{"_id":"public/index.html","modified":1439268120390,"shasum":"431efd65301202c91b973beb3fb2c0ee689bdc10"},{"_id":"public/page/2/index.html","modified":1439268120428,"shasum":"55449e87efab375ac11dd79dd746ee727ec11dda"},{"_id":"public/page/3/index.html","modified":1439268120448,"shasum":"5762a8c0ad705bed188ec3e92d5eb3f825a3c612"},{"_id":"public/tags/异步/index.html","modified":1439268120459,"shasum":"b6e3f8d6d0694a19bcd6a2793d4cbeb35ee0d58f"},{"_id":"public/tags/同步/index.html","modified":1439268120478,"shasum":"6b8f6f09beeefa8f383c50af64a55eac9e25fda7"},{"_id":"public/tags/IO模型/index.html","modified":1439268120488,"shasum":"205b7a35341508665e3a693be89fd9be487c057e"},{"_id":"public/tags/操作系统/index.html","modified":1439268120517,"shasum":"bffd4dd74b8ae43f081ed1f23eb60ebf205d099c"},{"_id":"public/tags/知识点整理/index.html","modified":1439268120545,"shasum":"8b0f29408dd90c2bba6cfe7d1654d1628c2360ef"},{"_id":"public/tags/计算机网络/index.html","modified":1439268120563,"shasum":"a2f3d31047f11b7428e2009b7fc4802e0118d26e"},{"_id":"public/tags/ssh反向代理/index.html","modified":1439268120588,"shasum":"3a31e78bcd2dd8aa8192fc2a81bb2ec12c8fe8b6"},{"_id":"public/tags/ssh/index.html","modified":1439268120599,"shasum":"20d52fc7926b3b0bb7b3f5ada9c4520492579df5"},{"_id":"public/tags/穿越内网/index.html","modified":1439268120614,"shasum":"679dc85bbddb54072c3a79b1036fa8c30e993fe5"},{"_id":"public/tags/设计模式/index.html","modified":1439268120640,"shasum":"72ef07b63e8ff6504df8d7933aceb97f6a22a13f"},{"_id":"public/tags/C-实现/index.html","modified":1439268120655,"shasum":"5015c1892513128abe378e1d42924f86ec204f90"},{"_id":"public/tags/excel/index.html","modified":1439268120669,"shasum":"7815846fc1744cce05ed7209fd2a2af948d5b4a8"},{"_id":"public/tags/phpmyadmin/index.html","modified":1439268120684,"shasum":"0ed3970ad8dc89e94ed416a21b3a5ca80e9d352a"},{"_id":"public/tags/uboot定制/index.html","modified":1439268120699,"shasum":"ce001a110b3894c9ded42353bf75ff339dee1de9"},{"_id":"public/tags/内核编译/index.html","modified":1439268120710,"shasum":"f1c96ac5ec7580c45a11a34bcc1c85e8da95ec19"},{"_id":"public/tags/打印机共享/index.html","modified":1439268120726,"shasum":"55ec35408a9234823802fae05ecaa536bbadaab0"},{"_id":"public/tags/openwrt/index.html","modified":1439268120741,"shasum":"c19f6aa1ade8f1a05cd641cab1f06a054b4060b3"},{"_id":"public/tags/linux/index.html","modified":1439268120760,"shasum":"0c55dc55261347126d5678901bdc7f451499669c"},{"_id":"public/tags/内存管理/index.html","modified":1439268120774,"shasum":"3239bd0b3986837638073f33a831faca6e3bda2e"},{"_id":"public/tags/分页技术/index.html","modified":1439268120788,"shasum":"9409963d0e762a09aeb85698392b90e7c7f8b7d5"},{"_id":"public/tags/hadoop/index.html","modified":1439268120808,"shasum":"9980fbefa9184ecaf0836d59f4e9b95c5294f9cd"},{"_id":"public/tags/n2n/index.html","modified":1439268120829,"shasum":"deaaadc58b69fe5d2baf1b6b4958e4968916ab96"},{"_id":"public/tags/vpn/index.html","modified":1439268120850,"shasum":"28604f1e606774c0655cc26a705787c49dcc9d1e"},{"_id":"public/tags/数据结构/index.html","modified":1439268120876,"shasum":"8814b9ee492d27c736249780864577ce2fea8a57"},{"_id":"public/tags/C/index.html","modified":1439268120894,"shasum":"37eff80b275a42a3f61cf1a69a112c132f7e6884"},{"_id":"public/tags/复习笔记/index.html","modified":1439268120929,"shasum":"4249b32e261b442ca618160514f6c67d85b2ec9c"},{"_id":"public/tags/进程线程/index.html","modified":1439268120944,"shasum":"11b957ba6a85c4fc2a3beb83430e788a1ea504a7"},{"_id":"public/tags/文件系统/index.html","modified":1439268120968,"shasum":"355926c0e2fcd694805472ca02285ad08db04d21"},{"_id":"public/tags/busybox/index.html","modified":1439268120983,"shasum":"d4bcc2cdc8f88dd2664e60919345326ea2d7fafe"},{"_id":"public/tags/移植/index.html","modified":1439268121003,"shasum":"f32f0bd5245934f44170d0cb91045a45c9846917"},{"_id":"public/tags/DNS，第三方DNS/index.html","modified":1439268121019,"shasum":"58f334cfb980f1cb20b83365bf155e901eb1f614"}],"Category":[{"name":"操作系统","_id":"cid6v2j160004o9d3sry0eplh"},{"name":"总结复习","_id":"cid6v2j1v000fo9d3ahkmlabb"},{"name":"网络技术","_id":"cid6v2j2c000mo9d3hwtokbgm"},{"name":"程序设计","_id":"cid6v2j30000vo9d36zbghrk4"},{"name":"数据库技术","_id":"cid6v2j3a0012o9d37n406px5"},{"name":"嵌入式linux","_id":"cid6v2j3q0019o9d3p76r52uc"},{"name":"转载文章","_id":"cid6v2j44001ko9d3lbeq98z7"},{"name":"hadoop","_id":"cid6v2j4m001to9d3f9rd50ja"}],"Data":[],"Page":[{"layout":"false","_content":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <title>404</title>\n    <link rel=\"icon\" href=\"/favicon.ico\">\n  </head>\n  <body>\n    <div align=\"center\">\n      <p><script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script></p>\n    </div>\n  </body>\n</html>\n\n\n","source":"404.html","raw":"layout: false\n--------\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <title>404</title>\n    <link rel=\"icon\" href=\"/favicon.ico\">\n  </head>\n  <body>\n    <div align=\"center\">\n      <p><script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script></p>\n    </div>\n  </body>\n</html>\n\n\n","date":"2015-08-08T10:48:49.000Z","updated":"2015-08-08T10:48:45.000Z","path":"404.html","title":"","comments":1,"_id":"cid6v2iud0000o9d3ner5ltrt"},{"_content":"layout: tags\ntitle: tags\n","source":"tags/index.md","raw":"layout: tags\ntitle: tags\n","date":"2015-08-07T14:08:06.000Z","updated":"2015-08-07T14:08:06.000Z","path":"tags/index.html","title":"","comments":1,"layout":"page","_id":"cid6v2j0b0001o9d36tknmln3"},{"layout":"search","title":"search","_content":"","source":"search/index.md","raw":"layout: search\ntitle: search\n---\n","date":"2015-08-08T01:53:11.000Z","updated":"2015-08-08T01:53:11.000Z","path":"search/index.html","comments":1,"_id":"cid6v2j0j0002o9d3n7vhfzf0"}],"Post":[{"title":"阻塞、非阻塞、同步、异步","date":"2015-05-11T16:51:44.000Z","_content":"几种IO模型\n<!--more-->\n\n\n\n- IO操作分为两个过程，第一个是内核有没有准备好数据，第二个是准备好的数据由内核空间拷贝到用户空间。\n\n- 阻塞、非阻塞、IO复用都是同步的，都是第一个阶段的不同，阻塞是主动去询问内核数据有没有准备好数据，阻塞的就停止了，直到内核说有了。非阻塞的内核告诉没有，直接返回，干其他事情。IO复用也是同理，与非阻塞相比，这里的IO复用是监听多个IO操作，比如在网络编程中，用select或者epoll可以监听一组套接字，这时候哪个套接字准备好数据了，就读，没有就接着干其他的，然后等到下次循环去问。同步中，数据由内核拷贝到用户空间的过程也是需要等待的，只是操作系统处理这个过程比较快，所以我们感觉不到程序已经停下来了，其实是等待数据结束，IO操作才结束。\n\n- 至于异步，是真正的非阻塞。IO操作的两个过程都没有阻塞，就是说，我在IO的过程中，只告诉内核，我是异步IO，我要读什么什么，然后我就不管了，直接去做其他事情，内核准备好数据后，然后把数据拷贝到用户空间，这两个过程完成后会给进程一个信号，告诉进程，数据都准备好了，请拿走，然后进程中断，取处理IO后的数据，处理完之后再做之后的。","source":"_posts/yibutongbu.md","raw":"title: 阻塞、非阻塞、同步、异步  \ndate: 2015-5-11 12:51:44\ncategories: 操作系统\ntags: [异步,同步,IO模型,操作系统] \n---\n几种IO模型\n<!--more-->\n\n\n\n- IO操作分为两个过程，第一个是内核有没有准备好数据，第二个是准备好的数据由内核空间拷贝到用户空间。\n\n- 阻塞、非阻塞、IO复用都是同步的，都是第一个阶段的不同，阻塞是主动去询问内核数据有没有准备好数据，阻塞的就停止了，直到内核说有了。非阻塞的内核告诉没有，直接返回，干其他事情。IO复用也是同理，与非阻塞相比，这里的IO复用是监听多个IO操作，比如在网络编程中，用select或者epoll可以监听一组套接字，这时候哪个套接字准备好数据了，就读，没有就接着干其他的，然后等到下次循环去问。同步中，数据由内核拷贝到用户空间的过程也是需要等待的，只是操作系统处理这个过程比较快，所以我们感觉不到程序已经停下来了，其实是等待数据结束，IO操作才结束。\n\n- 至于异步，是真正的非阻塞。IO操作的两个过程都没有阻塞，就是说，我在IO的过程中，只告诉内核，我是异步IO，我要读什么什么，然后我就不管了，直接去做其他事情，内核准备好数据后，然后把数据拷贝到用户空间，这两个过程完成后会给进程一个信号，告诉进程，数据都准备好了，请拿走，然后进程中断，取处理IO后的数据，处理完之后再做之后的。","slug":"yibutongbu","published":1,"updated":"2015-08-10T14:42:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j0w0003o9d3q7kj59lh"},{"title":"复习笔记-网络归纳","date":"2015-04-12T16:51:44.000Z","_content":"总结复习，网络知识点\n<!--more-->\n### 1.路由汇聚\n如果一个路由表中有很多相近的网段，这些相近到网段独占一条路由记录，这样系统维护到路由表就会比较大，效率就不会很高，所以如果把相近到网段聚合 在一起，使之成为一条路由记录，这样在搜索路由表到时候，效率就会提高。\n具体做法：\n> 有三条路由：  \n> 192.168.128.0/24  \n> 192.168.130.0/24  \n> 192.168.132.0/24    \n\n如果进行路由汇聚，则能汇聚到网段为：\n- a.首先我么应该观察这三条路由不同de字节数，写出他们的二进制。\n- b.192.168 一样就不用写了。所以从第三个字节算起。\n- 1000 0000\n- 1000 0010\n- 1000 0100\n- c.通过上边到分解可以看出，前5个比特位是一样的，所以聚合后的掩码为5，在加上前边的两个字节是8+8+5 = 21.\n- 前5个比特位固定住后，后边剩下到三个补0，则十进制为128.\n- d.所以，得到到聚合网段为192.168.128.0/21\n\n### 2.常用2进制转换\n128    1000 0000  \n127    0111 1111  \n240    1111 0000  \n168    1010 1000  \n192    1100 0000  \n172    1010 1100  \n### 3.16进制和2进制转换\n十六进制是分为两个字符，前边到一个正好对应2进制到前四个，后边到一个对应2进制的后四个。各算各的。\n逻辑中要用10进制中转。\n\n### 4.子网划分\n实际上是根ip地址到类型来划分的，比如一个C类地址，那么它默认到mask是24,子网演码是采用借位来去做的，借主机的位（不能借网络的位），这样一个网络就是由主机地址+子网地址+网络地址组成。有多少个子网，就看像主机借了多少位，有多少个主机就看主机还剩下多少位。比如借来两位，那么子网就为2的2次方，剩下6位，那么主机就为2到6次方-2（剪2是因为子网内第一个是网段地址，最后一个是广播地址，所以都不可以给主机使用。）\n\n### 5.如果把一个网络40.15.0.0分为两个子网，第一个子网是40.15.0.0/17,第二个子网为多少？\n\n首先根据题目可以知道40.15.0.0是一个A类网，既然第一个子网也是40.15开头到，那么可以知道这个40.15.0.0这个其实也是从40这个网段划分出来到一个子网。这个我们就不用考虑，只需知道40.15.0.0到子网演码为255.255.0.0就可以了。由于是两个子网，所以应该是2到1次方，则子网演码中的第三个字节为1000 0000，由此可知，每个子网有2的7+8次方个主机-2。演码第一位为1，则真实网段中可以变成0或者1，如果是0，则是条件中到那个，如果是1，则为128，即40.15.128.0/17.这个网段中主机范围应该是40.15.128.1~40.15.255.254.\n### 6.TCP是如何提供可靠连接的？\n**（三次握手四次分手、[拥塞处理](http://blog.sina.com.cn/s/blog_48ebca64010003t0.html)、滑动窗口、检验和、超时重传）**\n> a.拥塞处理机制：这个是在本地发送端做的处理，需要一个拥塞窗口，这个窗口的大小应该是动态变化的，默认是一个MSS的大小，应用一些算法（慢启动、拥塞避免、快速重发、快速恢复），比如说慢启动，就是当一个连接建立起来之后，并不能往网络中发送大量的数据，因为并不知道网络状态是好的，还是不好的，所以应该第一次发送一个MSS，第二次发送两个MSS，第三次发送4个MSS。。。以此类堆，先成指数增长，同时设置一个峰值（为默认的对方窗口大小 65535个字节），就按照这个大小来发，这样做提高来网络的利用率。如果发生来拥塞（发送端接到来相同的ACK回复或者根本没有回复），那么首先\n> \n> > -  1.减少峰值的大小，减少一半。\n> > -  2.同时再从一个MSS发送数据。\n> > -  3.继续慢启动的过程\n>  \n> 上述过程就为慢启动和拥塞避免算法。\n> \n> b.当TCP发送出去一个段后，本地会有一个定时器启动起来，这个定时器在某一时间内如果收不到对方的应答，则证明本次发送失败，就会进行重传处理。\n> c.当TCP收到一个数据后，要进行ACK的确认给发送方。\n> \n> d. TCP保持在它首部的检验和，这个检验和是包含TCP头和应用数据的。这样在传输到过程中，如果数据有丢失，接收方通过重算检验和会发现异常，丢弃这个包。而UDP的检验和虽然有，但默认是关闭的，所以不可靠。\n> e.滑动窗口机制。是接收端的一个窗口，每次接收端都会给发送端回复的包中，含有接收端接收缓冲区的剩余大小。这样在发送端往本地发送数据的时候就不会多发，因为多发，会导致本地接收缓冲区溢出，造成数据的丢失。滑动窗口并不能判断网络的拥塞情况，只是判断缓冲区的大小。判断拥塞应该是拥塞窗口的事情。\n> \n> f.与UDP相比，它是有一个三次握手，四次分手的过程。\n\n### 7.TCP 连接 TIME_WAIT\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/55067698.jpg)\n\n> 上述到TIME_WAIT状态是2MSL（max segment life），意思就是当结束连接的时候，必须要等待一段时间。\n> 具体过程是：当服务端发给客户最后一个FIN之后，服务端要等待ACK，这时候，客户端会给服务端回ACK，假如ACK没有传送至服务端，如果没有TIMEWAIT机制的话，客户端就可以直接关闭掉，倒是后服务端就关不上来。所以应该设置一个等待时间，如果服务端往客户端发送FIN，超时来再重发，这时候由于有TIME——WAIT所以客户端再次接收一个FIN，则此时就会再给服务端发一个ACK。\n\n### 8.FTP主动模式和被动模式\n\n主动模式：\n> FTP客户机向服务器的FTP控制端口（默认是21）发送请求，服务器接受连接，建立一条命令链路，当需要传送数据时候，客户端在命令链路上用PORT命令告诉服务器：“我打开了某个端口，你过来连接我。”于是服务器从20端口向客户端的改端口发送连接请求，建立一条数据链路来传送数据。在数据链路建立的过程中是服务器主动请求，所以称为主动模式。 \n> FTP 主动模式（命令行是主动模式）\n> 服务器用20号端口，主动连接客户机的大于1024的随机端口。\n> \n> 被动模式：\n> FTP客户端向服务器的FTP控制端口发送连接请求，服务器接收连接，建立一条命令链路，当需要传送数据时候，服务器在命令链路上用PASV命令告诉客户端；“我打开了某端口，你过来连接我。”于是客户端向服务器的该端口发送连接请求，建立一条数据链路来传送数据。在数据链路建立的过程中是服务器被动等待客户端请求，所以称为被动模式。\n\n---\n\n> FTP被动模式\n> 客户机用大于1024的随机端口，主动连接服务器大于1024的随机端口。\n> \n> 主动模式下的FTP服务器，需要在服务器和客户端之间的防火墙中设置一下策越：\n> 允许FTP客户机从大于1024的端口连接FTP服务器的21端口\n> 允许FTP服务器从21端口回应FTP客户机中大于1024端口的网络连接。\n> 允许FTP服务器从20端口主动连接FTP客户机中大于1024的端口\n> 允许FTP客户机从大于1024的端口回应来自FTP服务器20端口的网络连接\n> \n> 被动模式下的FTP服务器，需要在服务器和客户端之间的防火墙中设置一下策越：\n> 允许FTP客户机从大于1024的端口连接FTP服务器的21端口\n> 允许FTP服务器从21端口回应FTP客户机中大于1024端口的网络连接。\n> 允许FTP客户机从大于1024端口主动连接FTP服务器中大于1024的端口\n> 允许FTP服务器从大于1024的端口回应来自FTP客户机大于1024端口的网络连接\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/20845911.jpg)\n\n### 9.既然已经有了ip的分片，那么为什么还需要有tcp的分段？\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/72824121.jpg)\n\n### 10.[数据帧封装格式、MTU、MSS](http://infotech.blog.51cto.com/391844/123859 )\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/12035922.jpg)\n\n### 11.TCP、UDP、IP报文头部\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/22300570.jpg)![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/48048979.jpg)\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/59323400.jpg)\n### 12.iptables\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/41832642.jpg)\n### 13.三次握手\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/40534034.jpg)\n### NAT透传！\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/2700751.jpg)","source":"_posts/wangluo.md","raw":"title: 复习笔记-网络归纳  \ndate: 2015-4-12 12:51:44\ncategories: 总结复习\ntags: [知识点整理,计算机网络] \n---\n总结复习，网络知识点\n<!--more-->\n### 1.路由汇聚\n如果一个路由表中有很多相近的网段，这些相近到网段独占一条路由记录，这样系统维护到路由表就会比较大，效率就不会很高，所以如果把相近到网段聚合 在一起，使之成为一条路由记录，这样在搜索路由表到时候，效率就会提高。\n具体做法：\n> 有三条路由：  \n> 192.168.128.0/24  \n> 192.168.130.0/24  \n> 192.168.132.0/24    \n\n如果进行路由汇聚，则能汇聚到网段为：\n- a.首先我么应该观察这三条路由不同de字节数，写出他们的二进制。\n- b.192.168 一样就不用写了。所以从第三个字节算起。\n- 1000 0000\n- 1000 0010\n- 1000 0100\n- c.通过上边到分解可以看出，前5个比特位是一样的，所以聚合后的掩码为5，在加上前边的两个字节是8+8+5 = 21.\n- 前5个比特位固定住后，后边剩下到三个补0，则十进制为128.\n- d.所以，得到到聚合网段为192.168.128.0/21\n\n### 2.常用2进制转换\n128    1000 0000  \n127    0111 1111  \n240    1111 0000  \n168    1010 1000  \n192    1100 0000  \n172    1010 1100  \n### 3.16进制和2进制转换\n十六进制是分为两个字符，前边到一个正好对应2进制到前四个，后边到一个对应2进制的后四个。各算各的。\n逻辑中要用10进制中转。\n\n### 4.子网划分\n实际上是根ip地址到类型来划分的，比如一个C类地址，那么它默认到mask是24,子网演码是采用借位来去做的，借主机的位（不能借网络的位），这样一个网络就是由主机地址+子网地址+网络地址组成。有多少个子网，就看像主机借了多少位，有多少个主机就看主机还剩下多少位。比如借来两位，那么子网就为2的2次方，剩下6位，那么主机就为2到6次方-2（剪2是因为子网内第一个是网段地址，最后一个是广播地址，所以都不可以给主机使用。）\n\n### 5.如果把一个网络40.15.0.0分为两个子网，第一个子网是40.15.0.0/17,第二个子网为多少？\n\n首先根据题目可以知道40.15.0.0是一个A类网，既然第一个子网也是40.15开头到，那么可以知道这个40.15.0.0这个其实也是从40这个网段划分出来到一个子网。这个我们就不用考虑，只需知道40.15.0.0到子网演码为255.255.0.0就可以了。由于是两个子网，所以应该是2到1次方，则子网演码中的第三个字节为1000 0000，由此可知，每个子网有2的7+8次方个主机-2。演码第一位为1，则真实网段中可以变成0或者1，如果是0，则是条件中到那个，如果是1，则为128，即40.15.128.0/17.这个网段中主机范围应该是40.15.128.1~40.15.255.254.\n### 6.TCP是如何提供可靠连接的？\n**（三次握手四次分手、[拥塞处理](http://blog.sina.com.cn/s/blog_48ebca64010003t0.html)、滑动窗口、检验和、超时重传）**\n> a.拥塞处理机制：这个是在本地发送端做的处理，需要一个拥塞窗口，这个窗口的大小应该是动态变化的，默认是一个MSS的大小，应用一些算法（慢启动、拥塞避免、快速重发、快速恢复），比如说慢启动，就是当一个连接建立起来之后，并不能往网络中发送大量的数据，因为并不知道网络状态是好的，还是不好的，所以应该第一次发送一个MSS，第二次发送两个MSS，第三次发送4个MSS。。。以此类堆，先成指数增长，同时设置一个峰值（为默认的对方窗口大小 65535个字节），就按照这个大小来发，这样做提高来网络的利用率。如果发生来拥塞（发送端接到来相同的ACK回复或者根本没有回复），那么首先\n> \n> > -  1.减少峰值的大小，减少一半。\n> > -  2.同时再从一个MSS发送数据。\n> > -  3.继续慢启动的过程\n>  \n> 上述过程就为慢启动和拥塞避免算法。\n> \n> b.当TCP发送出去一个段后，本地会有一个定时器启动起来，这个定时器在某一时间内如果收不到对方的应答，则证明本次发送失败，就会进行重传处理。\n> c.当TCP收到一个数据后，要进行ACK的确认给发送方。\n> \n> d. TCP保持在它首部的检验和，这个检验和是包含TCP头和应用数据的。这样在传输到过程中，如果数据有丢失，接收方通过重算检验和会发现异常，丢弃这个包。而UDP的检验和虽然有，但默认是关闭的，所以不可靠。\n> e.滑动窗口机制。是接收端的一个窗口，每次接收端都会给发送端回复的包中，含有接收端接收缓冲区的剩余大小。这样在发送端往本地发送数据的时候就不会多发，因为多发，会导致本地接收缓冲区溢出，造成数据的丢失。滑动窗口并不能判断网络的拥塞情况，只是判断缓冲区的大小。判断拥塞应该是拥塞窗口的事情。\n> \n> f.与UDP相比，它是有一个三次握手，四次分手的过程。\n\n### 7.TCP 连接 TIME_WAIT\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/55067698.jpg)\n\n> 上述到TIME_WAIT状态是2MSL（max segment life），意思就是当结束连接的时候，必须要等待一段时间。\n> 具体过程是：当服务端发给客户最后一个FIN之后，服务端要等待ACK，这时候，客户端会给服务端回ACK，假如ACK没有传送至服务端，如果没有TIMEWAIT机制的话，客户端就可以直接关闭掉，倒是后服务端就关不上来。所以应该设置一个等待时间，如果服务端往客户端发送FIN，超时来再重发，这时候由于有TIME——WAIT所以客户端再次接收一个FIN，则此时就会再给服务端发一个ACK。\n\n### 8.FTP主动模式和被动模式\n\n主动模式：\n> FTP客户机向服务器的FTP控制端口（默认是21）发送请求，服务器接受连接，建立一条命令链路，当需要传送数据时候，客户端在命令链路上用PORT命令告诉服务器：“我打开了某个端口，你过来连接我。”于是服务器从20端口向客户端的改端口发送连接请求，建立一条数据链路来传送数据。在数据链路建立的过程中是服务器主动请求，所以称为主动模式。 \n> FTP 主动模式（命令行是主动模式）\n> 服务器用20号端口，主动连接客户机的大于1024的随机端口。\n> \n> 被动模式：\n> FTP客户端向服务器的FTP控制端口发送连接请求，服务器接收连接，建立一条命令链路，当需要传送数据时候，服务器在命令链路上用PASV命令告诉客户端；“我打开了某端口，你过来连接我。”于是客户端向服务器的该端口发送连接请求，建立一条数据链路来传送数据。在数据链路建立的过程中是服务器被动等待客户端请求，所以称为被动模式。\n\n---\n\n> FTP被动模式\n> 客户机用大于1024的随机端口，主动连接服务器大于1024的随机端口。\n> \n> 主动模式下的FTP服务器，需要在服务器和客户端之间的防火墙中设置一下策越：\n> 允许FTP客户机从大于1024的端口连接FTP服务器的21端口\n> 允许FTP服务器从21端口回应FTP客户机中大于1024端口的网络连接。\n> 允许FTP服务器从20端口主动连接FTP客户机中大于1024的端口\n> 允许FTP客户机从大于1024的端口回应来自FTP服务器20端口的网络连接\n> \n> 被动模式下的FTP服务器，需要在服务器和客户端之间的防火墙中设置一下策越：\n> 允许FTP客户机从大于1024的端口连接FTP服务器的21端口\n> 允许FTP服务器从21端口回应FTP客户机中大于1024端口的网络连接。\n> 允许FTP客户机从大于1024端口主动连接FTP服务器中大于1024的端口\n> 允许FTP服务器从大于1024的端口回应来自FTP客户机大于1024端口的网络连接\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/20845911.jpg)\n\n### 9.既然已经有了ip的分片，那么为什么还需要有tcp的分段？\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/72824121.jpg)\n\n### 10.[数据帧封装格式、MTU、MSS](http://infotech.blog.51cto.com/391844/123859 )\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/12035922.jpg)\n\n### 11.TCP、UDP、IP报文头部\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/22300570.jpg)![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/48048979.jpg)\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/59323400.jpg)\n### 12.iptables\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/41832642.jpg)\n### 13.三次握手\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/40534034.jpg)\n### NAT透传！\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/2700751.jpg)","slug":"wangluo","published":1,"updated":"2015-08-10T14:51:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j1s000eo9d3vxz0u4ft"},{"title":"ssh 反向代理","date":"2014-10-16T18:01:01.000Z","_content":"\n为了解决无法突破对远端设备所在内网访问的限制，ssh提供了一套反向代理机制来解决问题。\n\n<!--more-->\n## 1.原理图\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-9/58003707.jpg)\n\n## 2.使用方法\n##### 2.1 在A下\n\n```\nssh -NfR 2222:localhost:22 httpd@100.100.100.100 -p 22\n```\n（连接对方22的端口，并把B主机的2222端口 与 本地A主机的22端口映射，即建立通信线路。用httpd这个用户名登陆B主机，B主机ip为100.100.100.100）\n##### 2.2 在B下\n\n```\nssh -p 2222 exe@localhost\n```\n\n（B主机通过ssh客户端连接自己本地的2222端口，并用exe登陆远程A主机）\n\n（也可以不用输入exe@，直接输入ssh -p 2222 localhost即可）\n\n**这里需要说明的是，为了使B区分不同的远程主机，即可用端口号加以区分。**\n\n##### 2.3 为了解决内网A主机 第一次主动连接B主机时，需要输入密码的问题，还有ssh生命周期时间太短的问题。我们可以采用ssh-keygen和autossh解决。\n\na.在A主机上键入：\n```\nssh-keygen\n```\n ，依次点下去，会在~目录下的.ssh/中生成一个ida_rsa.pub的文件，把这个文件通过scp拷贝到远程主机B上\n\nb.在B主机上键入：\n```\ncat ida_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n\n此时，A主机已经免输密码。\n\nc.接着我们在A主机下安装一个autossh （ubuntu可采用apt-get install autossh安装，嵌入式设备可能需要移植）\n\n~~d.在A主机上键入 \n```\nautossh -M 5678 -NR 2222:localhost:22 root@100.100.100.100 -p 22  & \n```\n\n此时，A主机与B主机的SSH通道一直会保持在线了。~~\n\n\n##### 2.4 经测试发现，这条命令并不适用于3G网卡传输的方式，因为3G的无线传输方式本身就有传输可能会断掉的缺点。如果A主机端为一个3G网络的环境，那么需要在A主机上使用以下方法解决。\nd1.    \n```\nautossh -M 0 -q -N -o ServerAliveInterval=10 -o ServerAliveCountMax=3 -R 44444:localhost:22 root@100.100.100.100\n```\n这条命令的作用比上一条多了一个心跳信息，就是说A主机的ssh每隔10秒会主动给B主机的sshd发送心跳信息，这时候B主机sshd会给予A主机ssh一个响应信息，这是一个过程，如果B主机没有给予ssh一个响应信息，那么ServerAliveCountMax值+1，当ServerAliveCountMax等于3时，ssh客户端认为已经断掉，这时候ssh会自己关闭相关端口和进程，然后由autossh自动启动ssh客户端，再一次连接，也就是说完成一次检测网络状态，需要30秒，如果30秒，由于网络阻塞或者其他问题，那么ssh会主动关闭。\n\nd2.   另外，由于是3G网络环境（测试发现，如果3G网络异常断开，那么autossh进程会死掉），所以需要加入一小段监控的shell脚本，定期检测autossh是否存在，如果不存在则重启，如果存在阻塞几秒继续监控。\n\nd3.   上边配置了A主机，还需要配置B主机（服务器），首先要说的是，当用d1的那条命令后，会使得服务器端ssh连接异常，也就是说putty可能登陆不上去，重启也无效（这个可能是特例，总之咱不知道具体原因），查了一些资料，说是要更改ssh客户端的配置即可（这里不明白），具体做法是/etc/ssh/ssh_config这个文件中，加入ServerAliveInterval 60即可，据说是防被踢，但是不理解。。。。。\n\nd4. 另外我们使用netstat -antp命令可以看到linux当前网络的端口占用情况。测试的时候我发现A主机的3G网络异常断开之后，A主机的autossh自然死掉了。但是在B主机netstat -antp时，还是可以看到系统在监听44444端口，后边的进程是sshd 服务端程序启动的，如果我们在B主机上不做任何设置，那么会导致B主机44444端口一直处于无效状态，即便A主机设置重新启动autossh，也无法再B主机通过44444与A主机建立连接。解决方法是打开/etc/ssh/sshd_config配置文件，在最后边添加或者更改ClientAliveIntercal 10 还有 ClientAliveCountMax 3即可，意思就是说sshd服务端程序主动去发送小心给客户端（A主机），A主机如果与B保持连接，那么肯定会给予B回复，否则不回，这样就是使得10秒之后，count值+1，直到3，sshd程序就会主动把占用端口的sshd子进程杀掉，让出端口来。这时候就等待A主机建立连接就可以了！\n> \n> 副：测试发现，也有小概率出现，在A主机端发现autossh进程在，ssh进程也在，但是在B主机端用netstat -antp发现没有在监听44444端口。这时，需要在B主机端主动杀掉netstat -antp结果中那个本地22的端口后边对应的sshd:root所在的pid号。这时，你再netstat -antp，会发现44444已经出来了，在A主机上，ps可以看到autossh进程号没有改变，但是ssh进程改变了，是因为B主机端主动杀掉了连接，所以ssh又一次重连。 \n> \n如果想要A主机重启之后，也可以保持自动ssh反向连接，那么需要追加到相应脚本下实现开机自启动。\n\n## 参考文献\n\nhttp://www.jb51.net/hack/58514.html\n\nhttp://blog.chinaunix.net/uid-20109107-id-2954579.html\n\nhttp://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html","source":"_posts/sshreverse.md","raw":"title: ssh 反向代理    \ndate: 2014-10-16 14:01:01\ncategories: 网络技术 \ntags: [ssh反向代理,ssh,穿越内网] \n\n---\n\n为了解决无法突破对远端设备所在内网访问的限制，ssh提供了一套反向代理机制来解决问题。\n\n<!--more-->\n## 1.原理图\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-9/58003707.jpg)\n\n## 2.使用方法\n##### 2.1 在A下\n\n```\nssh -NfR 2222:localhost:22 httpd@100.100.100.100 -p 22\n```\n（连接对方22的端口，并把B主机的2222端口 与 本地A主机的22端口映射，即建立通信线路。用httpd这个用户名登陆B主机，B主机ip为100.100.100.100）\n##### 2.2 在B下\n\n```\nssh -p 2222 exe@localhost\n```\n\n（B主机通过ssh客户端连接自己本地的2222端口，并用exe登陆远程A主机）\n\n（也可以不用输入exe@，直接输入ssh -p 2222 localhost即可）\n\n**这里需要说明的是，为了使B区分不同的远程主机，即可用端口号加以区分。**\n\n##### 2.3 为了解决内网A主机 第一次主动连接B主机时，需要输入密码的问题，还有ssh生命周期时间太短的问题。我们可以采用ssh-keygen和autossh解决。\n\na.在A主机上键入：\n```\nssh-keygen\n```\n ，依次点下去，会在~目录下的.ssh/中生成一个ida_rsa.pub的文件，把这个文件通过scp拷贝到远程主机B上\n\nb.在B主机上键入：\n```\ncat ida_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n\n此时，A主机已经免输密码。\n\nc.接着我们在A主机下安装一个autossh （ubuntu可采用apt-get install autossh安装，嵌入式设备可能需要移植）\n\n~~d.在A主机上键入 \n```\nautossh -M 5678 -NR 2222:localhost:22 root@100.100.100.100 -p 22  & \n```\n\n此时，A主机与B主机的SSH通道一直会保持在线了。~~\n\n\n##### 2.4 经测试发现，这条命令并不适用于3G网卡传输的方式，因为3G的无线传输方式本身就有传输可能会断掉的缺点。如果A主机端为一个3G网络的环境，那么需要在A主机上使用以下方法解决。\nd1.    \n```\nautossh -M 0 -q -N -o ServerAliveInterval=10 -o ServerAliveCountMax=3 -R 44444:localhost:22 root@100.100.100.100\n```\n这条命令的作用比上一条多了一个心跳信息，就是说A主机的ssh每隔10秒会主动给B主机的sshd发送心跳信息，这时候B主机sshd会给予A主机ssh一个响应信息，这是一个过程，如果B主机没有给予ssh一个响应信息，那么ServerAliveCountMax值+1，当ServerAliveCountMax等于3时，ssh客户端认为已经断掉，这时候ssh会自己关闭相关端口和进程，然后由autossh自动启动ssh客户端，再一次连接，也就是说完成一次检测网络状态，需要30秒，如果30秒，由于网络阻塞或者其他问题，那么ssh会主动关闭。\n\nd2.   另外，由于是3G网络环境（测试发现，如果3G网络异常断开，那么autossh进程会死掉），所以需要加入一小段监控的shell脚本，定期检测autossh是否存在，如果不存在则重启，如果存在阻塞几秒继续监控。\n\nd3.   上边配置了A主机，还需要配置B主机（服务器），首先要说的是，当用d1的那条命令后，会使得服务器端ssh连接异常，也就是说putty可能登陆不上去，重启也无效（这个可能是特例，总之咱不知道具体原因），查了一些资料，说是要更改ssh客户端的配置即可（这里不明白），具体做法是/etc/ssh/ssh_config这个文件中，加入ServerAliveInterval 60即可，据说是防被踢，但是不理解。。。。。\n\nd4. 另外我们使用netstat -antp命令可以看到linux当前网络的端口占用情况。测试的时候我发现A主机的3G网络异常断开之后，A主机的autossh自然死掉了。但是在B主机netstat -antp时，还是可以看到系统在监听44444端口，后边的进程是sshd 服务端程序启动的，如果我们在B主机上不做任何设置，那么会导致B主机44444端口一直处于无效状态，即便A主机设置重新启动autossh，也无法再B主机通过44444与A主机建立连接。解决方法是打开/etc/ssh/sshd_config配置文件，在最后边添加或者更改ClientAliveIntercal 10 还有 ClientAliveCountMax 3即可，意思就是说sshd服务端程序主动去发送小心给客户端（A主机），A主机如果与B保持连接，那么肯定会给予B回复，否则不回，这样就是使得10秒之后，count值+1，直到3，sshd程序就会主动把占用端口的sshd子进程杀掉，让出端口来。这时候就等待A主机建立连接就可以了！\n> \n> 副：测试发现，也有小概率出现，在A主机端发现autossh进程在，ssh进程也在，但是在B主机端用netstat -antp发现没有在监听44444端口。这时，需要在B主机端主动杀掉netstat -antp结果中那个本地22的端口后边对应的sshd:root所在的pid号。这时，你再netstat -antp，会发现44444已经出来了，在A主机上，ps可以看到autossh进程号没有改变，但是ssh进程改变了，是因为B主机端主动杀掉了连接，所以ssh又一次重连。 \n> \n如果想要A主机重启之后，也可以保持自动ssh反向连接，那么需要追加到相应脚本下实现开机自启动。\n\n## 参考文献\n\nhttp://www.jb51.net/hack/58514.html\n\nhttp://blog.chinaunix.net/uid-20109107-id-2954579.html\n\nhttp://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html","slug":"sshreverse","published":1,"updated":"2015-08-09T11:35:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j27000lo9d3jp8n5d05"},{"title":"程序设计的几种设计模式","date":"2015-08-10T16:31:49.000Z","_content":"**在程序设计中往往想到哪里就写到哪里，涉及到设计模式的思想用到实现中确实不多，总结下常用的，对于后期需要的只能之后用到再补充，这样做以免自己一次性学的太多，记的不牢靠。每个设计模式后都有C++实现，并配图便于理解。**\n<!--more-->\n### 目录\n> 1. 单例模式  \n> 2. 简单工厂模式\n> 3. 工厂模式\n> 4. 抽象工厂模式\n> 5. 策略模式\n> 6. 装饰者模式\n> 7. 观察者模式\n\n### 1.单例模式\n> 单例模式就是在程序的运行周期内，只有一个类的实例在运行。  \n> > 他为了解决某一个程序执行相同的操作，但是每次使用，都需要分配内存，然后销毁，这样给系统带来了不必要的开销。所以只需要一个相同的实例，每次调用一次就完成工作。\n> > \n单例模式适合应用在工具类，常常与工厂模式配合使用。\n\n1.1 UML图\n\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/5097401.jpg)  \n1.2 实现  \n\n- 考虑防止创建多个实例，这样构造函数设置为private可解决。\n- 考虑防止多个线程操作类的时候，还是会创建多个实例。用lock同步\n\n```\n#include <iostream>\nusing namespace std;\n\nclass Singleton\n{\npublic:\n\tstatic Singleton *GetInstance()\n\t{\n\t\tif (m_Instance == NULL )\n\t\t{\n\t\t\tLock(); \n\t\t\tif (m_Instance == NULL )\n\t\t\t{\n\t\t\t\tm_Instance = new Singleton ();\n\t\t\t}\n\t\t\tUnLock(); \n\t\t}\n\t\treturn m_Instance;\n\t}\n\n\tstatic void DestoryInstance()\n\t{\n\t\tif (m_Instance != NULL )\n\t\t{\n\t\t\tdelete m_Instance;\n\t\t\tm_Instance = NULL ;\n\t\t}\n\t}\n\n\tint GetTest()\n\t{\n\t\treturn m_Test;\n\t}\n\nprivate:\n\tSingleton(){ m_Test = 0; }\n\tstatic Singleton *m_Instance;\n\tint m_Test;\n};\n\nSingleton *Singleton ::m_Instance = NULL;\n\nint main(int argc , char *argv [])\n{\n\tSingleton *singletonObj = Singleton ::GetInstance();\n\tcout<<singletonObj->GetTest()<<endl;\n\tSingleton ::DestoryInstance();\n\n\treturn 0;\n}\n```\n### 2.简单工厂模式\n> 简单工厂模式，它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。  \n\n2.1 UML图\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/4895436.jpg)\n2.2 实现\n- 每次需要新的工厂，比如说中国pizaa，在加上一个派生类，同时修改下simplepizzafacotry的判断条件。\n```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Pizza\n{\npublic:\n\tvirtual void Prapare() = 0;\n\tvirtual void Bake() = 0;\n};\n\nclass CheesePizza:public Pizza\n{\npublic:\n\n\tvoid Prapare()\n\t{\n\t\tcout << \"CheesePizza Prapare.\\n\";\n\t}\n\n\tvoid Bake()\n\t{\n\t\tcout << \"CheesePizza Bake.\\n\";\n\t}\n};\n\nclass VeggiePizza:public Pizza\n{\npublic:\n\n\tvoid Prapare()\n\t{\n\t\tcout << \"VeggiePizza Prapare.\\n\";\n\t}\n\n\tvoid Bake()\n\t{\n\t\tcout << \"VeggiePizza Bake.\\n\";\n\t}\n};\n\n\nclass SimplePizzaFactory\n{\npublic:\n\n\tstatic Pizza* CreatePizza(string type)\n\t{\n\t\tif (0 == type.compare(\"cheese\"))\n\t\t{\n\t\t\tpizza_ = new CheesePizza;\n\t\t}\n\t\telse if (0 == type.compare(\"veggie\"))\n\t\t{\n\t\t\tpizza_ = new VeggiePizza;\n\t\t}\n\n\t\treturn pizza_;\n\t}\n\nprivate:\n\tstatic Pizza* pizza_;\n};\n\nPizza* SimplePizzaFactory::pizza_ = NULL;\n\nint main()\n{\n\tSimplePizzaFactory::CreatePizza(\"cheese\")->Prapare();\n\tSimplePizzaFactory::CreatePizza(\"veggie\")->Prapare();\n\n\treturn 0;\n}\n\n\n```\n### 3.工厂模式\n>工厂模式与简单工厂模式相比有何优势？\n> > 简单工厂模式下，如果多了一个内容，比如说有北京，有日本，那么需要在simplePizzaFatory下添加判断，然后再去添加相关的产品生产类。这样就改动了原有的simplePizzaFactory类。不符合面向对象的思想。如果我们不改变原有的simplePizzaFactory,而是再加一层抽象，把这个类也变成抽象父类，最初一开始就指定要xxxx工厂帮我判断，然后xxxx工厂自行判断好，去告诉相关的生产商去生产产品就可以了。\n\n> >如下图所示：这时候如果想要添加一个合肥的pizza厂商帮我生产，那么分为两步：1.把HefeiPizzaFactory填写好，然后让其去判断是吃cheese还是吃veggie，然后再去写cheese还是veggie，这时候虽然麻烦一点，但是并不没有触动以前的类和方法。 \n\n\n3.1 UML图\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/90160599.jpg)\n3.2 实现\n\n```\n/*\n工厂模式\n*/\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Pizza\n{\npublic:\n\tvirtual void Production() = 0;\n};\n\nclass BeijingCheesePizza:public Pizza\n{\npublic:\n\n\tvoid Production()\n\t{\n\t\tcout << \"Beijing CheesePizza production.\\n\";\n\t}\n\n};\n\nclass BeijingVeggiePizza:public Pizza\n{\npublic:\n\n\tvoid Production()\n\t{\n\t\tcout << \"Beijing VeggiePizza Prapare.\\n\";\n\t}\n};\n\nclass JinanCheesePizza:public Pizza\n{\npublic:\n\n\tvoid Production()\n\t{\n\t\tcout << \"Jinan CheesePizza production.\\n\";\n\t}\n\n};\n\nclass JinanVeggiePizza:public Pizza\n{\npublic:\n\n\tvoid Production()\n\t{\n\t\tcout << \"Jinan VeggiePizza Prapare.\\n\";\n\t}\n};\n\nclass PizzaFactory\n{\npublic:\n\tvirtual Pizza* CreatePizza(string type) = 0;\n\n};\n\nclass BeijingPizzaFactory:public PizzaFactory\n{\npublic:\n\tPizza* CreatePizza(string type)\n\t{\n\t\tif (0 == type.compare(\"cheese\"))\n\t\t{\n\t\t\tpizza_ = new BeijingCheesePizza;\n\t\t}\n\t\telse if (0 == type.compare(\"veggie\"))\n\t\t{\n\t\t\tpizza_ = new BeijingVeggiePizza;\n\t\t}\n\t\treturn pizza_;\n\t}\n\nprivate:\n\n\tPizza* pizza_;\n};\n\nclass JinanPizzaFactory:public PizzaFactory\n{\npublic:\n\tPizza* CreatePizza(string type)\n\t{\n\t\tif (0 == type.compare(\"cheese\"))\n\t\t{\n\t\t\tpizza_ = new JinanCheesePizza;\n\t\t}\n\t\telse if (0 == type.compare(\"veggie\"))\n\t\t{\n\t\t\tpizza_ = new JinanVeggiePizza;\n\t\t}\n\t\treturn pizza_;\n\t}\n\nprivate:\n\n\tPizza* pizza_;\n};\n\nint main()\n{\n\tPizzaFactory *beijing = new BeijingPizzaFactory;\n\tbeijing->CreatePizza(\"veggie\")->Production();\n\n\tPizzaFactory* jinan = new JinanPizzaFactory;\n\tjinan->CreatePizza(\"cheese\")->Production();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n```\n\n### 参考文献\n\nhttp://www.jellythink.com/archives/82\nhttp://blog.chinaunix.net/uid-25510439-id-3073218.html\nhttp://www.cnblogs.com/cxjchen/p/3143633.html","source":"_posts/shejimoshi.md","raw":"title: 程序设计的几种设计模式    \ndate: 2015-8-10 12:31:49\ncategories: 程序设计\ntags: [设计模式,C++实现] \n---\n**在程序设计中往往想到哪里就写到哪里，涉及到设计模式的思想用到实现中确实不多，总结下常用的，对于后期需要的只能之后用到再补充，这样做以免自己一次性学的太多，记的不牢靠。每个设计模式后都有C++实现，并配图便于理解。**\n<!--more-->\n### 目录\n> 1. 单例模式  \n> 2. 简单工厂模式\n> 3. 工厂模式\n> 4. 抽象工厂模式\n> 5. 策略模式\n> 6. 装饰者模式\n> 7. 观察者模式\n\n### 1.单例模式\n> 单例模式就是在程序的运行周期内，只有一个类的实例在运行。  \n> > 他为了解决某一个程序执行相同的操作，但是每次使用，都需要分配内存，然后销毁，这样给系统带来了不必要的开销。所以只需要一个相同的实例，每次调用一次就完成工作。\n> > \n单例模式适合应用在工具类，常常与工厂模式配合使用。\n\n1.1 UML图\n\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/5097401.jpg)  \n1.2 实现  \n\n- 考虑防止创建多个实例，这样构造函数设置为private可解决。\n- 考虑防止多个线程操作类的时候，还是会创建多个实例。用lock同步\n\n```\n#include <iostream>\nusing namespace std;\n\nclass Singleton\n{\npublic:\n\tstatic Singleton *GetInstance()\n\t{\n\t\tif (m_Instance == NULL )\n\t\t{\n\t\t\tLock(); \n\t\t\tif (m_Instance == NULL )\n\t\t\t{\n\t\t\t\tm_Instance = new Singleton ();\n\t\t\t}\n\t\t\tUnLock(); \n\t\t}\n\t\treturn m_Instance;\n\t}\n\n\tstatic void DestoryInstance()\n\t{\n\t\tif (m_Instance != NULL )\n\t\t{\n\t\t\tdelete m_Instance;\n\t\t\tm_Instance = NULL ;\n\t\t}\n\t}\n\n\tint GetTest()\n\t{\n\t\treturn m_Test;\n\t}\n\nprivate:\n\tSingleton(){ m_Test = 0; }\n\tstatic Singleton *m_Instance;\n\tint m_Test;\n};\n\nSingleton *Singleton ::m_Instance = NULL;\n\nint main(int argc , char *argv [])\n{\n\tSingleton *singletonObj = Singleton ::GetInstance();\n\tcout<<singletonObj->GetTest()<<endl;\n\tSingleton ::DestoryInstance();\n\n\treturn 0;\n}\n```\n### 2.简单工厂模式\n> 简单工厂模式，它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。  \n\n2.1 UML图\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/4895436.jpg)\n2.2 实现\n- 每次需要新的工厂，比如说中国pizaa，在加上一个派生类，同时修改下simplepizzafacotry的判断条件。\n```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Pizza\n{\npublic:\n\tvirtual void Prapare() = 0;\n\tvirtual void Bake() = 0;\n};\n\nclass CheesePizza:public Pizza\n{\npublic:\n\n\tvoid Prapare()\n\t{\n\t\tcout << \"CheesePizza Prapare.\\n\";\n\t}\n\n\tvoid Bake()\n\t{\n\t\tcout << \"CheesePizza Bake.\\n\";\n\t}\n};\n\nclass VeggiePizza:public Pizza\n{\npublic:\n\n\tvoid Prapare()\n\t{\n\t\tcout << \"VeggiePizza Prapare.\\n\";\n\t}\n\n\tvoid Bake()\n\t{\n\t\tcout << \"VeggiePizza Bake.\\n\";\n\t}\n};\n\n\nclass SimplePizzaFactory\n{\npublic:\n\n\tstatic Pizza* CreatePizza(string type)\n\t{\n\t\tif (0 == type.compare(\"cheese\"))\n\t\t{\n\t\t\tpizza_ = new CheesePizza;\n\t\t}\n\t\telse if (0 == type.compare(\"veggie\"))\n\t\t{\n\t\t\tpizza_ = new VeggiePizza;\n\t\t}\n\n\t\treturn pizza_;\n\t}\n\nprivate:\n\tstatic Pizza* pizza_;\n};\n\nPizza* SimplePizzaFactory::pizza_ = NULL;\n\nint main()\n{\n\tSimplePizzaFactory::CreatePizza(\"cheese\")->Prapare();\n\tSimplePizzaFactory::CreatePizza(\"veggie\")->Prapare();\n\n\treturn 0;\n}\n\n\n```\n### 3.工厂模式\n>工厂模式与简单工厂模式相比有何优势？\n> > 简单工厂模式下，如果多了一个内容，比如说有北京，有日本，那么需要在simplePizzaFatory下添加判断，然后再去添加相关的产品生产类。这样就改动了原有的simplePizzaFactory类。不符合面向对象的思想。如果我们不改变原有的simplePizzaFactory,而是再加一层抽象，把这个类也变成抽象父类，最初一开始就指定要xxxx工厂帮我判断，然后xxxx工厂自行判断好，去告诉相关的生产商去生产产品就可以了。\n\n> >如下图所示：这时候如果想要添加一个合肥的pizza厂商帮我生产，那么分为两步：1.把HefeiPizzaFactory填写好，然后让其去判断是吃cheese还是吃veggie，然后再去写cheese还是veggie，这时候虽然麻烦一点，但是并不没有触动以前的类和方法。 \n\n\n3.1 UML图\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/90160599.jpg)\n3.2 实现\n\n```\n/*\n工厂模式\n*/\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Pizza\n{\npublic:\n\tvirtual void Production() = 0;\n};\n\nclass BeijingCheesePizza:public Pizza\n{\npublic:\n\n\tvoid Production()\n\t{\n\t\tcout << \"Beijing CheesePizza production.\\n\";\n\t}\n\n};\n\nclass BeijingVeggiePizza:public Pizza\n{\npublic:\n\n\tvoid Production()\n\t{\n\t\tcout << \"Beijing VeggiePizza Prapare.\\n\";\n\t}\n};\n\nclass JinanCheesePizza:public Pizza\n{\npublic:\n\n\tvoid Production()\n\t{\n\t\tcout << \"Jinan CheesePizza production.\\n\";\n\t}\n\n};\n\nclass JinanVeggiePizza:public Pizza\n{\npublic:\n\n\tvoid Production()\n\t{\n\t\tcout << \"Jinan VeggiePizza Prapare.\\n\";\n\t}\n};\n\nclass PizzaFactory\n{\npublic:\n\tvirtual Pizza* CreatePizza(string type) = 0;\n\n};\n\nclass BeijingPizzaFactory:public PizzaFactory\n{\npublic:\n\tPizza* CreatePizza(string type)\n\t{\n\t\tif (0 == type.compare(\"cheese\"))\n\t\t{\n\t\t\tpizza_ = new BeijingCheesePizza;\n\t\t}\n\t\telse if (0 == type.compare(\"veggie\"))\n\t\t{\n\t\t\tpizza_ = new BeijingVeggiePizza;\n\t\t}\n\t\treturn pizza_;\n\t}\n\nprivate:\n\n\tPizza* pizza_;\n};\n\nclass JinanPizzaFactory:public PizzaFactory\n{\npublic:\n\tPizza* CreatePizza(string type)\n\t{\n\t\tif (0 == type.compare(\"cheese\"))\n\t\t{\n\t\t\tpizza_ = new JinanCheesePizza;\n\t\t}\n\t\telse if (0 == type.compare(\"veggie\"))\n\t\t{\n\t\t\tpizza_ = new JinanVeggiePizza;\n\t\t}\n\t\treturn pizza_;\n\t}\n\nprivate:\n\n\tPizza* pizza_;\n};\n\nint main()\n{\n\tPizzaFactory *beijing = new BeijingPizzaFactory;\n\tbeijing->CreatePizza(\"veggie\")->Production();\n\n\tPizzaFactory* jinan = new JinanPizzaFactory;\n\tjinan->CreatePizza(\"cheese\")->Production();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n```\n\n### 参考文献\n\nhttp://www.jellythink.com/archives/82\nhttp://blog.chinaunix.net/uid-25510439-id-3073218.html\nhttp://www.cnblogs.com/cxjchen/p/3143633.html","slug":"shejimoshi","published":1,"updated":"2015-08-10T06:52:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j2p000uo9d3khvd4p9d"},{"title":"phpmyadmin导入excel表格->mysql","date":"2015-07-26T00:23:23.000Z","description":"介绍phpmyadmin导入excel的方法","_content":"\n### 写在开头\n帮助文档以phpMyadmin数据库建表开始，然后再到后边的用csv导入到数据库表中。写这些的目的是 因为插入的东西是中文，所以需要注意编码问题。\n<!--more-->\n### 用到的工具\nexcel，phpmyadmin，emeditor\n### 过程\n- phpMyadmin建表\n登陆lorne.pw/database中，在新建数据库中写上数据库名字 divider，整理选择utf8_general_ci，然后点击创建。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/98049354.jpg)\n\n- 选择进入数据库divider，然后选择新建一张表，写上名字dividerInfo，并写上字段5个，然后点击执行。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/10194909.jpg)\n\n- 在这张新建数据表的窗口下，点击添加各字段详细信息，如下，值得注意的是中文用varchar就好，长度写上大概的就可以：\n\n![image description](http://img-storage.qiniudn.com/15-8-8/61706716.jpg)\n\n- 在同一个窗口下，注意选择整理：然后选择utf8_general_ci，然后点击保存表就建好了。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/5406617.jpg)\n\n- 新建excel表格，编辑学生信息，如下所示：\n（注意列的顺序与表要严格一致，第一行不需要些字段名称）\n\n![image description](http://img-storage.qiniudn.com/15-8-8/20837690.jpg)\n\n- 编辑完点击文件-另存为-计算机，然后弹出对话框，点击对话框的工具-web选项-编码。\n\n\n![image description](http://img-storage.qiniudn.com/15-8-8/87494927.jpg)\n\n- 选择将此文档另存为uniconde(UTF-8),然后点击确定，此时进入第10步。\n\n\n![image description](http://img-storage.qiniudn.com/15-8-8/5380601.jpg)\n\n- 在下图中选择保存为csv格式。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/54058994.jpg)\n\n\n- 此时桌面出现csv格式后，这时就可以进入12步，把csv上传到phpMyadmin中。\n在phpMyadmin主界面，选择数据库divider，然后选择表dividerInfo，最后选择导入。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/91318425.jpg)\n\n- 选择从计算机中上传student.csv文件。其他不用管，配置如图所示。\n\n ![image description](http://img-storage.qiniudn.com/15-8-8/44047196.jpg)\n\n- 此时还需要一步，就是在桌面生成的student.csv文件，右键用windows自带的记事本打\n\n ![image description](http://img-storage.qiniudn.com/15-8-8/60755242.jpg)\n \n*** *附**\n ![image description](http://img-storage.qiniudn.com/15-8-8/28900338.jpg)\n \n** 其实有一种更为简单的方法，就是直接在桌面上右键新建一个txt，然后用自带的记事本编辑，\n比如编辑：\n11,胡威,99,三中,高一5班\n12,胡方法,10,二中,高一10班\n\n\n这个方法需要注意的事项是每个字段与每个字段之间的逗号必须要用英文的逗号。\n编辑结束后，点击文件另存为，选择编码为utf-8，保存为csv格式。这种方法不适合批量输入，因为不方便输入逗号\n**\n\n\n\n","source":"_posts/phpmyadmin.md","raw":"title: phpmyadmin导入excel表格->mysql \ndate: 2015-7-25 20:23:23\ncategories: 数据库技术 \ntags: [excel,phpmyadmin]\ndescription: 介绍phpmyadmin导入excel的方法\n---\n\n### 写在开头\n帮助文档以phpMyadmin数据库建表开始，然后再到后边的用csv导入到数据库表中。写这些的目的是 因为插入的东西是中文，所以需要注意编码问题。\n<!--more-->\n### 用到的工具\nexcel，phpmyadmin，emeditor\n### 过程\n- phpMyadmin建表\n登陆lorne.pw/database中，在新建数据库中写上数据库名字 divider，整理选择utf8_general_ci，然后点击创建。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/98049354.jpg)\n\n- 选择进入数据库divider，然后选择新建一张表，写上名字dividerInfo，并写上字段5个，然后点击执行。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/10194909.jpg)\n\n- 在这张新建数据表的窗口下，点击添加各字段详细信息，如下，值得注意的是中文用varchar就好，长度写上大概的就可以：\n\n![image description](http://img-storage.qiniudn.com/15-8-8/61706716.jpg)\n\n- 在同一个窗口下，注意选择整理：然后选择utf8_general_ci，然后点击保存表就建好了。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/5406617.jpg)\n\n- 新建excel表格，编辑学生信息，如下所示：\n（注意列的顺序与表要严格一致，第一行不需要些字段名称）\n\n![image description](http://img-storage.qiniudn.com/15-8-8/20837690.jpg)\n\n- 编辑完点击文件-另存为-计算机，然后弹出对话框，点击对话框的工具-web选项-编码。\n\n\n![image description](http://img-storage.qiniudn.com/15-8-8/87494927.jpg)\n\n- 选择将此文档另存为uniconde(UTF-8),然后点击确定，此时进入第10步。\n\n\n![image description](http://img-storage.qiniudn.com/15-8-8/5380601.jpg)\n\n- 在下图中选择保存为csv格式。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/54058994.jpg)\n\n\n- 此时桌面出现csv格式后，这时就可以进入12步，把csv上传到phpMyadmin中。\n在phpMyadmin主界面，选择数据库divider，然后选择表dividerInfo，最后选择导入。\n\n![image description](http://img-storage.qiniudn.com/15-8-8/91318425.jpg)\n\n- 选择从计算机中上传student.csv文件。其他不用管，配置如图所示。\n\n ![image description](http://img-storage.qiniudn.com/15-8-8/44047196.jpg)\n\n- 此时还需要一步，就是在桌面生成的student.csv文件，右键用windows自带的记事本打\n\n ![image description](http://img-storage.qiniudn.com/15-8-8/60755242.jpg)\n \n*** *附**\n ![image description](http://img-storage.qiniudn.com/15-8-8/28900338.jpg)\n \n** 其实有一种更为简单的方法，就是直接在桌面上右键新建一个txt，然后用自带的记事本编辑，\n比如编辑：\n11,胡威,99,三中,高一5班\n12,胡方法,10,二中,高一10班\n\n\n这个方法需要注意的事项是每个字段与每个字段之间的逗号必须要用英文的逗号。\n编辑结束后，点击文件另存为，选择编码为utf-8，保存为csv格式。这种方法不适合批量输入，因为不方便输入逗号\n**\n\n\n\n","slug":"phpmyadmin","published":1,"updated":"2015-08-09T05:51:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j390011o9d3wnqelb8o"},{"title":"OpenWRT编译之360路由器C301","date":"2014-10-16T18:01:01.000Z","_content":"\n备忘录分为三部分来描述，尽量做的详细一些，也算是给后人的一个参考。\n一.刷写第三方的uboot（刷不死的u-boot）\n\n二.编译内核（定制基础功能）\n\n三.OpenWRT挂3G网卡（华为E3276）\n\n<!--more-->\n## 一.刷写第三方的uboot（刷不死的u-boot）\n今天拿到手的360 c301，在官方系统的uboot上直刷 第三方 openwrt 。\n按住复位键，然后上电，10秒后待前边的灯 闪烁后 即表示 进入了uboot\n然后主机端 Ip要设置成192.168.1.x网段，这时候登陆web界面192.168.1.1就可以进入了官方自带的uboot，然后选择刷入 \n\n```\n//广告: 981213 大神的360路由全功能openwrt rom链接 http://www.right.com.cn/forum/thread-147319-1-1.html\n```\n我用的是flash1的。刷好之后，然后固件就成为了openwrt，这时候其实已经可以用了，但是为了以防万一，\n在之后的操作过程中，可能会损坏uboot，所以采用第三方的刷不死的Uboot, 这样自己编译的内核或者其他第三方的固件都\n随便刷了。\n之后：\n> 1.进入openwrt WEB界面把初始化的密码改成自己的    \n2.然后用winSCP客户端的SCP命令把我们提前下好的第三方刷不死uboot（http://www.right.com.cn/forum/thread-136444-1-1.html）传入路由器  \n3.用ssh登陆，并在/tmp目录下运行mtd write -r /tmp/u-boot.bin u-boot 命令刷入boot，这时路由器会自动重启    \n4.待重启好后即刷好了   \n5.以后所有的更新固件的操作，都要通过这个第三方的u-boot来做。（按下RESET键，上电等待10秒，再进入192.168.1.1,刚测试下，貌似只能用自带的网线。。。。。还有要注意的事，在更新的过程中，一定要用firefox或者chrome）\n\n## 二.编译openwrt\n\n#### 2.1    搭建编译环境\n我这边的环境是VMware下的ubuntu12.04，网上有说ubuntu版本最好用32位，64位可能有问题。另外需要apt-get一些基础的库和软件，如果缺少这一步，可能编译的过程中会报错，有可能缺少工具，如git，也有可能缺少库、头文件。\n```\nsudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip zip unrar p7zip p7zip-rar p7zip-full sharutils subversion libncurses5-dev ncurses-term zlib1g-dev gawk git-core  libpcre3-dev libssl-dev\n\n```\n\n#### 2.2    首先down下一份源码（分为两种，一种是trunk版，即开发版，另外一种是Barrier Breaker，即稳定版）\n由于我的这个C301官方支持只有trunk版，所以down的这个版本的，down分为两种，一种是svn，另外一种是git。\n\n```\nsvn co svn://svn.openwrt.org/openwrt/trunk/\n//接着到trunk目录下 \n./scripts/feeds update -a      //据说这部目录是更新package目录\n./scripts/feeds install -a      //安装package索引文件，这些文件个人感觉只是安装了一个索引，等编译的时候还要按需（make menuconfig）从指定地点下载\n```\n#### 2.3 接着就是配置了，这一步个人也许是整个编译的核心了，你所需要的功能都要在这步去做好。\n```\n //在源码目录下敲\n    make menuconfig \n```\n(测试发现，第一次make menuconfig 必须用普通用户，不能是root，所以如果是root下载的源码，记得要把整个源码目录chmod 777 \\*/\\* -R下，然后切换到普通用户，make menuconfig，以后再make menuconfig就不用普通用户了，root也可以的！)\n\n***以下是我从百度文库摘的极路由1S*，但是都大同小异，一些基础的配置按照这个来就够。**\n```\n选择LuCI 配置（web网页管理程序）：\nLuCI  ---> 1. Collections  --->  luci                                         启用LuCI\nLuCI  ---> 3. Applications  ---> luci-app-commands                         网页Shell \nLuCI  ---> 3. Applications  ---> luci-app-ddns                                动态域名\nLuCI  ---> 3. Applications  ---> luci-app-firewall                              防 火 墙\nLuCI  ---> 3. Applications  ---> luci-app-mwan3                              网络叠加\nLuCI  ---> 3. Applications  ---> luci-app-multiwan                            网络叠加\nLuCI  ---> 3. Applications  ---> luci-app-ntpc                           时间同步服务器\nLuCI  ---> 3. Applications  ---> luci-app-ocserv                           VPN Server\nLuCI  ---> 3. Applications  ---> luci-app-qos\nLuCI  ---> 3. Applications  ---> luci-app-samba                               网络共享\nLuCI  ---> 3. Applications  ---> luci-app-upnp\nLuCI  ---> 3. Applications  ---> luci-app-wol                                  网络唤醒\nLuCI  ---> 4. Themes  ---> luci-theme-bootstrap                             默认主题\nLuCI  ---> 4. Themes  ---> luci-theme-openwrt                          openwrt主题\nLuCI  ---> 5. Translations  --->  luci-i18n-chinese                            支持中文\n大家可以自行增减插件，保存设置后，重新编译下即可。\n \n文件系统、SD卡、USB配置：\nBase system  --->  block-mount                                              USB挂载\nKernel modules  --->  Filesystems  --->  kmod-fs-ext4              支持ext4文件系统\nKernel modules  --->  Filesystems  --->  kmod-fs-nfs                支持NFS文件系统\nKernel modules  --->  Filesystems  --->  kmod-fs-nfs-common\nKernel modules  --->  Filesystems  --->  kmod-fs-ntfs              支持NTFS文件系统\nKernel modules  --->  Filesystems  --->  kmod-fs-vfat             支持FAT32文件系统\nKernel modules  --->  Native Language Support  --->  kmod-nls-cp437       支持中文\nKernel modules  --->  Native Language Support  --->  kmod-nls-iso8859-1   支持中文\nKernel modules  --->  Native Language Support  --->  kmod-nls-utf8         支持中文\nKernel modules  --->  Other modules  --->  kmod-mmc                     支持SD卡\nKernel modules  --->  Other modules  --->  kmod-sdhci                     支持SD卡\nKernel modules  --->  Other modules  --->  kmod-sdhci-mt7620            支持SD卡\nKernel modules  --->  USB Support  --->  kmod-usb-ohci                 支持USB 1.0\nKernel modules  --->  USB Support  --->  kmod-usb-storage\nKernel modules  --->  USB Support  --->  kmod-usb-storage-extras\nKernel modules  --->  USB Support  --->  kmod-usb-uhci                 支持USB 1.1\nKernel modules  --->  USB Support  --->  kmod-usb2                     支持USB 2.0\n \n网络配置：\nNetwork  --->  ppp-mod-pppoe                                           PPPOE拨号模式\nNetwork  --->  ppp-mod-pptp                                                 VPN客户端\nNetwork  --->  SSH  --->  openssh-client                                    SSH客户端\n其实里面有很多软件，大家可以编译试一试的，番茄软件很多的哦！~\n \n应用程序配置：\nUtilities  --->  bzip2                                                            解压缩工具\nUtilities  --->  Compression  --->  unrar                                       解压缩工具\nUtilities  --->  Compression  --->  unzip                                       解压缩工具\nUtilities  --->  Compression  --->  zip                                           压缩工具\nUtilities  --->  Filesystem  --->  badblocks                             支持ext2文件系统\nUtilities  --->  Filesystem  --->  e2fsprogs                 支持ext2/ext3/ext4格式化工具\nUtilities  --->  disc  --->  fdisk                                                   分区工具\n```\n\n除了上边的配置，以下我标注几个对自己需求比较重要的，其他的省略\n\n第一个Target System ，这里边就是要选你的路由器所对应的cpu的型号。如果路由器有两颗芯片，以第一个cpu为主，C301路由器主芯片为AR9344，所以我选择Atheros AR7XXX / AR9XXX,这个可能要靠一些经验了，我对硬件的芯片区分的也不是很好，最好去相应的论坛找找路由器对应的芯片类型。\n\n第二个Subtarget，选择Generic即可。这一步我不是特别明白，这一选项跟你上边的targetsystem有关，如果换一个芯片的话，这里可能还要选择对应的版本，目前尚不清晰。\n    \n第三个target profile 选择路由器型号。一般比较通用。\n    \n> （我down了一份BB版的源码，在这里找qihooC301没有找到，所以就是不支持，后来算下日子才知道，恩山的HACK大哥9月份才提交的patch，正式被官方录用。bb是7月出来的，肯定没有了！这里啰嗦几句，什么Kamikaze ，backfire ，attitude adjustment， barrier breaker 和trunk都是什么意思，之前我也模糊，后来去官方wiki，https://dev.openwrt.org/wiki/GetSource，感觉标注跟linux一贯的风格差不多，ubuntu两年一个正式版，openwrt最近也是两年，但时间并不确定，所以这样来看我也就清楚了。前面的这几个都是openwrt的正式版本，从老版本到最新版本，都是稳定版。后边的这个trunk是开发版，也就是功能涵盖barrier breaker，但是还在慢慢的添加新功能。所以如果你不是特意的获取trunk的老版，你获取到的永远是最新的，trunk官方源码一两天就更新一次,更新速度特别快，可以用svn log 网址来看下）\n\n这几个大选项 global build settings ,advaced configureation options , build the openwrt image builder ,build the openwrt sdk ,package the openwrt-based toolchain ,image configuration 目前我还没用到，所以不清楚具体含义和用法。\n\n  在大项Base system下，基本上没有动，还是按照op默认的配置来做的，值得要说的是，这里边的busybox，大家都知道busybox是一个嵌入式的linux shell集成工具，嵌入式的linux基本上所有的命令都是出自这里边（我所说的当然不包括一些第三方的package软件包的命令了）。如果有需求，可以进去打开一些命令，比如lsusb就可以在这里边打开，不然默认是没有的，除非你在其它的package安装usbutils（在大项utils下）。\n\n    Administrator默认。\n\n    Boot Loaders 默认。\n\n    Devlopment 默认。\n\n    Firmware 默认。\n    \n大项Kernel modules，这里边的选项，个人感觉是最重要的一个了，有很多功能如果这里边不选择好，那么将会非常麻烦，以后的固件可能很多功能用不了。结合我自己的C301进行定制。对于需要的功能。首先是无线，C301是双频的wifi，有2.4G和5G，分为两个网卡。所以在这里边的Wireless Drivers把Kmod-ath10k和kmod-ath9k，kmod-ath9k-common都要选上！因为C301自带一个usb口，所以我们进入usb support,把kmod-usb-core kmod-usb-ohci kmod-usb-storage-extras kmod-usb-uhci kmod-usb2都选上。在network support 下，把ppp的选项都选上，不然 无法拨号上网。由于360这个路由器还有一个LED，所以还要选下LED modules，我选的是gpio defaulton ledtrig gpio timer usbdev，这几项选上，我这边led显示是正常的，不过跟官方的那种亮不一样，我这个是一闪一闪的，不过感觉还可以！！！！内核在结合上边的就差不多了。\n\n还有比较重要的两个，这两个是个性化 定制的东西，一般的package小软件，都在这两个下面。功能非常丰富而且强大！\n按照我目前的需求来的，我用到了network下的File transfer下的lftp，这是一个ftp的客户端，我这需求类似的可能比较小。还有SSH这里边我全选了。VPN也可以选。。。至于utilities里边，我用到了usbutils和usb-modeswitch（挂3G网卡）\n\n至此。配置结束了。\n\n> 接下来还有很重要的一步才可以编译。这也算是openwrt官方Trunk的一个BUG（至少在现在14年10月份没有解决呢），估计以后会修复的。\n就是如果配置结果make，然后编译好的固件，你刷上去是没有无线的（2.4G和5G都没办法启动），所以需要替换掉一个目前源码工程目录下的mac80211下的东西。具体做法：\n在现在用的trunk源码目录外新建一个文件夹testop，然后进入testop，down一份之前的代码。svn co -r42681 svn://svn.openwrt.org/openwrt/trunk，之所以用这个版本，是因为这个版本的的2.4G是正常的，（也就是说5G不正常，所以不能用，但现在wifi大多数还是2.4G的！），down下来之后，然后把test源码目录下的pakcage/kernel/mac80211/Makefile和pakcage/kernel/mac80211/patches替换到之前的trunk源码的package/kernel/mac80211下。\n\n这时配置才算真正结束。\n\nmake V=99 或者 make j=cpu核数+1 都可以，就执行编译了。\n编译完之后会在源码目录下的bin下生诚ar7XXX的文件夹，打开之后就会看到我们的固件和packages包，这个包是好东西，因为和你的路由器是配套的，里边的软件你路由器可以直接安装。并不是所有ipk结尾的文件都能在路由器上安装，也并不是同一个cpu平台的通用，也可以说同型号的路由器ipk都可能不通用。所以这个文件夹的packages还是很有用的，保存好，之后做一个局域网软件源，从路由器直接到这里下载软件就可以了。。\n\n## OpenWRT挂3G网卡（华为E3276）\n\n首先要说的是，华为的大部分3G网卡都支持linux，也就是说openwrt只要是配置好，是完全能够支持的（当然你需要有一个usb口）.\n\n我们需要几个东西，PPP、usb-serial、usb-modeswitch,与此同时，usb的一些选项也要加进去，例如USB2.0、usb1.0、usb-storage等。\n我们所需要的是在/dev/目录下看到ttyUSB0和ttyUSB1，虽然linux驱动能够识别3G网卡，但是如果想让其工作，还需要使之拨号，这就需要ttyUSB0这个接口了，我们可以把她想象成以太网口，例如eth1。原来广域网口wan出去是从eth1走的，现在wan出去是通过ttyUSB0。另一方面，据说在BB版本（openwrt 14.07）没有出现之前，我们即便装了usb-serial也不能看到/dev/下有ttyUSB,还需要设置才可以（老版本的设置请参照下边的某老外论坛上的参考文献，另外为了识别你网卡产品的Device ID,你在openwrt下需要一个命令，lsusb，这个命令你在编译openwrt的时候可以在busybox里选上，也可以勾选上在Utilities/下的USButils）。话说回来，现在的BB版和trunk版就方便多了，直接在内核中选上usb-serial就可以看到/dev/ttyUSB0和/dev/ttyUSB1了。\n\n这几个东西具体的位置，usb-serial在内核目录下的USB support下，值得一提的是，你需要把Kmod-usb-serial-option和kmod-usb-serial-wwan、还有mod-us-serial-ipw选上。ppp在network模块下，一般这个都会编的。。。usb-modeswitch在Utilities下。USB的一些常用选项都在内核目录下的USB SUPPORT下。\n\n\n配置好了。然后就可以编译进固件中了。\n\n至于启动3G拨号。有两种方式，一个是shell中的操作，一个是web页面的操作。我用的是web上的操作，在网络，接口，找到wan，点击修改。\n然后在协议中找到UMTS/GPRS/EV-DO这一项。点击切换协议，然后在调制解调器节点 选择/dev/ttyUSB0,服务类型选择UMTS/GPRS (即3G/2G网)其他的留空就可以直接点保存应用了。过一会就看到ISP给分配的ipv4地址了。ping下外网是可以通的。\n\n切换到原来的上网模式，选择原来的模式即可，我这边的环境是dhcp自动分配的，我就选择dhcp自动获取ip。然后点击保存会提示物理的端口需要选择，点击物理设置，桥接接口 不选，直接选中接口中的eth1即可，因为eth1对应于路由器上的wan口。\n\n\n至此3G配置结束！\n副：路由器如果只有一个USB口，请慎用USB-HUB，经本人实际测试，插USB-HUB确实可以使用，3G网卡，U盘，都可以用，这几天一直有个ssh的连接在用，我发现ssh总是无故断掉，找了好半天原因找不到。ps发现pppd这个进程总是断掉重启，所以我用ping 外网ip的方式发现，一分钟到两分钟就会使3G网断掉，于是我怀疑是接了USB-HUB的原因，我果断把USB-HUB撤掉，直接插在路由器的USB接口上，在测试ping外网，发现ping完全正常，目前已经ping了4000秒左右了，没有出现网络断开。所以可以确定是USB-HUB导致3G网卡供电不足。慎用！！！如果确有需求，推荐X宝买一款带供电的hub。\n\n\n## 四.对编译的问题和总结\n\n#### 4.1    在编译的过程中难免会出现一个问题，比如说，我们down的这份源码中，make menuconfig没有这个某个软件怎么办？很多人都是通过刷好固件opkg install xx解决，但是经实验证实，很难下载成功，或者下载成功安装不上，具体原因还我并不清楚。。所以我在想有些软件，我这个trunk版本没有，以前的trunk版本有没有？整个trunk版本都没有，那么BB正式版有没有？\n解：假如我们down一份之前的代码或者正式版代码，在源码工程目录下，linux下可以用find . -name xxx来找你想要的软件包（当然名字要首先明确下来），这时候如果找到的话，一般来说这个文件夹都是一个索引文件（目前个人的感觉，对源码目录及结构细节和Makefile的组织并没有深究过），里边会有Makefile和子文件夹file，file中又有几个文件。把这个软件的文件夹（一般路径不确定，比如feeds/packages/net/autossh）拷贝到我们自己的源码目录下的package下（这个路径是明确规定的，不能是其他的），所以按照这种思路，以后就不是去满世界找ipk了，自己编译一个更加方便，而且肯定兼容！\n\n然后有两个方式来完成你想要的功能，主要看你的需求，第一个是直接编译出ipk文件，另外一个是编译出新的包含此软件功能的固件。\n```\n第一个方式用几个指令即可：\n说先解释下 即为你拷贝来的软件包。\nmake package//prepare V=99 \n//这个命令是根据软件中的Makefile中的路径去指定URL下载软件包源码，并放在dl目录下，具体解压到哪里还没有研究- -！\n//敲完这个命令会有个警告，告诉你重新make menuconfig一下。因为这时候menuconfig就可以看到新的功能了哦\n//一般新的功能都在图形配置界面的network下或者utilities下，仔细找找可以看到。\nmake package//compile V=99   \n//这个是编译命令，编译完之后就可以在bin目录的相应位置找到，但是我发现目录下会多出好多个ipk\n//可能其中还有关联关系，就是可能生成很多个ipk，可能光安装一个不能安装上。。安装的过程没测试过。\n\n\n```\n\n\n```\n//另外提供一些命令，这些命令没有完全用过。（摘自官方wiki）\nTroubleshooting\n\nIf you find your package doesn’t show up in menuconfig, try the following command to see if you get the correct description:\n    TOPDIR=$PWD make -C package/ DUMP=1 V=99\nIf you’re just having trouble getting your package to compile, there’s a few shortcuts you can take. Instead of waiting for make to get to your package, you can run one of the following:\n\nmake package//clean V=99\nmake package//install V=99\nAnother nice trick is that if the source directory under build_dir/ is newer than the package directory, it won’t clobber it by unpacking the sources again. If you were working on a patch you could simply edit the sources under the build_dir// directory and run the install command above, when satisfied, copy the patched sources elsewhere and diff them with the unpatched sources. A warning though - if you go modify anything under package/ it will remove the old sources and unpack a fresh copy.\nOther useful targets include:\n\nmake package//prepare V=99\nmake package//compile V=99\nmake package//configure V=99\n```\n用以上这些命令的前提是，你已经搭建好了一个完整的编译环境（就是说你make过固件，不然没有交叉编译工具，你编译不了软件）\n\n第二种方式是，你用完\n```\nmake package//prepare V=99\n```\n\n命令后menuconfig中已经可以看到你所需要的软件了，直接make V=99 编译新固件！\n\n\n#### 4.2 对于定制文件系统\n\n\n在源码目录下的package/base-files/files下就是openwrt的文件系统。这里只有简单的几个，其他的一些目录都是在编译的时候生成的。\n本人实际测试，发现可以在这个目录下任意位置添加自己的配置文件或者脚本，编译固件的过程中，编译器会把这个目录全部拷贝走的。\n如果需要开机启动脚本，在etc/rc.local中添加，但要记得如果调用你的脚本是一个while无限循环的，那么需要在脚本名的后边加后台运行，即&\n不然会导致exit 0无法执行，到时候reboot这些命令不可用。\nopenwrt大部分基础文件都在软件包base-files里面。这个软件包做3件事：\n\n1 复制package/base-files/files下的所有文件到根目录\n\n2 复制target/linux/对应平台/base-files下的所有文件到根目录\n\n3 复制源码根目录下的files文件夹下的所有文件到根目录（如果需要添加自己的文件那么可以通过这一步，即在源码根目录内新建一个files文件夹）\n#### 4.3.解决目前trunk版无法正常使用校园web认证\n\n这个问题困扰了很久，这几天有时间所以就找了下问题。问题找了好多，编译了很多次，最后把问题定位到了mwan上。\n\n所在的环境为校园网，上网会跳转web认证页面，然后30秒之后认证页面就弹不出来了，打开任何网页无果。ping上层网关通，ping同级ip通，把网线拔了重新插在wan口上，又会有几十秒的时间跳转，过了这个时间就又不正常了。由于在校园，所在环境为自然的双栈地址，装了一个6relayd，按理说v4地址和v6地址都能获取到，v4不正常，v6应该正常，可是ipv6同样不正常。\n\n经测试发现，插上wan口上，然后这时候随便刷新网页会有弹出认证页面，然后过一会就认证不了了。这时候再查看路由器web页面的系统日志信息\n，发现确实有异常，于是尝试几次相同的操作，发现可以锁定问题。\n```\nSun Nov  2 04:44:07 2014 user.notice mwan3: ifup interface wan (eth1)\nSun Nov  2 04:44:08 2014 daemon.info dnsmasq[1552]: reading /tmp/resolv.conf.auto\nSun Nov  2 04:44:08 2014 daemon.info dnsmasq[1552]: using local addresses only for domain lan\nSun Nov  2 04:44:08 2014 daemon.info dnsmasq[1552]: using nameserver 210.45.240.99#53\nSun Nov  2 04:44:08 2014 daemon.info dnsmasq[1552]: using nameserver 8.8.8.8#53\nSun Nov  2 04:44:08 2014 user.notice firewall: Reloading firewall due to ifup of wan (eth1)\nSun Nov  2 04:44:10 2014 daemon.notice netifd: Interface 'wan6' is now up\nSun Nov  2 04:44:10 2014 daemon.info hnetd[2022]: platform: interface update for br-lan detected\nSun Nov  2 04:44:10 2014 daemon.info hnetd[2022]: platform: interface update for lo detected\nSun Nov  2 04:44:10 2014 daemon.info hnetd[2022]: platform: interface update for eth1 detected\nSun Nov  2 04:44:10 2014 daemon.info hnetd[2022]: platform: interface update for eth1 detected\nSun Nov  2 04:44:11 2014 user.notice root: starting ntpclient\nSun Nov  2 04:44:11 2014 user.crit ddns-scripts[2421]: myddns_ipv4: CRITICAL ERROR - Service Configuration is disabled - EXITING\nSun Nov  2 04:44:11 2014 daemon.warn 6relayd[1567]: A default route is present but there is no public prefix on br-lan thus we don't announce a default route!\nSun Nov  2 04:44:11 2014 daemon.warn odhcpd[1379]: A default route is present but there is no public prefix on br-lan thus we don't announce a default route!\nSun Nov  2 04:44:12 2014 daemon.err miniupnpd[2508]: could not open lease file: /var/upnp.leases\nSun Nov  2 04:44:12 2014 daemon.notice miniupnpd[2508]: HTTP listening on port 5000\nSun Nov  2 04:44:12 2014 daemon.notice miniupnpd[2508]: HTTP IPv6 address given to control points : [fdc0:8c3b:8d0::1]\nSun Nov  2 04:44:12 2014 daemon.notice miniupnpd[2508]: Listening for NAT-PMP/PCP traffic on port 5351\nSun Nov  2 04:44:13 2014 user.notice firewall: Reloading firewall due to ifup of wan6 (eth1)\nSun Nov  2 04:44:13 2014 user.crit ddns-scripts[2593]: myddns_ipv6: CRITICAL ERROR - Service Configuration is disabled - EXITING\nSun Nov  2 04:44:13 2014 daemon.warn 6relayd[1567]: Termination requested by signal.\nSun Nov  2 04:44:14 2014 daemon.info dnsmasq[1552]: read /etc/hosts - 1 addresses\nSun Nov  2 04:44:14 2014 daemon.info dnsmasq[1552]: read /tmp/hosts/odhcpd - 1 addresses\nSun Nov  2 04:44:14 2014 daemon.info dnsmasq[1552]: read /tmp/hosts/6relayd - 0 addresses\nSun Nov  2 04:44:14 2014 daemon.info dnsmasq[1552]: read /tmp/hosts/dhcp - 1 addresses\nSun Nov  2 04:44:28 2014 user.info autossh[1475]: starting ssh (count 11)\nSun Nov  2 04:44:28 2014 user.info autossh[1475]: ssh child pid is 2685\nSun Nov  2 04:44:28 2014 user.info autossh[1475]: ssh exited with error status 255; restarting ssh\nSun Nov  2 04:44:42 2014 user.notice mwan3track: Interface wan (eth1) is offline\nSun Nov  2 04:44:42 2014 user.notice mwan3: ifdown interface wan (eth1)\nSun Nov  2 04:44:42 2014 user.info autossh[1475]: starting ssh (count 12)\nSun Nov  2 04:44:42 2014 user.info autossh[1475]: ssh child pid is 2795\nSun Nov  2 04:44:42 2014 user.info autossh[1475]: ssh exited with error status 255; restarting ssh\nSun Nov  2 04:44:49 2014 user.notice root: stopping ntpclient\n```\n观察可发现，插上网线会有mwan打开接口eth1，然后这时候可以通过认证，然后过一会没认证了，这时发现正好会出现mwan4track和mwan3 把eth1关掉了。（实际上，我在路由器shell中查看并没有关掉eth1）\n\nmwan3是一个多拨的软件，我个人认为这个软件可能会尝试几次多播，不成功就停止运行，可能与我们校园的web认证冲突。\n目前down下来的openwrt源码，默认的menuconfig中已经把mwan加到编译选项上。所以才会出现这种情况！\n问题找到了，解决问题办法是删掉mwan3和mwan3track。ps观察在/usr/sbin/下，删除，重启，于是问题解决。\n最终解决办法在编译openwrt的时候把mwan取消即可。\n```\nNetwork-->Routing and Redirection--->mwan3\nLuCI-->Application-->luci-app-multiwam\nLuCI-->Application-->luci-app-mwan3\n```\n\n#### 4.4 Openwrt安装pptp客户端\n\n需要两个包，一般的固件中，可能都集成了。\n一个是ppp-mod-pptp，另一个是luci-proto-pptp。\n\n具体的配置可以在luci界面上配置，接口-网络-添加新接口，然后选择协议为pptp即可。\n输入user,password,server即可。\n\n另外比较重要的一部是在/etc/ppp/options和/etc/ppp/options.pptp文件中。以下为自己的配置文件。\n```\nroot@OpenWrt:/etc/ppp# cat options\n#debug\nlogfile /dev/null\n#noipdefault\n#noaccomp\n#nopcomp\n#nocrtscts\n#lock\n#maxfail 0\n#lcp-echo-failure 5\n#lcp-echo-interval 1\n\n```\n\n\n```\nroot@OpenWrt:/etc/ppp# cat options.pptp\nnoipdefault\nnoauth\nnobsdcomp\nnodeflate\nidle 0\nmppe required,no40,no56,stateless\nmaxfail 0\nrefuse-eap\nrefuse-pap\n\n```\n\n#### 4.5 HP 1020 plus打印机--->网络共享打印机\n\n> 所需模块：kmod-usb-printer、p910nd、luci-app-p910nd\n\n> 打印的原理即：\npc把要打印的文档通过打印机驱动封装后成为打印机可识别的数据，发送给路由器端，路由器端由p910nd监听程序进行转发，把接到的数据转发给打印机。所以路由器端是不需要驱动程序的，只要保证p910nd进程能够正常运行即可。\n\n**具体配置（a,b,c,d）：**\n\na.由于惠普的低端打印机（类似于LaserJet 1010 1008 1009 1020 等）本身并不是自带firmware，我们每次打印的时候都是由PC端的驱动程序发送给打印机一个firmware。这个firmware在打印机的内存中，掉电后firmware就没了。基于打印机断电后不能够正常使用的问题，就是因为没有firmware的原因。firmware常用下载地址http://oleg.wl500g.info/hplj/ 找到自己的下载即可。也可以自己去编译，然后把编译出来的固件扔到路由器的/lib目录下。编译的过程参考http://wiki.openwrt.org/doc/howto/p910nd.server?s[]=p910nd\n\n所以我们可以通过一个热插拔的脚本来做，每次usb接到路由器时，就把firmware这个固件推送到打印机上（所以每次插路由器的时候会听到打印机呗驱动的声音）。然后再进行打印即可。usb的热插拔采用hotplug模块，这个一般op中都是自带的了。\n配置文件的位置在/etc/hotplug.d/usb/下。名字叫做20-usb_mode。可参考我的配置文件。\n```\n#!/bin/sh\nset -e\n\n# change this to the location where you put the .dl file:\nFIRMWARE=\"/lib/sihp1020.dl\"\nDEVICE=/dev/usb/lp0\nLOGFILE=/var/log/hp\n\nif [ \"$PRODUCT\" = \"3f0/2b17/100\" -a \"$ACTION\" = \"add\" ]; then\nfor i in $(seq 30); do\nif [ -c $DEVICE ]; then\necho \"$(date) : Sending firmware to printer…\" > $LOGFILE\nnc 192.168.14.55 9109 < /lib/sihp1020.dl\necho \"$(date) : done.\" ? $LOGFILE\nexit\nfi\nsleep 1\ndone\nfi\n```\nb.做完以上的步骤之后，并在/etc/rc.local下编辑如下内容，使p910nd进程自启。\n```\n/etc/init.d/p910nd start &\n\nexit 0\n```\n\nc.另外在luci管理界面上，把p910nd的配置中，接口选择wan口。启用前勾上。bidirectional mode(双向模式)不要打钩。\n\n也可参考配置文件。/etc/config/p910nd\n\n\n```\nconfig p910nd\n        option device '/dev/usb/lp0'\n        option enabled '1'\n        option bind '192.168.14.55'\n        option port '9'\n```\nd.在PC端，首先需要安装系统的驱动程序。\n有两种方式，第一种是从百度上直接搜索驱动，然后插上打印机的usb到电脑上，安装驱动。\n另一种方式不用插usb，直接在控制面板中，添加打印机，网络打印机，然后选择ip和端口名，然后windows update找到打印机响应型号\n安装即可。\n\n第一种安装完之后拔掉usb后，双击1020打印机，然后在左上角的打印下，把脱机打印取消。然后右击1020打印机，选择端口，添加端口，\n把ip和端口号写好，其他的默认，确认。还有重要的一步是，把双向打印前的勾一定要取消掉，不然会出现重复打印的情况。\n\n第二种安装完之后即可使用。注意 双向打印去掉。。\n\n***稳定性*：**\n还算可靠，在打印的时候，如果不能保证纸张充足的情况下打印，最后剩下的没有纸张了就不能够打印了，你在pc上再选择打印也不可以。\n这时候需要把打印机usb从路由器上拔掉，等待3秒后重新插上，然后打印机就会把剩余的任务打印出来。\n\n\n## 五 参考文献：\n\nhttp://blog.csdn.net/qingfengtsing/article/details/39344327\nhttp://blog.csdn.net/jk110333/article/category/1148871\nhttp://openwrt.diandian.com/post/2014-09-16/40062999348\nhttps://downloads.openwrt.org/kamikaze/docs/openwrt.html\nhttps://dev.openwrt.org/wiki/GetSource\nhttp://chaochaoblog.com/archives/1011\nhttp://www.right.com.cn/forum/thread-146084-1-1.html\nhttp://wenku.it168.com/d_000649332.shtml\nhttp://www.right.com.cn/forum/thread-147651-1-1.html\nhttp://www.right.com.cn/forum/thread-148069-1-1.html\nhttp://www.right.com.cn/forum/home.php?mod=space&uid=200302&do=thread&type=thread&view=me&from=space\nhttp://wenku.baidu.com/view/85d69c56ee06eff9aef80777.html\nhttps://forum.openwrt.org/viewtopic.php?id=50795\nhttps://github.com/pichuang/openvwrt","source":"_posts/openwrt.md","raw":"title: OpenWRT编译之360路由器C301    \ndate: 2014-10-16 14:01:01\ncategories: 嵌入式linux \ntags: [uboot定制,内核编译,打印机共享,openwrt] \n\n---\n\n备忘录分为三部分来描述，尽量做的详细一些，也算是给后人的一个参考。\n一.刷写第三方的uboot（刷不死的u-boot）\n\n二.编译内核（定制基础功能）\n\n三.OpenWRT挂3G网卡（华为E3276）\n\n<!--more-->\n## 一.刷写第三方的uboot（刷不死的u-boot）\n今天拿到手的360 c301，在官方系统的uboot上直刷 第三方 openwrt 。\n按住复位键，然后上电，10秒后待前边的灯 闪烁后 即表示 进入了uboot\n然后主机端 Ip要设置成192.168.1.x网段，这时候登陆web界面192.168.1.1就可以进入了官方自带的uboot，然后选择刷入 \n\n```\n//广告: 981213 大神的360路由全功能openwrt rom链接 http://www.right.com.cn/forum/thread-147319-1-1.html\n```\n我用的是flash1的。刷好之后，然后固件就成为了openwrt，这时候其实已经可以用了，但是为了以防万一，\n在之后的操作过程中，可能会损坏uboot，所以采用第三方的刷不死的Uboot, 这样自己编译的内核或者其他第三方的固件都\n随便刷了。\n之后：\n> 1.进入openwrt WEB界面把初始化的密码改成自己的    \n2.然后用winSCP客户端的SCP命令把我们提前下好的第三方刷不死uboot（http://www.right.com.cn/forum/thread-136444-1-1.html）传入路由器  \n3.用ssh登陆，并在/tmp目录下运行mtd write -r /tmp/u-boot.bin u-boot 命令刷入boot，这时路由器会自动重启    \n4.待重启好后即刷好了   \n5.以后所有的更新固件的操作，都要通过这个第三方的u-boot来做。（按下RESET键，上电等待10秒，再进入192.168.1.1,刚测试下，貌似只能用自带的网线。。。。。还有要注意的事，在更新的过程中，一定要用firefox或者chrome）\n\n## 二.编译openwrt\n\n#### 2.1    搭建编译环境\n我这边的环境是VMware下的ubuntu12.04，网上有说ubuntu版本最好用32位，64位可能有问题。另外需要apt-get一些基础的库和软件，如果缺少这一步，可能编译的过程中会报错，有可能缺少工具，如git，也有可能缺少库、头文件。\n```\nsudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip zip unrar p7zip p7zip-rar p7zip-full sharutils subversion libncurses5-dev ncurses-term zlib1g-dev gawk git-core  libpcre3-dev libssl-dev\n\n```\n\n#### 2.2    首先down下一份源码（分为两种，一种是trunk版，即开发版，另外一种是Barrier Breaker，即稳定版）\n由于我的这个C301官方支持只有trunk版，所以down的这个版本的，down分为两种，一种是svn，另外一种是git。\n\n```\nsvn co svn://svn.openwrt.org/openwrt/trunk/\n//接着到trunk目录下 \n./scripts/feeds update -a      //据说这部目录是更新package目录\n./scripts/feeds install -a      //安装package索引文件，这些文件个人感觉只是安装了一个索引，等编译的时候还要按需（make menuconfig）从指定地点下载\n```\n#### 2.3 接着就是配置了，这一步个人也许是整个编译的核心了，你所需要的功能都要在这步去做好。\n```\n //在源码目录下敲\n    make menuconfig \n```\n(测试发现，第一次make menuconfig 必须用普通用户，不能是root，所以如果是root下载的源码，记得要把整个源码目录chmod 777 \\*/\\* -R下，然后切换到普通用户，make menuconfig，以后再make menuconfig就不用普通用户了，root也可以的！)\n\n***以下是我从百度文库摘的极路由1S*，但是都大同小异，一些基础的配置按照这个来就够。**\n```\n选择LuCI 配置（web网页管理程序）：\nLuCI  ---> 1. Collections  --->  luci                                         启用LuCI\nLuCI  ---> 3. Applications  ---> luci-app-commands                         网页Shell \nLuCI  ---> 3. Applications  ---> luci-app-ddns                                动态域名\nLuCI  ---> 3. Applications  ---> luci-app-firewall                              防 火 墙\nLuCI  ---> 3. Applications  ---> luci-app-mwan3                              网络叠加\nLuCI  ---> 3. Applications  ---> luci-app-multiwan                            网络叠加\nLuCI  ---> 3. Applications  ---> luci-app-ntpc                           时间同步服务器\nLuCI  ---> 3. Applications  ---> luci-app-ocserv                           VPN Server\nLuCI  ---> 3. Applications  ---> luci-app-qos\nLuCI  ---> 3. Applications  ---> luci-app-samba                               网络共享\nLuCI  ---> 3. Applications  ---> luci-app-upnp\nLuCI  ---> 3. Applications  ---> luci-app-wol                                  网络唤醒\nLuCI  ---> 4. Themes  ---> luci-theme-bootstrap                             默认主题\nLuCI  ---> 4. Themes  ---> luci-theme-openwrt                          openwrt主题\nLuCI  ---> 5. Translations  --->  luci-i18n-chinese                            支持中文\n大家可以自行增减插件，保存设置后，重新编译下即可。\n \n文件系统、SD卡、USB配置：\nBase system  --->  block-mount                                              USB挂载\nKernel modules  --->  Filesystems  --->  kmod-fs-ext4              支持ext4文件系统\nKernel modules  --->  Filesystems  --->  kmod-fs-nfs                支持NFS文件系统\nKernel modules  --->  Filesystems  --->  kmod-fs-nfs-common\nKernel modules  --->  Filesystems  --->  kmod-fs-ntfs              支持NTFS文件系统\nKernel modules  --->  Filesystems  --->  kmod-fs-vfat             支持FAT32文件系统\nKernel modules  --->  Native Language Support  --->  kmod-nls-cp437       支持中文\nKernel modules  --->  Native Language Support  --->  kmod-nls-iso8859-1   支持中文\nKernel modules  --->  Native Language Support  --->  kmod-nls-utf8         支持中文\nKernel modules  --->  Other modules  --->  kmod-mmc                     支持SD卡\nKernel modules  --->  Other modules  --->  kmod-sdhci                     支持SD卡\nKernel modules  --->  Other modules  --->  kmod-sdhci-mt7620            支持SD卡\nKernel modules  --->  USB Support  --->  kmod-usb-ohci                 支持USB 1.0\nKernel modules  --->  USB Support  --->  kmod-usb-storage\nKernel modules  --->  USB Support  --->  kmod-usb-storage-extras\nKernel modules  --->  USB Support  --->  kmod-usb-uhci                 支持USB 1.1\nKernel modules  --->  USB Support  --->  kmod-usb2                     支持USB 2.0\n \n网络配置：\nNetwork  --->  ppp-mod-pppoe                                           PPPOE拨号模式\nNetwork  --->  ppp-mod-pptp                                                 VPN客户端\nNetwork  --->  SSH  --->  openssh-client                                    SSH客户端\n其实里面有很多软件，大家可以编译试一试的，番茄软件很多的哦！~\n \n应用程序配置：\nUtilities  --->  bzip2                                                            解压缩工具\nUtilities  --->  Compression  --->  unrar                                       解压缩工具\nUtilities  --->  Compression  --->  unzip                                       解压缩工具\nUtilities  --->  Compression  --->  zip                                           压缩工具\nUtilities  --->  Filesystem  --->  badblocks                             支持ext2文件系统\nUtilities  --->  Filesystem  --->  e2fsprogs                 支持ext2/ext3/ext4格式化工具\nUtilities  --->  disc  --->  fdisk                                                   分区工具\n```\n\n除了上边的配置，以下我标注几个对自己需求比较重要的，其他的省略\n\n第一个Target System ，这里边就是要选你的路由器所对应的cpu的型号。如果路由器有两颗芯片，以第一个cpu为主，C301路由器主芯片为AR9344，所以我选择Atheros AR7XXX / AR9XXX,这个可能要靠一些经验了，我对硬件的芯片区分的也不是很好，最好去相应的论坛找找路由器对应的芯片类型。\n\n第二个Subtarget，选择Generic即可。这一步我不是特别明白，这一选项跟你上边的targetsystem有关，如果换一个芯片的话，这里可能还要选择对应的版本，目前尚不清晰。\n    \n第三个target profile 选择路由器型号。一般比较通用。\n    \n> （我down了一份BB版的源码，在这里找qihooC301没有找到，所以就是不支持，后来算下日子才知道，恩山的HACK大哥9月份才提交的patch，正式被官方录用。bb是7月出来的，肯定没有了！这里啰嗦几句，什么Kamikaze ，backfire ，attitude adjustment， barrier breaker 和trunk都是什么意思，之前我也模糊，后来去官方wiki，https://dev.openwrt.org/wiki/GetSource，感觉标注跟linux一贯的风格差不多，ubuntu两年一个正式版，openwrt最近也是两年，但时间并不确定，所以这样来看我也就清楚了。前面的这几个都是openwrt的正式版本，从老版本到最新版本，都是稳定版。后边的这个trunk是开发版，也就是功能涵盖barrier breaker，但是还在慢慢的添加新功能。所以如果你不是特意的获取trunk的老版，你获取到的永远是最新的，trunk官方源码一两天就更新一次,更新速度特别快，可以用svn log 网址来看下）\n\n这几个大选项 global build settings ,advaced configureation options , build the openwrt image builder ,build the openwrt sdk ,package the openwrt-based toolchain ,image configuration 目前我还没用到，所以不清楚具体含义和用法。\n\n  在大项Base system下，基本上没有动，还是按照op默认的配置来做的，值得要说的是，这里边的busybox，大家都知道busybox是一个嵌入式的linux shell集成工具，嵌入式的linux基本上所有的命令都是出自这里边（我所说的当然不包括一些第三方的package软件包的命令了）。如果有需求，可以进去打开一些命令，比如lsusb就可以在这里边打开，不然默认是没有的，除非你在其它的package安装usbutils（在大项utils下）。\n\n    Administrator默认。\n\n    Boot Loaders 默认。\n\n    Devlopment 默认。\n\n    Firmware 默认。\n    \n大项Kernel modules，这里边的选项，个人感觉是最重要的一个了，有很多功能如果这里边不选择好，那么将会非常麻烦，以后的固件可能很多功能用不了。结合我自己的C301进行定制。对于需要的功能。首先是无线，C301是双频的wifi，有2.4G和5G，分为两个网卡。所以在这里边的Wireless Drivers把Kmod-ath10k和kmod-ath9k，kmod-ath9k-common都要选上！因为C301自带一个usb口，所以我们进入usb support,把kmod-usb-core kmod-usb-ohci kmod-usb-storage-extras kmod-usb-uhci kmod-usb2都选上。在network support 下，把ppp的选项都选上，不然 无法拨号上网。由于360这个路由器还有一个LED，所以还要选下LED modules，我选的是gpio defaulton ledtrig gpio timer usbdev，这几项选上，我这边led显示是正常的，不过跟官方的那种亮不一样，我这个是一闪一闪的，不过感觉还可以！！！！内核在结合上边的就差不多了。\n\n还有比较重要的两个，这两个是个性化 定制的东西，一般的package小软件，都在这两个下面。功能非常丰富而且强大！\n按照我目前的需求来的，我用到了network下的File transfer下的lftp，这是一个ftp的客户端，我这需求类似的可能比较小。还有SSH这里边我全选了。VPN也可以选。。。至于utilities里边，我用到了usbutils和usb-modeswitch（挂3G网卡）\n\n至此。配置结束了。\n\n> 接下来还有很重要的一步才可以编译。这也算是openwrt官方Trunk的一个BUG（至少在现在14年10月份没有解决呢），估计以后会修复的。\n就是如果配置结果make，然后编译好的固件，你刷上去是没有无线的（2.4G和5G都没办法启动），所以需要替换掉一个目前源码工程目录下的mac80211下的东西。具体做法：\n在现在用的trunk源码目录外新建一个文件夹testop，然后进入testop，down一份之前的代码。svn co -r42681 svn://svn.openwrt.org/openwrt/trunk，之所以用这个版本，是因为这个版本的的2.4G是正常的，（也就是说5G不正常，所以不能用，但现在wifi大多数还是2.4G的！），down下来之后，然后把test源码目录下的pakcage/kernel/mac80211/Makefile和pakcage/kernel/mac80211/patches替换到之前的trunk源码的package/kernel/mac80211下。\n\n这时配置才算真正结束。\n\nmake V=99 或者 make j=cpu核数+1 都可以，就执行编译了。\n编译完之后会在源码目录下的bin下生诚ar7XXX的文件夹，打开之后就会看到我们的固件和packages包，这个包是好东西，因为和你的路由器是配套的，里边的软件你路由器可以直接安装。并不是所有ipk结尾的文件都能在路由器上安装，也并不是同一个cpu平台的通用，也可以说同型号的路由器ipk都可能不通用。所以这个文件夹的packages还是很有用的，保存好，之后做一个局域网软件源，从路由器直接到这里下载软件就可以了。。\n\n## OpenWRT挂3G网卡（华为E3276）\n\n首先要说的是，华为的大部分3G网卡都支持linux，也就是说openwrt只要是配置好，是完全能够支持的（当然你需要有一个usb口）.\n\n我们需要几个东西，PPP、usb-serial、usb-modeswitch,与此同时，usb的一些选项也要加进去，例如USB2.0、usb1.0、usb-storage等。\n我们所需要的是在/dev/目录下看到ttyUSB0和ttyUSB1，虽然linux驱动能够识别3G网卡，但是如果想让其工作，还需要使之拨号，这就需要ttyUSB0这个接口了，我们可以把她想象成以太网口，例如eth1。原来广域网口wan出去是从eth1走的，现在wan出去是通过ttyUSB0。另一方面，据说在BB版本（openwrt 14.07）没有出现之前，我们即便装了usb-serial也不能看到/dev/下有ttyUSB,还需要设置才可以（老版本的设置请参照下边的某老外论坛上的参考文献，另外为了识别你网卡产品的Device ID,你在openwrt下需要一个命令，lsusb，这个命令你在编译openwrt的时候可以在busybox里选上，也可以勾选上在Utilities/下的USButils）。话说回来，现在的BB版和trunk版就方便多了，直接在内核中选上usb-serial就可以看到/dev/ttyUSB0和/dev/ttyUSB1了。\n\n这几个东西具体的位置，usb-serial在内核目录下的USB support下，值得一提的是，你需要把Kmod-usb-serial-option和kmod-usb-serial-wwan、还有mod-us-serial-ipw选上。ppp在network模块下，一般这个都会编的。。。usb-modeswitch在Utilities下。USB的一些常用选项都在内核目录下的USB SUPPORT下。\n\n\n配置好了。然后就可以编译进固件中了。\n\n至于启动3G拨号。有两种方式，一个是shell中的操作，一个是web页面的操作。我用的是web上的操作，在网络，接口，找到wan，点击修改。\n然后在协议中找到UMTS/GPRS/EV-DO这一项。点击切换协议，然后在调制解调器节点 选择/dev/ttyUSB0,服务类型选择UMTS/GPRS (即3G/2G网)其他的留空就可以直接点保存应用了。过一会就看到ISP给分配的ipv4地址了。ping下外网是可以通的。\n\n切换到原来的上网模式，选择原来的模式即可，我这边的环境是dhcp自动分配的，我就选择dhcp自动获取ip。然后点击保存会提示物理的端口需要选择，点击物理设置，桥接接口 不选，直接选中接口中的eth1即可，因为eth1对应于路由器上的wan口。\n\n\n至此3G配置结束！\n副：路由器如果只有一个USB口，请慎用USB-HUB，经本人实际测试，插USB-HUB确实可以使用，3G网卡，U盘，都可以用，这几天一直有个ssh的连接在用，我发现ssh总是无故断掉，找了好半天原因找不到。ps发现pppd这个进程总是断掉重启，所以我用ping 外网ip的方式发现，一分钟到两分钟就会使3G网断掉，于是我怀疑是接了USB-HUB的原因，我果断把USB-HUB撤掉，直接插在路由器的USB接口上，在测试ping外网，发现ping完全正常，目前已经ping了4000秒左右了，没有出现网络断开。所以可以确定是USB-HUB导致3G网卡供电不足。慎用！！！如果确有需求，推荐X宝买一款带供电的hub。\n\n\n## 四.对编译的问题和总结\n\n#### 4.1    在编译的过程中难免会出现一个问题，比如说，我们down的这份源码中，make menuconfig没有这个某个软件怎么办？很多人都是通过刷好固件opkg install xx解决，但是经实验证实，很难下载成功，或者下载成功安装不上，具体原因还我并不清楚。。所以我在想有些软件，我这个trunk版本没有，以前的trunk版本有没有？整个trunk版本都没有，那么BB正式版有没有？\n解：假如我们down一份之前的代码或者正式版代码，在源码工程目录下，linux下可以用find . -name xxx来找你想要的软件包（当然名字要首先明确下来），这时候如果找到的话，一般来说这个文件夹都是一个索引文件（目前个人的感觉，对源码目录及结构细节和Makefile的组织并没有深究过），里边会有Makefile和子文件夹file，file中又有几个文件。把这个软件的文件夹（一般路径不确定，比如feeds/packages/net/autossh）拷贝到我们自己的源码目录下的package下（这个路径是明确规定的，不能是其他的），所以按照这种思路，以后就不是去满世界找ipk了，自己编译一个更加方便，而且肯定兼容！\n\n然后有两个方式来完成你想要的功能，主要看你的需求，第一个是直接编译出ipk文件，另外一个是编译出新的包含此软件功能的固件。\n```\n第一个方式用几个指令即可：\n说先解释下 即为你拷贝来的软件包。\nmake package//prepare V=99 \n//这个命令是根据软件中的Makefile中的路径去指定URL下载软件包源码，并放在dl目录下，具体解压到哪里还没有研究- -！\n//敲完这个命令会有个警告，告诉你重新make menuconfig一下。因为这时候menuconfig就可以看到新的功能了哦\n//一般新的功能都在图形配置界面的network下或者utilities下，仔细找找可以看到。\nmake package//compile V=99   \n//这个是编译命令，编译完之后就可以在bin目录的相应位置找到，但是我发现目录下会多出好多个ipk\n//可能其中还有关联关系，就是可能生成很多个ipk，可能光安装一个不能安装上。。安装的过程没测试过。\n\n\n```\n\n\n```\n//另外提供一些命令，这些命令没有完全用过。（摘自官方wiki）\nTroubleshooting\n\nIf you find your package doesn’t show up in menuconfig, try the following command to see if you get the correct description:\n    TOPDIR=$PWD make -C package/ DUMP=1 V=99\nIf you’re just having trouble getting your package to compile, there’s a few shortcuts you can take. Instead of waiting for make to get to your package, you can run one of the following:\n\nmake package//clean V=99\nmake package//install V=99\nAnother nice trick is that if the source directory under build_dir/ is newer than the package directory, it won’t clobber it by unpacking the sources again. If you were working on a patch you could simply edit the sources under the build_dir// directory and run the install command above, when satisfied, copy the patched sources elsewhere and diff them with the unpatched sources. A warning though - if you go modify anything under package/ it will remove the old sources and unpack a fresh copy.\nOther useful targets include:\n\nmake package//prepare V=99\nmake package//compile V=99\nmake package//configure V=99\n```\n用以上这些命令的前提是，你已经搭建好了一个完整的编译环境（就是说你make过固件，不然没有交叉编译工具，你编译不了软件）\n\n第二种方式是，你用完\n```\nmake package//prepare V=99\n```\n\n命令后menuconfig中已经可以看到你所需要的软件了，直接make V=99 编译新固件！\n\n\n#### 4.2 对于定制文件系统\n\n\n在源码目录下的package/base-files/files下就是openwrt的文件系统。这里只有简单的几个，其他的一些目录都是在编译的时候生成的。\n本人实际测试，发现可以在这个目录下任意位置添加自己的配置文件或者脚本，编译固件的过程中，编译器会把这个目录全部拷贝走的。\n如果需要开机启动脚本，在etc/rc.local中添加，但要记得如果调用你的脚本是一个while无限循环的，那么需要在脚本名的后边加后台运行，即&\n不然会导致exit 0无法执行，到时候reboot这些命令不可用。\nopenwrt大部分基础文件都在软件包base-files里面。这个软件包做3件事：\n\n1 复制package/base-files/files下的所有文件到根目录\n\n2 复制target/linux/对应平台/base-files下的所有文件到根目录\n\n3 复制源码根目录下的files文件夹下的所有文件到根目录（如果需要添加自己的文件那么可以通过这一步，即在源码根目录内新建一个files文件夹）\n#### 4.3.解决目前trunk版无法正常使用校园web认证\n\n这个问题困扰了很久，这几天有时间所以就找了下问题。问题找了好多，编译了很多次，最后把问题定位到了mwan上。\n\n所在的环境为校园网，上网会跳转web认证页面，然后30秒之后认证页面就弹不出来了，打开任何网页无果。ping上层网关通，ping同级ip通，把网线拔了重新插在wan口上，又会有几十秒的时间跳转，过了这个时间就又不正常了。由于在校园，所在环境为自然的双栈地址，装了一个6relayd，按理说v4地址和v6地址都能获取到，v4不正常，v6应该正常，可是ipv6同样不正常。\n\n经测试发现，插上wan口上，然后这时候随便刷新网页会有弹出认证页面，然后过一会就认证不了了。这时候再查看路由器web页面的系统日志信息\n，发现确实有异常，于是尝试几次相同的操作，发现可以锁定问题。\n```\nSun Nov  2 04:44:07 2014 user.notice mwan3: ifup interface wan (eth1)\nSun Nov  2 04:44:08 2014 daemon.info dnsmasq[1552]: reading /tmp/resolv.conf.auto\nSun Nov  2 04:44:08 2014 daemon.info dnsmasq[1552]: using local addresses only for domain lan\nSun Nov  2 04:44:08 2014 daemon.info dnsmasq[1552]: using nameserver 210.45.240.99#53\nSun Nov  2 04:44:08 2014 daemon.info dnsmasq[1552]: using nameserver 8.8.8.8#53\nSun Nov  2 04:44:08 2014 user.notice firewall: Reloading firewall due to ifup of wan (eth1)\nSun Nov  2 04:44:10 2014 daemon.notice netifd: Interface 'wan6' is now up\nSun Nov  2 04:44:10 2014 daemon.info hnetd[2022]: platform: interface update for br-lan detected\nSun Nov  2 04:44:10 2014 daemon.info hnetd[2022]: platform: interface update for lo detected\nSun Nov  2 04:44:10 2014 daemon.info hnetd[2022]: platform: interface update for eth1 detected\nSun Nov  2 04:44:10 2014 daemon.info hnetd[2022]: platform: interface update for eth1 detected\nSun Nov  2 04:44:11 2014 user.notice root: starting ntpclient\nSun Nov  2 04:44:11 2014 user.crit ddns-scripts[2421]: myddns_ipv4: CRITICAL ERROR - Service Configuration is disabled - EXITING\nSun Nov  2 04:44:11 2014 daemon.warn 6relayd[1567]: A default route is present but there is no public prefix on br-lan thus we don't announce a default route!\nSun Nov  2 04:44:11 2014 daemon.warn odhcpd[1379]: A default route is present but there is no public prefix on br-lan thus we don't announce a default route!\nSun Nov  2 04:44:12 2014 daemon.err miniupnpd[2508]: could not open lease file: /var/upnp.leases\nSun Nov  2 04:44:12 2014 daemon.notice miniupnpd[2508]: HTTP listening on port 5000\nSun Nov  2 04:44:12 2014 daemon.notice miniupnpd[2508]: HTTP IPv6 address given to control points : [fdc0:8c3b:8d0::1]\nSun Nov  2 04:44:12 2014 daemon.notice miniupnpd[2508]: Listening for NAT-PMP/PCP traffic on port 5351\nSun Nov  2 04:44:13 2014 user.notice firewall: Reloading firewall due to ifup of wan6 (eth1)\nSun Nov  2 04:44:13 2014 user.crit ddns-scripts[2593]: myddns_ipv6: CRITICAL ERROR - Service Configuration is disabled - EXITING\nSun Nov  2 04:44:13 2014 daemon.warn 6relayd[1567]: Termination requested by signal.\nSun Nov  2 04:44:14 2014 daemon.info dnsmasq[1552]: read /etc/hosts - 1 addresses\nSun Nov  2 04:44:14 2014 daemon.info dnsmasq[1552]: read /tmp/hosts/odhcpd - 1 addresses\nSun Nov  2 04:44:14 2014 daemon.info dnsmasq[1552]: read /tmp/hosts/6relayd - 0 addresses\nSun Nov  2 04:44:14 2014 daemon.info dnsmasq[1552]: read /tmp/hosts/dhcp - 1 addresses\nSun Nov  2 04:44:28 2014 user.info autossh[1475]: starting ssh (count 11)\nSun Nov  2 04:44:28 2014 user.info autossh[1475]: ssh child pid is 2685\nSun Nov  2 04:44:28 2014 user.info autossh[1475]: ssh exited with error status 255; restarting ssh\nSun Nov  2 04:44:42 2014 user.notice mwan3track: Interface wan (eth1) is offline\nSun Nov  2 04:44:42 2014 user.notice mwan3: ifdown interface wan (eth1)\nSun Nov  2 04:44:42 2014 user.info autossh[1475]: starting ssh (count 12)\nSun Nov  2 04:44:42 2014 user.info autossh[1475]: ssh child pid is 2795\nSun Nov  2 04:44:42 2014 user.info autossh[1475]: ssh exited with error status 255; restarting ssh\nSun Nov  2 04:44:49 2014 user.notice root: stopping ntpclient\n```\n观察可发现，插上网线会有mwan打开接口eth1，然后这时候可以通过认证，然后过一会没认证了，这时发现正好会出现mwan4track和mwan3 把eth1关掉了。（实际上，我在路由器shell中查看并没有关掉eth1）\n\nmwan3是一个多拨的软件，我个人认为这个软件可能会尝试几次多播，不成功就停止运行，可能与我们校园的web认证冲突。\n目前down下来的openwrt源码，默认的menuconfig中已经把mwan加到编译选项上。所以才会出现这种情况！\n问题找到了，解决问题办法是删掉mwan3和mwan3track。ps观察在/usr/sbin/下，删除，重启，于是问题解决。\n最终解决办法在编译openwrt的时候把mwan取消即可。\n```\nNetwork-->Routing and Redirection--->mwan3\nLuCI-->Application-->luci-app-multiwam\nLuCI-->Application-->luci-app-mwan3\n```\n\n#### 4.4 Openwrt安装pptp客户端\n\n需要两个包，一般的固件中，可能都集成了。\n一个是ppp-mod-pptp，另一个是luci-proto-pptp。\n\n具体的配置可以在luci界面上配置，接口-网络-添加新接口，然后选择协议为pptp即可。\n输入user,password,server即可。\n\n另外比较重要的一部是在/etc/ppp/options和/etc/ppp/options.pptp文件中。以下为自己的配置文件。\n```\nroot@OpenWrt:/etc/ppp# cat options\n#debug\nlogfile /dev/null\n#noipdefault\n#noaccomp\n#nopcomp\n#nocrtscts\n#lock\n#maxfail 0\n#lcp-echo-failure 5\n#lcp-echo-interval 1\n\n```\n\n\n```\nroot@OpenWrt:/etc/ppp# cat options.pptp\nnoipdefault\nnoauth\nnobsdcomp\nnodeflate\nidle 0\nmppe required,no40,no56,stateless\nmaxfail 0\nrefuse-eap\nrefuse-pap\n\n```\n\n#### 4.5 HP 1020 plus打印机--->网络共享打印机\n\n> 所需模块：kmod-usb-printer、p910nd、luci-app-p910nd\n\n> 打印的原理即：\npc把要打印的文档通过打印机驱动封装后成为打印机可识别的数据，发送给路由器端，路由器端由p910nd监听程序进行转发，把接到的数据转发给打印机。所以路由器端是不需要驱动程序的，只要保证p910nd进程能够正常运行即可。\n\n**具体配置（a,b,c,d）：**\n\na.由于惠普的低端打印机（类似于LaserJet 1010 1008 1009 1020 等）本身并不是自带firmware，我们每次打印的时候都是由PC端的驱动程序发送给打印机一个firmware。这个firmware在打印机的内存中，掉电后firmware就没了。基于打印机断电后不能够正常使用的问题，就是因为没有firmware的原因。firmware常用下载地址http://oleg.wl500g.info/hplj/ 找到自己的下载即可。也可以自己去编译，然后把编译出来的固件扔到路由器的/lib目录下。编译的过程参考http://wiki.openwrt.org/doc/howto/p910nd.server?s[]=p910nd\n\n所以我们可以通过一个热插拔的脚本来做，每次usb接到路由器时，就把firmware这个固件推送到打印机上（所以每次插路由器的时候会听到打印机呗驱动的声音）。然后再进行打印即可。usb的热插拔采用hotplug模块，这个一般op中都是自带的了。\n配置文件的位置在/etc/hotplug.d/usb/下。名字叫做20-usb_mode。可参考我的配置文件。\n```\n#!/bin/sh\nset -e\n\n# change this to the location where you put the .dl file:\nFIRMWARE=\"/lib/sihp1020.dl\"\nDEVICE=/dev/usb/lp0\nLOGFILE=/var/log/hp\n\nif [ \"$PRODUCT\" = \"3f0/2b17/100\" -a \"$ACTION\" = \"add\" ]; then\nfor i in $(seq 30); do\nif [ -c $DEVICE ]; then\necho \"$(date) : Sending firmware to printer…\" > $LOGFILE\nnc 192.168.14.55 9109 < /lib/sihp1020.dl\necho \"$(date) : done.\" ? $LOGFILE\nexit\nfi\nsleep 1\ndone\nfi\n```\nb.做完以上的步骤之后，并在/etc/rc.local下编辑如下内容，使p910nd进程自启。\n```\n/etc/init.d/p910nd start &\n\nexit 0\n```\n\nc.另外在luci管理界面上，把p910nd的配置中，接口选择wan口。启用前勾上。bidirectional mode(双向模式)不要打钩。\n\n也可参考配置文件。/etc/config/p910nd\n\n\n```\nconfig p910nd\n        option device '/dev/usb/lp0'\n        option enabled '1'\n        option bind '192.168.14.55'\n        option port '9'\n```\nd.在PC端，首先需要安装系统的驱动程序。\n有两种方式，第一种是从百度上直接搜索驱动，然后插上打印机的usb到电脑上，安装驱动。\n另一种方式不用插usb，直接在控制面板中，添加打印机，网络打印机，然后选择ip和端口名，然后windows update找到打印机响应型号\n安装即可。\n\n第一种安装完之后拔掉usb后，双击1020打印机，然后在左上角的打印下，把脱机打印取消。然后右击1020打印机，选择端口，添加端口，\n把ip和端口号写好，其他的默认，确认。还有重要的一步是，把双向打印前的勾一定要取消掉，不然会出现重复打印的情况。\n\n第二种安装完之后即可使用。注意 双向打印去掉。。\n\n***稳定性*：**\n还算可靠，在打印的时候，如果不能保证纸张充足的情况下打印，最后剩下的没有纸张了就不能够打印了，你在pc上再选择打印也不可以。\n这时候需要把打印机usb从路由器上拔掉，等待3秒后重新插上，然后打印机就会把剩余的任务打印出来。\n\n\n## 五 参考文献：\n\nhttp://blog.csdn.net/qingfengtsing/article/details/39344327\nhttp://blog.csdn.net/jk110333/article/category/1148871\nhttp://openwrt.diandian.com/post/2014-09-16/40062999348\nhttps://downloads.openwrt.org/kamikaze/docs/openwrt.html\nhttps://dev.openwrt.org/wiki/GetSource\nhttp://chaochaoblog.com/archives/1011\nhttp://www.right.com.cn/forum/thread-146084-1-1.html\nhttp://wenku.it168.com/d_000649332.shtml\nhttp://www.right.com.cn/forum/thread-147651-1-1.html\nhttp://www.right.com.cn/forum/thread-148069-1-1.html\nhttp://www.right.com.cn/forum/home.php?mod=space&uid=200302&do=thread&type=thread&view=me&from=space\nhttp://wenku.baidu.com/view/85d69c56ee06eff9aef80777.html\nhttps://forum.openwrt.org/viewtopic.php?id=50795\nhttps://github.com/pichuang/openvwrt","slug":"openwrt","published":1,"updated":"2015-08-09T07:28:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j3p0018o9d3vo8way2b"},{"title":"linux中的内存管理","date":"2015-08-01T18:01:01.000Z","description":null,"_content":"\n前一段时间看了《深入理解Linux内核》对其中的内存管理部分花了不少时间，但是还是有很多问题不是很清楚，最近又花了一些时间复习了一下，在这里记录下自己的理解和对Linux中内存管理的一些看法和认识。\n<!--more-->\n我比较喜欢搞清楚一个技术本身的发展历程，简而言之就是这个技术是怎么发展而来的，在这个技术之前存在哪些技术，这些技术有哪些特点，为什么会被目前的技术所取代，而目前的技术又解决了之前的技术所存在的哪些问题。弄清楚了这些，我们才能比较清晰的把握某一项技术。有些资料在介绍某个概念的时候直接就介绍这个概念的意义，原理，而对其发展过程和背后的原理丝毫不提，仿佛这个技术从天上掉下来的一样。介于此，还是以内存管理的发展历程来讲述今天的主题。\n首先，我必须要阐述一下这篇文章的主题是Linux内存管理中的分段和分页技术。\n让我们来回顾一下历史，在早期的计算机中，程序是直接运行在物理内存上的。换句话说，就是程序在运行的过程中访问的都是物理地址。如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就你一个程序，就这么点内存，吃不吃得饱那是你的事情了。然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了，这个事情本身我们就称之为内存管理。\n下面举一个早期的计算机系统中，内存分配管理的例子，以便于大家理解。\n加入我们有三个程序，程序1，2，3.程序1运行的过程中需要10M内存，程序2运行的过程中需要100M内存，而程序3运行的过程中需要20M内存。如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A, 接下来的10M-110M分配给B。这种内存管理的方法比较直接，好了，假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。下面我们来看看这种内存管理方式存在的几个比较明显的问题。就像文章一开始提到的，要很深层次的把握某个技术最好搞清楚其发展历程。\n### 进程地址空间不能隔离\n\n由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。举个例子，就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃（每个程序都可以系统的整个地址空间）。这样很多恶意程序或者是木马程序可以轻而易举的破快其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。\n### 内存使用的效率低\n\n如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道IO操作比较耗时，所以这个过程效率将会十分低下。\n### 程序运行的地址不能确定\n\n程序每次需要运行时，都需要在内存中非配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址，如果有不明白童鞋可以去查查编译原理方面的资料。\n内存管理无非就是想办法解决上面三个问题，如何使进程的地址空间隔离，如何提高内存的使用效率，如何解决程序运行时的重定位问题？\n这里引用计算机界一句无从考证的名言：“计算机系统里的任何问题都可以靠引入一个中间层来解决。”\n现在的内存管理方法就是在程序和物理内存之间引入了虚拟内存这个概念。虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。顾名思义既然是虚拟地址，也就是虚的，不是现实存在的地址空间。\n既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有分段和分页两种技术。\n分段(Segmentation)：这种方法是人们最开始使用的一种方法，基本思路是将程序所需要的内存地址空间大小的虚拟空间映射到某个\n物理地址空间。\n\n![image description](http://blog.chinaunix.net/attachment/201306/11/26611383_1370963405d40G.jpg)\n每个程序都有其独立的虚拟的独立的进程地址空间，可以看到程序A和B的虚拟地址空间都是从0x00000000开始的。我们将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节，这个映射过程由软件来设置映射的机制，实际的转换由硬件来完成。\n这种分段的机制解决了文章一开始提到的3个问题中的进程地址空间隔离和程序地址重定位的问题。程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。我们应用程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。\n无论如何分段机制解决了上面两个问题，是一个很大的进步，但是对于内存效率问题仍然无能为力。因为这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。那么，怎么才算高效率的内存使用呢。事实上，根据程序的局部性运行原理，一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到。所以我们需要更加小粒度的内存分割和映射方法，此时是否会想到Linux中的Buddy算法和slab内存分配机制呢，哈哈。另一种将虚拟地址转换为物理地址的方法分页机制应运而生了。\n分页机制：\n分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。试想以下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果我想存储在磁盘上的文件是1K字节，那么其余的999K字节是不是浪费了。所以需要更加细粒度的磁盘分割方式，我们可以将Block设置得小一点，这当然是根据所存放文件的大小来综合考虑的，好像有点跑题了，我只是想说，内存中的分页机制跟ext文件系统中的磁盘分割机制非常相似。\nLinux中一般页的大小是4KB，我们把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，我们还是以一个例子来说明,如下图：\n\n![进程虚拟地址空间、物理地址空间和磁盘之间的页映射关系](http://blog.chinaunix.net/attachment/201306/11/26611383_1370963405d40G.jpg)\n\n我们可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内(这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行),甚至他们共用了一部分物理地址空间，这就是共享内存。\n进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个缺页异常，然后异常管理程序会将其读到内存中。\n这就是分页机制的原理，当然Linux中的分页机制的实现还是比较复杂的，通过了也全局目录，也上级目录，页中级目录，页表等几级的分页机制来实现的，但是基本的工作原理是不会变的。\n分页机制的实现需要硬件的实现，这个硬件名字叫做MMU(Memory Management Unit)，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。\n\n\n参考文献：\n《深入理解Linux内核》\n《程序员的自我修养》","source":"_posts/linuxneicunguanli.md","raw":"title: linux中的内存管理 \ndate: 2015-8-1 14:01:01\ncategories: 转载文章 \ntags: [linux,内存管理,分页技术] \ndescription: \n---\n\n前一段时间看了《深入理解Linux内核》对其中的内存管理部分花了不少时间，但是还是有很多问题不是很清楚，最近又花了一些时间复习了一下，在这里记录下自己的理解和对Linux中内存管理的一些看法和认识。\n<!--more-->\n我比较喜欢搞清楚一个技术本身的发展历程，简而言之就是这个技术是怎么发展而来的，在这个技术之前存在哪些技术，这些技术有哪些特点，为什么会被目前的技术所取代，而目前的技术又解决了之前的技术所存在的哪些问题。弄清楚了这些，我们才能比较清晰的把握某一项技术。有些资料在介绍某个概念的时候直接就介绍这个概念的意义，原理，而对其发展过程和背后的原理丝毫不提，仿佛这个技术从天上掉下来的一样。介于此，还是以内存管理的发展历程来讲述今天的主题。\n首先，我必须要阐述一下这篇文章的主题是Linux内存管理中的分段和分页技术。\n让我们来回顾一下历史，在早期的计算机中，程序是直接运行在物理内存上的。换句话说，就是程序在运行的过程中访问的都是物理地址。如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就你一个程序，就这么点内存，吃不吃得饱那是你的事情了。然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了，这个事情本身我们就称之为内存管理。\n下面举一个早期的计算机系统中，内存分配管理的例子，以便于大家理解。\n加入我们有三个程序，程序1，2，3.程序1运行的过程中需要10M内存，程序2运行的过程中需要100M内存，而程序3运行的过程中需要20M内存。如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A, 接下来的10M-110M分配给B。这种内存管理的方法比较直接，好了，假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。下面我们来看看这种内存管理方式存在的几个比较明显的问题。就像文章一开始提到的，要很深层次的把握某个技术最好搞清楚其发展历程。\n### 进程地址空间不能隔离\n\n由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。举个例子，就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃（每个程序都可以系统的整个地址空间）。这样很多恶意程序或者是木马程序可以轻而易举的破快其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。\n### 内存使用的效率低\n\n如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道IO操作比较耗时，所以这个过程效率将会十分低下。\n### 程序运行的地址不能确定\n\n程序每次需要运行时，都需要在内存中非配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址，如果有不明白童鞋可以去查查编译原理方面的资料。\n内存管理无非就是想办法解决上面三个问题，如何使进程的地址空间隔离，如何提高内存的使用效率，如何解决程序运行时的重定位问题？\n这里引用计算机界一句无从考证的名言：“计算机系统里的任何问题都可以靠引入一个中间层来解决。”\n现在的内存管理方法就是在程序和物理内存之间引入了虚拟内存这个概念。虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。顾名思义既然是虚拟地址，也就是虚的，不是现实存在的地址空间。\n既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有分段和分页两种技术。\n分段(Segmentation)：这种方法是人们最开始使用的一种方法，基本思路是将程序所需要的内存地址空间大小的虚拟空间映射到某个\n物理地址空间。\n\n![image description](http://blog.chinaunix.net/attachment/201306/11/26611383_1370963405d40G.jpg)\n每个程序都有其独立的虚拟的独立的进程地址空间，可以看到程序A和B的虚拟地址空间都是从0x00000000开始的。我们将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节，这个映射过程由软件来设置映射的机制，实际的转换由硬件来完成。\n这种分段的机制解决了文章一开始提到的3个问题中的进程地址空间隔离和程序地址重定位的问题。程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。我们应用程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。\n无论如何分段机制解决了上面两个问题，是一个很大的进步，但是对于内存效率问题仍然无能为力。因为这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。那么，怎么才算高效率的内存使用呢。事实上，根据程序的局部性运行原理，一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到。所以我们需要更加小粒度的内存分割和映射方法，此时是否会想到Linux中的Buddy算法和slab内存分配机制呢，哈哈。另一种将虚拟地址转换为物理地址的方法分页机制应运而生了。\n分页机制：\n分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。试想以下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果我想存储在磁盘上的文件是1K字节，那么其余的999K字节是不是浪费了。所以需要更加细粒度的磁盘分割方式，我们可以将Block设置得小一点，这当然是根据所存放文件的大小来综合考虑的，好像有点跑题了，我只是想说，内存中的分页机制跟ext文件系统中的磁盘分割机制非常相似。\nLinux中一般页的大小是4KB，我们把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，我们还是以一个例子来说明,如下图：\n\n![进程虚拟地址空间、物理地址空间和磁盘之间的页映射关系](http://blog.chinaunix.net/attachment/201306/11/26611383_1370963405d40G.jpg)\n\n我们可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内(这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行),甚至他们共用了一部分物理地址空间，这就是共享内存。\n进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个缺页异常，然后异常管理程序会将其读到内存中。\n这就是分页机制的原理，当然Linux中的分页机制的实现还是比较复杂的，通过了也全局目录，也上级目录，页中级目录，页表等几级的分页机制来实现的，但是基本的工作原理是不会变的。\n分页机制的实现需要硬件的实现，这个硬件名字叫做MMU(Memory Management Unit)，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。\n\n\n参考文献：\n《深入理解Linux内核》\n《程序员的自我修养》","slug":"linuxneicunguanli","published":1,"updated":"2015-08-09T06:04:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j3z001jo9d3tx5v8nh3"},{"title":"基于Hadoop平台的局域网和广域网环境下的处理性能比较","date":"2015-01-11T19:01:01.000Z","_content":"\n## 测试目标\n检验在局域网环境下的hadoop平台与广域网环境下通过VPN组建的hadoop平台在处理性能上的差异。\n实际上检测网络通信情况，通过hadoop的terasort示例工具来做排序的压力测试，通过对比排序所用时间来确定差异。\n\n<!--more-->\n## 测试环境\n\nhadoop-1.0.0\n三台vmware下的ubuntu12.04，一台为Master，两台为Slave。\n\n## 实验步骤\n### 测试局域网环境下的计算性能\na.首先搭建hadoop平台\n\nb.搭建好hadoop平台后，通过master启动hadoop\n\nc.本人hadoop装在/usr/hadoop下，首先先通过teragen工具产生一定的随机数据\n\nd.在/usr/hadoop下运行bin/hadoop jar hadoop-examples-1.0.0.jar\n\nteragen 10000000 input\n(即产生1G的文本数据，每行有100个字节，所以总共有一千万行的随机数据，产生的数据存入到hdfs用户目录的input下)\n(附：有时候输入命令，无反应。\n\n出现如下错误：\n\n　　org.apache.hadoop.dfs.SafeModeException: Cannot delete ..., Name node is in safe mode\n\n　　在分布式文件系统启动的时候，开始的时候会有安全模式，当分布式文件系统处于安全模式的情况下，文件系统中的内容不允许修改也不允许删除，直到安全模式结束。安全模式主要是为了系统启动的时候检查各个DataNode上数据块的有效性，同时根据策略必要的复制或者删除部分数据块。运行期通过命令也可以进入安全模式。在实践过程中，系统启动的时候去修改和删除文件也会有安全模式不允许修改的出错提示，只需要等待一会儿即可。\n\n　　解决方案是：关闭安全模式\n　　\n　　\n```\nhadoop dfsadmin -safemode leave\n```\ne.运行结束后，然后运行bin/hadoop jar hadoop-examples-1.0.0.jar terasort input output\n(这条命令是让hadoop执行文本数据的排序，从input读，最终产生的文件也在hdfs的output文件夹下，会生成一个单一的文件。)\n\nf.同时还可用/bin/hadoop jar hadoop-examples-1.0.0.jar teravalidate output validate 来执行检验排序的正确与否。\n#### 结果\n（1）通过6次重复实验，可根据e运行的结果如下：\n\n第一次：5分3秒\n第二次：4分34秒\n第三次：3分44秒\n第四次：4分20秒\n第五次：4分20秒\n第六次：3分59秒\n\n（2）同时观察到两个Slave节点在map和reduce的过程中，cpu和内存充分被利用，cpu占用率大概在60%-75%之间，内存占用百分之90以上。而当总的运算进度已达到百分之70多的时候，有一个节点的cpu和内存已经空闲，说明他自己的运算工作已经完成，另一个节点在总进度达到100%时cpu和内存变为空闲。另外，在hadoop刚刚开始运算的时候，Master瞬间cpu占用比高，之后运算空闲。这也验证了Hadoop平台的主从架构。\n### 测试广域网环境下的计算性能\n广域网测试延迟巨大，处理速度差异巨大。\n## 结论\n分布式的处理架构，对网络带宽的要求苛刻。一般内网中组建的hadoop平台，网络带宽应该在100M。如果公网能找到这样的环境，应该也是可以的。但是这种环境搭建成本太高，所以hadoop平台在广域网范围下的应用失败。\n（据说，处理1TB的数据，需要在网络中传输3TB的数据。）\n\n## 附录\n\n```\nhadoop@Master:/usr/hadoop$ bin/hadoop jar hadoop-examples-1.0.0.jar teragen 10000000 in4\nWarning: $HADOOP_HOME is deprecated.\n\n\nGenerating 10000000 using 2 maps with step of 5000000\n15/01/09 18:35:30 INFO mapred.JobClient: Running job: job_201501101813_0020\n15/01/09 18:35:31 INFO mapred.JobClient:  map 0% reduce 0%\n15/01/09 18:35:47 INFO mapred.JobClient:  map 17% reduce 0%\n15/01/09 18:35:50 INFO mapred.JobClient:  map 40% reduce 0%\n15/01/09 18:35:53 INFO mapred.JobClient:  map 46% reduce 0%\n15/01/09 18:35:54 INFO mapred.JobClient:  map 56% reduce 0%\n15/01/09 18:35:57 INFO mapred.JobClient:  map 61% reduce 0%\n15/01/09 18:35:59 INFO mapred.JobClient:  map 75% reduce 0%\n15/01/09 18:36:00 INFO mapred.JobClient:  map 84% reduce 0%\n15/01/09 18:36:03 INFO mapred.JobClient:  map 95% reduce 0%\n15/01/09 18:36:12 INFO mapred.JobClient:  map 100% reduce 0%\n15/01/09 18:36:17 INFO mapred.JobClient: Job complete: job_201501101813_0020\n15/01/09 18:36:17 INFO mapred.JobClient: Counters: 19\n15/01/09 18:36:17 INFO mapred.JobClient:   Job Counters\n15/01/09 18:36:17 INFO mapred.JobClient:     SLOTS_MILLIS_MAPS=55752\n15/01/09 18:36:17 INFO mapred.JobClient:     Total time spent by all reduces waiting after reserving slots (ms)=0\n15/01/09 18:36:17 INFO mapred.JobClient:     Total time spent by all maps waiting after reserving slots (ms)=0\n15/01/09 18:36:17 INFO mapred.JobClient:     Launched map tasks=2\n15/01/09 18:36:17 INFO mapred.JobClient:     SLOTS_MILLIS_REDUCES=0\n15/01/09 18:36:17 INFO mapred.JobClient:   File Input Format Counters\n15/01/09 18:36:17 INFO mapred.JobClient:     Bytes Read=0\n15/01/09 18:36:17 INFO mapred.JobClient:   File Output Format Counters\n15/01/09 18:36:17 INFO mapred.JobClient:     Bytes Written=1000000000\n15/01/09 18:36:17 INFO mapred.JobClient:   FileSystemCounters\n15/01/09 18:36:17 INFO mapred.JobClient:     HDFS_BYTES_READ=167\n15/01/09 18:36:17 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=42624\n15/01/09 18:36:17 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=1000000000\n15/01/09 18:36:17 INFO mapred.JobClient:   Map-Reduce Framework\n15/01/09 18:36:17 INFO mapred.JobClient:     Map input records=10000000\n15/01/09 18:36:17 INFO mapred.JobClient:     Physical memory (bytes) snapshot=77443072\n15/01/09 18:36:17 INFO mapred.JobClient:     Spilled Records=0\n15/01/09 18:36:17 INFO mapred.JobClient:     CPU time spent (ms)=14870\n15/01/09 18:36:17 INFO mapred.JobClient:     Total committed heap usage (bytes)=31850496\n15/01/09 18:36:17 INFO mapred.JobClient:     Virtual memory (bytes) snapshot=694943744\n15/01/09 18:36:17 INFO mapred.JobClient:     Map input bytes=10000000\n15/01/09 18:36:17 INFO mapred.JobClient:     Map output records=10000000\n15/01/09 18:36:17 INFO mapred.JobClient:     SPLIT_RAW_BYTES=167\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------\nhadoop@Master:/usr/hadoop$ bin/hadoop jar hadoop-examples-1.0.0.jar terasort in4                                                                              out4\nWarning: $HADOOP_HOME is deprecated.\n\n\n15/01/09 18:36:49 INFO terasort.TeraSort: starting\n15/01/09 18:36:50 INFO mapred.FileInputFormat: Total input paths to process : 2\n15/01/09 18:36:50 INFO util.NativeCodeLoader: Loaded the native-hadoop library\n15/01/09 18:36:50 INFO zlib.ZlibFactory: Successfully loaded & initialized native-zlib library\n15/01/09 18:36:50 INFO compress.CodecPool: Got brand-new compressor\nMaking 1 from 100000 records\nStep size is 100000.0\n15/01/09 18:36:50 INFO mapred.FileInputFormat: Total input paths to process : 2\n15/01/09 18:36:51 INFO mapred.JobClient: Running job: job_201501101813_0021\n15/01/09 18:36:52 INFO mapred.JobClient:  map 0% reduce 0%\n15/01/09 18:37:09 INFO mapred.JobClient:  map 10% reduce 0%\n15/01/09 18:37:11 INFO mapred.JobClient:  map 21% reduce 0%\n15/01/09 18:37:12 INFO mapred.JobClient:  map 22% reduce 0%\n15/01/09 18:37:13 INFO mapred.JobClient:  map 24% reduce 0%\n15/01/09 18:37:17 INFO mapred.JobClient:  map 25% reduce 0%\n15/01/09 18:37:23 INFO mapred.JobClient:  map 30% reduce 0%\n15/01/09 18:37:26 INFO mapred.JobClient:  map 35% reduce 0%\n15/01/09 18:37:28 INFO mapred.JobClient:  map 36% reduce 0%\n15/01/09 18:37:33 INFO mapred.JobClient:  map 37% reduce 2%\n15/01/09 18:37:39 INFO mapred.JobClient:  map 37% reduce 4%\n15/01/09 18:37:42 INFO mapred.JobClient:  map 37% reduce 6%\n15/01/09 18:37:47 INFO mapred.JobClient:  map 37% reduce 8%\n15/01/09 18:37:48 INFO mapred.JobClient:  map 37% reduce 10%\n15/01/09 18:37:49 INFO mapred.JobClient:  map 44% reduce 10%\n15/01/09 18:37:52 INFO mapred.JobClient:  map 47% reduce 10%\n15/01/09 18:37:59 INFO mapred.JobClient:  map 49% reduce 10%\n15/01/09 18:38:01 INFO mapred.JobClient:  map 56% reduce 10%\n15/01/09 18:38:03 INFO mapred.JobClient:  map 60% reduce 10%\n15/01/09 18:38:06 INFO mapred.JobClient:  map 61% reduce 12%\n15/01/09 18:38:10 INFO mapred.JobClient:  map 62% reduce 12%\n15/01/09 18:38:16 INFO mapred.JobClient:  map 66% reduce 14%\n15/01/09 18:38:20 INFO mapred.JobClient:  map 68% reduce 16%\n15/01/09 18:38:21 INFO mapred.JobClient:  map 69% reduce 16%\n15/01/09 18:38:22 INFO mapred.JobClient:  map 69% reduce 18%\n15/01/09 18:38:29 INFO mapred.JobClient:  map 73% reduce 20%\n15/01/09 18:38:32 INFO mapred.JobClient:  map 83% reduce 20%\n15/01/09 18:38:35 INFO mapred.JobClient:  map 87% reduce 20%\n15/01/09 18:38:47 INFO mapred.JobClient:  map 93% reduce 25%\n15/01/09 18:38:51 INFO mapred.JobClient:  map 95% reduce 25%\n15/01/09 18:38:54 INFO mapred.JobClient:  map 98% reduce 25%\n15/01/09 18:38:57 INFO mapred.JobClient:  map 99% reduce 27%\n15/01/09 18:39:00 INFO mapred.JobClient:  map 100% reduce 29%\n15/01/09 18:39:03 INFO mapred.JobClient:  map 100% reduce 31%\n15/01/09 18:39:12 INFO mapred.JobClient:  map 100% reduce 33%\n15/01/09 18:39:30 INFO mapred.JobClient:  map 100% reduce 67%\n15/01/09 18:39:33 INFO mapred.JobClient:  map 100% reduce 69%\n15/01/09 18:39:36 INFO mapred.JobClient:  map 100% reduce 71%\n15/01/09 18:39:39 INFO mapred.JobClient:  map 100% reduce 73%\n15/01/09 18:39:42 INFO mapred.JobClient:  map 100% reduce 75%\n15/01/09 18:39:46 INFO mapred.JobClient:  map 100% reduce 77%\n15/01/09 18:39:49 INFO mapred.JobClient:  map 100% reduce 78%\n15/01/09 18:39:52 INFO mapred.JobClient:  map 100% reduce 79%\n15/01/09 18:39:55 INFO mapred.JobClient:  map 100% reduce 81%\n15/01/09 18:39:58 INFO mapred.JobClient:  map 100% reduce 83%\n15/01/09 18:40:01 INFO mapred.JobClient:  map 100% reduce 85%\n15/01/09 18:40:04 INFO mapred.JobClient:  map 100% reduce 86%\n15/01/09 18:40:07 INFO mapred.JobClient:  map 100% reduce 88%\n15/01/09 18:40:10 INFO mapred.JobClient:  map 100% reduce 90%\n15/01/09 18:40:13 INFO mapred.JobClient:  map 100% reduce 92%\n15/01/09 18:40:16 INFO mapred.JobClient:  map 100% reduce 94%\n15/01/09 18:40:19 INFO mapred.JobClient:  map 100% reduce 96%\n15/01/09 18:40:22 INFO mapred.JobClient:  map 100% reduce 98%\n15/01/09 18:40:28 INFO mapred.JobClient:  map 100% reduce 100%\n15/01/09 18:40:39 INFO mapred.JobClient: Job complete: job_201501101813_0021\n15/01/09 18:40:40 INFO mapred.JobClient: Counters: 31\n15/01/09 18:40:40 INFO mapred.JobClient:   Job Counters\n15/01/09 18:40:40 INFO mapred.JobClient:     Launched reduce tasks=1\n15/01/09 18:40:40 INFO mapred.JobClient:     SLOTS_MILLIS_MAPS=432306\n15/01/09 18:40:40 INFO mapred.JobClient:     Total time spent by all reduces waiting after reserving slots (ms)=0\n15/01/09 18:40:40 INFO mapred.JobClient:     Total time spent by all maps waiting after reserving slots (ms)=0\n15/01/09 18:40:40 INFO mapred.JobClient:     Rack-local map tasks=2\n15/01/09 18:40:40 INFO mapred.JobClient:     Launched map tasks=18\n15/01/09 18:40:40 INFO mapred.JobClient:     Data-local map tasks=16\n15/01/09 18:40:40 INFO mapred.JobClient:     SLOTS_MILLIS_REDUCES=193553\n15/01/09 18:40:40 INFO mapred.JobClient:   File Input Format Counters\n15/01/09 18:40:40 INFO mapred.JobClient:     Bytes Read=1000057358\n15/01/09 18:40:40 INFO mapred.JobClient:   File Output Format Counters\n15/01/09 18:40:40 INFO mapred.JobClient:     Bytes Written=1000000000\n15/01/09 18:40:40 INFO mapred.JobClient:   FileSystemCounters\n15/01/09 18:40:40 INFO mapred.JobClient:     FILE_BYTES_READ=2382257412\n15/01/09 18:40:40 INFO mapred.JobClient:     HDFS_BYTES_READ=1000059054\n15/01/09 18:40:40 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=3402633323\n15/01/09 18:40:40 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=1000000000\n15/01/09 18:40:40 INFO mapred.JobClient:   Map-Reduce Framework\n15/01/09 18:40:40 INFO mapred.JobClient:     Map output materialized bytes=1020000096\n15/01/09 18:40:40 INFO mapred.JobClient:     Map input records=10000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Reduce shuffle bytes=1020000096\n15/01/09 18:40:40 INFO mapred.JobClient:     Spilled Records=33355441\n15/01/09 18:40:40 INFO mapred.JobClient:     Map output bytes=1000000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Total committed heap usage (bytes)=2367090688\n15/01/09 18:40:40 INFO mapred.JobClient:     CPU time spent (ms)=124990\n15/01/09 18:40:40 INFO mapred.JobClient:     Map input bytes=1000000000\n15/01/09 18:40:40 INFO mapred.JobClient:     SPLIT_RAW_BYTES=1696\n15/01/09 18:40:40 INFO mapred.JobClient:     Combine input records=0\n15/01/09 18:40:40 INFO mapred.JobClient:     Reduce input records=10000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Reduce input groups=10000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Combine output records=0\n15/01/09 18:40:40 INFO mapred.JobClient:     Physical memory (bytes) snapshot=2481545216\n15/01/09 18:40:40 INFO mapred.JobClient:     Reduce output records=10000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Virtual memory (bytes) snapshot=5898289152\n15/01/09 18:40:40 INFO mapred.JobClient:     Map output records=10000000\n15/01/09 18:40:40 INFO terasort.TeraSort: done\n```\n","source":"_posts/hadoop.md","raw":"title: 基于Hadoop平台的局域网和广域网环境下的处理性能比较  \ndate: 2015-1-11 14:01:01\ncategories: hadoop \ntags: [hadoop,n2n,vpn] \n\n---\n\n## 测试目标\n检验在局域网环境下的hadoop平台与广域网环境下通过VPN组建的hadoop平台在处理性能上的差异。\n实际上检测网络通信情况，通过hadoop的terasort示例工具来做排序的压力测试，通过对比排序所用时间来确定差异。\n\n<!--more-->\n## 测试环境\n\nhadoop-1.0.0\n三台vmware下的ubuntu12.04，一台为Master，两台为Slave。\n\n## 实验步骤\n### 测试局域网环境下的计算性能\na.首先搭建hadoop平台\n\nb.搭建好hadoop平台后，通过master启动hadoop\n\nc.本人hadoop装在/usr/hadoop下，首先先通过teragen工具产生一定的随机数据\n\nd.在/usr/hadoop下运行bin/hadoop jar hadoop-examples-1.0.0.jar\n\nteragen 10000000 input\n(即产生1G的文本数据，每行有100个字节，所以总共有一千万行的随机数据，产生的数据存入到hdfs用户目录的input下)\n(附：有时候输入命令，无反应。\n\n出现如下错误：\n\n　　org.apache.hadoop.dfs.SafeModeException: Cannot delete ..., Name node is in safe mode\n\n　　在分布式文件系统启动的时候，开始的时候会有安全模式，当分布式文件系统处于安全模式的情况下，文件系统中的内容不允许修改也不允许删除，直到安全模式结束。安全模式主要是为了系统启动的时候检查各个DataNode上数据块的有效性，同时根据策略必要的复制或者删除部分数据块。运行期通过命令也可以进入安全模式。在实践过程中，系统启动的时候去修改和删除文件也会有安全模式不允许修改的出错提示，只需要等待一会儿即可。\n\n　　解决方案是：关闭安全模式\n　　\n　　\n```\nhadoop dfsadmin -safemode leave\n```\ne.运行结束后，然后运行bin/hadoop jar hadoop-examples-1.0.0.jar terasort input output\n(这条命令是让hadoop执行文本数据的排序，从input读，最终产生的文件也在hdfs的output文件夹下，会生成一个单一的文件。)\n\nf.同时还可用/bin/hadoop jar hadoop-examples-1.0.0.jar teravalidate output validate 来执行检验排序的正确与否。\n#### 结果\n（1）通过6次重复实验，可根据e运行的结果如下：\n\n第一次：5分3秒\n第二次：4分34秒\n第三次：3分44秒\n第四次：4分20秒\n第五次：4分20秒\n第六次：3分59秒\n\n（2）同时观察到两个Slave节点在map和reduce的过程中，cpu和内存充分被利用，cpu占用率大概在60%-75%之间，内存占用百分之90以上。而当总的运算进度已达到百分之70多的时候，有一个节点的cpu和内存已经空闲，说明他自己的运算工作已经完成，另一个节点在总进度达到100%时cpu和内存变为空闲。另外，在hadoop刚刚开始运算的时候，Master瞬间cpu占用比高，之后运算空闲。这也验证了Hadoop平台的主从架构。\n### 测试广域网环境下的计算性能\n广域网测试延迟巨大，处理速度差异巨大。\n## 结论\n分布式的处理架构，对网络带宽的要求苛刻。一般内网中组建的hadoop平台，网络带宽应该在100M。如果公网能找到这样的环境，应该也是可以的。但是这种环境搭建成本太高，所以hadoop平台在广域网范围下的应用失败。\n（据说，处理1TB的数据，需要在网络中传输3TB的数据。）\n\n## 附录\n\n```\nhadoop@Master:/usr/hadoop$ bin/hadoop jar hadoop-examples-1.0.0.jar teragen 10000000 in4\nWarning: $HADOOP_HOME is deprecated.\n\n\nGenerating 10000000 using 2 maps with step of 5000000\n15/01/09 18:35:30 INFO mapred.JobClient: Running job: job_201501101813_0020\n15/01/09 18:35:31 INFO mapred.JobClient:  map 0% reduce 0%\n15/01/09 18:35:47 INFO mapred.JobClient:  map 17% reduce 0%\n15/01/09 18:35:50 INFO mapred.JobClient:  map 40% reduce 0%\n15/01/09 18:35:53 INFO mapred.JobClient:  map 46% reduce 0%\n15/01/09 18:35:54 INFO mapred.JobClient:  map 56% reduce 0%\n15/01/09 18:35:57 INFO mapred.JobClient:  map 61% reduce 0%\n15/01/09 18:35:59 INFO mapred.JobClient:  map 75% reduce 0%\n15/01/09 18:36:00 INFO mapred.JobClient:  map 84% reduce 0%\n15/01/09 18:36:03 INFO mapred.JobClient:  map 95% reduce 0%\n15/01/09 18:36:12 INFO mapred.JobClient:  map 100% reduce 0%\n15/01/09 18:36:17 INFO mapred.JobClient: Job complete: job_201501101813_0020\n15/01/09 18:36:17 INFO mapred.JobClient: Counters: 19\n15/01/09 18:36:17 INFO mapred.JobClient:   Job Counters\n15/01/09 18:36:17 INFO mapred.JobClient:     SLOTS_MILLIS_MAPS=55752\n15/01/09 18:36:17 INFO mapred.JobClient:     Total time spent by all reduces waiting after reserving slots (ms)=0\n15/01/09 18:36:17 INFO mapred.JobClient:     Total time spent by all maps waiting after reserving slots (ms)=0\n15/01/09 18:36:17 INFO mapred.JobClient:     Launched map tasks=2\n15/01/09 18:36:17 INFO mapred.JobClient:     SLOTS_MILLIS_REDUCES=0\n15/01/09 18:36:17 INFO mapred.JobClient:   File Input Format Counters\n15/01/09 18:36:17 INFO mapred.JobClient:     Bytes Read=0\n15/01/09 18:36:17 INFO mapred.JobClient:   File Output Format Counters\n15/01/09 18:36:17 INFO mapred.JobClient:     Bytes Written=1000000000\n15/01/09 18:36:17 INFO mapred.JobClient:   FileSystemCounters\n15/01/09 18:36:17 INFO mapred.JobClient:     HDFS_BYTES_READ=167\n15/01/09 18:36:17 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=42624\n15/01/09 18:36:17 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=1000000000\n15/01/09 18:36:17 INFO mapred.JobClient:   Map-Reduce Framework\n15/01/09 18:36:17 INFO mapred.JobClient:     Map input records=10000000\n15/01/09 18:36:17 INFO mapred.JobClient:     Physical memory (bytes) snapshot=77443072\n15/01/09 18:36:17 INFO mapred.JobClient:     Spilled Records=0\n15/01/09 18:36:17 INFO mapred.JobClient:     CPU time spent (ms)=14870\n15/01/09 18:36:17 INFO mapred.JobClient:     Total committed heap usage (bytes)=31850496\n15/01/09 18:36:17 INFO mapred.JobClient:     Virtual memory (bytes) snapshot=694943744\n15/01/09 18:36:17 INFO mapred.JobClient:     Map input bytes=10000000\n15/01/09 18:36:17 INFO mapred.JobClient:     Map output records=10000000\n15/01/09 18:36:17 INFO mapred.JobClient:     SPLIT_RAW_BYTES=167\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------\nhadoop@Master:/usr/hadoop$ bin/hadoop jar hadoop-examples-1.0.0.jar terasort in4                                                                              out4\nWarning: $HADOOP_HOME is deprecated.\n\n\n15/01/09 18:36:49 INFO terasort.TeraSort: starting\n15/01/09 18:36:50 INFO mapred.FileInputFormat: Total input paths to process : 2\n15/01/09 18:36:50 INFO util.NativeCodeLoader: Loaded the native-hadoop library\n15/01/09 18:36:50 INFO zlib.ZlibFactory: Successfully loaded & initialized native-zlib library\n15/01/09 18:36:50 INFO compress.CodecPool: Got brand-new compressor\nMaking 1 from 100000 records\nStep size is 100000.0\n15/01/09 18:36:50 INFO mapred.FileInputFormat: Total input paths to process : 2\n15/01/09 18:36:51 INFO mapred.JobClient: Running job: job_201501101813_0021\n15/01/09 18:36:52 INFO mapred.JobClient:  map 0% reduce 0%\n15/01/09 18:37:09 INFO mapred.JobClient:  map 10% reduce 0%\n15/01/09 18:37:11 INFO mapred.JobClient:  map 21% reduce 0%\n15/01/09 18:37:12 INFO mapred.JobClient:  map 22% reduce 0%\n15/01/09 18:37:13 INFO mapred.JobClient:  map 24% reduce 0%\n15/01/09 18:37:17 INFO mapred.JobClient:  map 25% reduce 0%\n15/01/09 18:37:23 INFO mapred.JobClient:  map 30% reduce 0%\n15/01/09 18:37:26 INFO mapred.JobClient:  map 35% reduce 0%\n15/01/09 18:37:28 INFO mapred.JobClient:  map 36% reduce 0%\n15/01/09 18:37:33 INFO mapred.JobClient:  map 37% reduce 2%\n15/01/09 18:37:39 INFO mapred.JobClient:  map 37% reduce 4%\n15/01/09 18:37:42 INFO mapred.JobClient:  map 37% reduce 6%\n15/01/09 18:37:47 INFO mapred.JobClient:  map 37% reduce 8%\n15/01/09 18:37:48 INFO mapred.JobClient:  map 37% reduce 10%\n15/01/09 18:37:49 INFO mapred.JobClient:  map 44% reduce 10%\n15/01/09 18:37:52 INFO mapred.JobClient:  map 47% reduce 10%\n15/01/09 18:37:59 INFO mapred.JobClient:  map 49% reduce 10%\n15/01/09 18:38:01 INFO mapred.JobClient:  map 56% reduce 10%\n15/01/09 18:38:03 INFO mapred.JobClient:  map 60% reduce 10%\n15/01/09 18:38:06 INFO mapred.JobClient:  map 61% reduce 12%\n15/01/09 18:38:10 INFO mapred.JobClient:  map 62% reduce 12%\n15/01/09 18:38:16 INFO mapred.JobClient:  map 66% reduce 14%\n15/01/09 18:38:20 INFO mapred.JobClient:  map 68% reduce 16%\n15/01/09 18:38:21 INFO mapred.JobClient:  map 69% reduce 16%\n15/01/09 18:38:22 INFO mapred.JobClient:  map 69% reduce 18%\n15/01/09 18:38:29 INFO mapred.JobClient:  map 73% reduce 20%\n15/01/09 18:38:32 INFO mapred.JobClient:  map 83% reduce 20%\n15/01/09 18:38:35 INFO mapred.JobClient:  map 87% reduce 20%\n15/01/09 18:38:47 INFO mapred.JobClient:  map 93% reduce 25%\n15/01/09 18:38:51 INFO mapred.JobClient:  map 95% reduce 25%\n15/01/09 18:38:54 INFO mapred.JobClient:  map 98% reduce 25%\n15/01/09 18:38:57 INFO mapred.JobClient:  map 99% reduce 27%\n15/01/09 18:39:00 INFO mapred.JobClient:  map 100% reduce 29%\n15/01/09 18:39:03 INFO mapred.JobClient:  map 100% reduce 31%\n15/01/09 18:39:12 INFO mapred.JobClient:  map 100% reduce 33%\n15/01/09 18:39:30 INFO mapred.JobClient:  map 100% reduce 67%\n15/01/09 18:39:33 INFO mapred.JobClient:  map 100% reduce 69%\n15/01/09 18:39:36 INFO mapred.JobClient:  map 100% reduce 71%\n15/01/09 18:39:39 INFO mapred.JobClient:  map 100% reduce 73%\n15/01/09 18:39:42 INFO mapred.JobClient:  map 100% reduce 75%\n15/01/09 18:39:46 INFO mapred.JobClient:  map 100% reduce 77%\n15/01/09 18:39:49 INFO mapred.JobClient:  map 100% reduce 78%\n15/01/09 18:39:52 INFO mapred.JobClient:  map 100% reduce 79%\n15/01/09 18:39:55 INFO mapred.JobClient:  map 100% reduce 81%\n15/01/09 18:39:58 INFO mapred.JobClient:  map 100% reduce 83%\n15/01/09 18:40:01 INFO mapred.JobClient:  map 100% reduce 85%\n15/01/09 18:40:04 INFO mapred.JobClient:  map 100% reduce 86%\n15/01/09 18:40:07 INFO mapred.JobClient:  map 100% reduce 88%\n15/01/09 18:40:10 INFO mapred.JobClient:  map 100% reduce 90%\n15/01/09 18:40:13 INFO mapred.JobClient:  map 100% reduce 92%\n15/01/09 18:40:16 INFO mapred.JobClient:  map 100% reduce 94%\n15/01/09 18:40:19 INFO mapred.JobClient:  map 100% reduce 96%\n15/01/09 18:40:22 INFO mapred.JobClient:  map 100% reduce 98%\n15/01/09 18:40:28 INFO mapred.JobClient:  map 100% reduce 100%\n15/01/09 18:40:39 INFO mapred.JobClient: Job complete: job_201501101813_0021\n15/01/09 18:40:40 INFO mapred.JobClient: Counters: 31\n15/01/09 18:40:40 INFO mapred.JobClient:   Job Counters\n15/01/09 18:40:40 INFO mapred.JobClient:     Launched reduce tasks=1\n15/01/09 18:40:40 INFO mapred.JobClient:     SLOTS_MILLIS_MAPS=432306\n15/01/09 18:40:40 INFO mapred.JobClient:     Total time spent by all reduces waiting after reserving slots (ms)=0\n15/01/09 18:40:40 INFO mapred.JobClient:     Total time spent by all maps waiting after reserving slots (ms)=0\n15/01/09 18:40:40 INFO mapred.JobClient:     Rack-local map tasks=2\n15/01/09 18:40:40 INFO mapred.JobClient:     Launched map tasks=18\n15/01/09 18:40:40 INFO mapred.JobClient:     Data-local map tasks=16\n15/01/09 18:40:40 INFO mapred.JobClient:     SLOTS_MILLIS_REDUCES=193553\n15/01/09 18:40:40 INFO mapred.JobClient:   File Input Format Counters\n15/01/09 18:40:40 INFO mapred.JobClient:     Bytes Read=1000057358\n15/01/09 18:40:40 INFO mapred.JobClient:   File Output Format Counters\n15/01/09 18:40:40 INFO mapred.JobClient:     Bytes Written=1000000000\n15/01/09 18:40:40 INFO mapred.JobClient:   FileSystemCounters\n15/01/09 18:40:40 INFO mapred.JobClient:     FILE_BYTES_READ=2382257412\n15/01/09 18:40:40 INFO mapred.JobClient:     HDFS_BYTES_READ=1000059054\n15/01/09 18:40:40 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=3402633323\n15/01/09 18:40:40 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=1000000000\n15/01/09 18:40:40 INFO mapred.JobClient:   Map-Reduce Framework\n15/01/09 18:40:40 INFO mapred.JobClient:     Map output materialized bytes=1020000096\n15/01/09 18:40:40 INFO mapred.JobClient:     Map input records=10000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Reduce shuffle bytes=1020000096\n15/01/09 18:40:40 INFO mapred.JobClient:     Spilled Records=33355441\n15/01/09 18:40:40 INFO mapred.JobClient:     Map output bytes=1000000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Total committed heap usage (bytes)=2367090688\n15/01/09 18:40:40 INFO mapred.JobClient:     CPU time spent (ms)=124990\n15/01/09 18:40:40 INFO mapred.JobClient:     Map input bytes=1000000000\n15/01/09 18:40:40 INFO mapred.JobClient:     SPLIT_RAW_BYTES=1696\n15/01/09 18:40:40 INFO mapred.JobClient:     Combine input records=0\n15/01/09 18:40:40 INFO mapred.JobClient:     Reduce input records=10000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Reduce input groups=10000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Combine output records=0\n15/01/09 18:40:40 INFO mapred.JobClient:     Physical memory (bytes) snapshot=2481545216\n15/01/09 18:40:40 INFO mapred.JobClient:     Reduce output records=10000000\n15/01/09 18:40:40 INFO mapred.JobClient:     Virtual memory (bytes) snapshot=5898289152\n15/01/09 18:40:40 INFO mapred.JobClient:     Map output records=10000000\n15/01/09 18:40:40 INFO terasort.TeraSort: done\n```\n","slug":"hadoop","published":1,"updated":"2015-08-09T06:16:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j4f001so9d3mlk0h0m0"},{"title":"复习笔记-数据结构","date":"2015-03-29T19:31:49.000Z","_content":"总结复习，数据结构\n<!--more-->\n#### 1.[可视化演示](http://blog.csdn.net/bigleo/article/details/41219647)\n> [可视化数据结构](http://www.cs.usfca.edu/~galles/visualization/Algorithms.html )   \n> [C++实现的各种算法演示](http://people.cs.pitt.edu/~kirk/cs1501/animations/)   \n> [很酷的各种排序演示](http://sorting.at/)   \n> [很有创意的排序比较（匈牙利 Sapientia 大学的 6 种排序算法舞蹈视频](http://top.jobbole.com/1539/)）  \n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/33611161.jpg)\n\n#### 快速排序所谓的最好情况和最坏情况不一样，如何才是最好，如何才是最坏？\n最好情况是，选取到那个基准正好为比较中间的值，比如一个序列，10，23，45，8，9，这样就比较好，彼此到次数少，所以时间复杂度会变小，为nlog2n，\n最坏情况是，选取到这个序列有一定到顺序，这样再排序到时候，就会使得比较次数增加（每一轮比上次少1个），时间复杂度o(n2)\n####  所谓的稳定与不稳定是什么意思？\n假如待排序的一个序列中有A和B两个元素相等，如果在排序的过程中，有可能交换两个元素到位置，那么说这个排序算法不稳定。如果没有交换次序，那么就说这个排序算法是稳定的。\n#### 1.冒泡排序：O（n2），稳定。\n从前往后依次比较两个数的大小，如果按递减的顺序排序的话，那么比较一趟下来，最小的数应该位于最后一个数上。然后再从第一个继续比较，第二趟完了，会把次小的放在倒数第二个，以此类推。\n#### 2.选择排序：O（n2），不稳定。\n首先应选择第一个为基准，开始第一堂排序，之后的所有值与这个基准进行比较，如果a[i]小于基准，那么把a[i]定位新的基准，在用新的基准比较后边的值，一直到最后为止，这时候，把新的基准和第一个交换为止，第一趟结束。然后同理进入第二趟。\n#### 3.快速排序：好的时候是O（nlogn）,坏的时候是O（n2），不稳定\n任取一个值，一般取第一个，然后定义两个游标，一个游标指向最左边，另一个游标指向最右边，然后右边的游标先动，从右往左查找比第一个数小的值，找到就停止。然后左边的开始往右边查找一个比第一个大的数，找到为止，然后开始交换两个游标指向的值，直到左右游标相遇了。这时候再把第一个值与游标目前为止的值互换一下，进入下一次递归调用。\n在算法实现的过程中需要注意的问题：\n- a.由于进行的是递归调用，下边还需要使用right和left，所以right和left不能直接参与本次循环，需要引入r和l，如r=right,l=left\n- b.第一层循环while(l<r)，这时候不能在下边的设置为if(arr[r] >= arr[index]) 因为如果是if判断，只是简单判断第一次是否成立，并不能保证找到了比基准小的值，所以需要把条件变为while(arr[r] >= arr[index]) \n- c.由b改成while()之后，需要再条件中添加一个条件l<r，因为如果不添加那么就会一直减下去。\n- d.在递归调用的时候，必须要有一个判断退出的，不然会无线循环。if(l>r) return;\n\n```\n#include \"General.h\"\n/*\n *  快速排序所谓的最好情况和最坏情况不一样，如何才是最好，如何才是最坏？\n *\t最好情况是，选取到那个基准正好为比较中间的值，比如一个序列，10，23，45，8，9，这样就比较好，彼此到次数少，所以时间复杂度会变小，为nlog2n，\n *\t最坏情况是，选取到这个序列有一定到顺序，这样再排序到时候，就会使得比较次数增加（每一轮比上次少1个），时间复杂度o(n2)\n */\nvoid quickSort(int arr[], int left, int right){\n\n\tif(left > right) return;//递归必须要有退出的语句！\n\tint index = left;\n\tint l = left, r = right;\n\twhile(l < r){\n\t\twhile(arr[r]>arr[index] && l<r) r--;\n\t\twhile(arr[l]<arr[index] && l<r) l++;\n\t\tint tmp = arr[r];\n\t\tarr[r] = arr[l];\n\t\tarr[l] = tmp;\n\t}\n\tint temp = arr[l];\n\tarr[l] = arr[index];\n\tarr[index] = temp;\n\n\n\tquickSort(arr,left,l-1);\n\tquickSort(arr,l+1,right);\n}\n\n```\n\n#### 4.[堆排序](http://www.cnblogs.com/mengdd/archive/2012/11/30/2796845.html)：O（nlogn），不稳定\n分为两个过程，一个是建立堆的过程，一个是拿出祖先节点后，重新调整堆的过程。d\n建立堆之后，祖先节点就是一个最值了，把这个最值拷贝到另外一个数组的第一个位置，然后在原来的数组上（即堆上），删除根节点，然后现在的数组就需要重新调整为一个新的堆，在把这个堆的第一个元素取出，放到另外一个数组的第二个位置。以此类推。\n\n\n```\n#include \"General.h\"\n\n\nvoid adjustHeap(int arr[],int start,int end){\n\t//int tmp = arr[start];\n\tint i;\n\t//每次调整3个，如果传入进来的节点start,i,i+1，已经是一个有序的序列，那么循环执行一次就会结束。\n\t//如果传入进来的三个节点顺序不对，那么先调整这三个节点，然后再进入下一次循环以i或者i+1作为新的父节点进行调整，有可能调整到叶子节点，直到满足break。\n\t//NOTICE:for中一定要i<=end，而下边第一条执行if一定要有i<end，\n\t//考虑叶子节点只有一个左孩子的情况，此时也需要判断父亲和左孩子的大小，因为左孩子没有兄弟，所以不能跟i+1比较，会出现不可预料的后果。\n\tfor(i=2*start+1;i<=end;i*=2){\n\t\tif(arr[i] < arr[i+1] && i<end) i++;//选择大的子节点//这里的大于小于就确定了是大根堆还是小根堆\n\t\tif(arr[i] < arr[start]) break;//选择子节点和父节点中较大的一个\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[start];\n\t\tarr[start] = temp;\n\t\tstart = i;//为下一次节点调整做准备，下次循环中start就是“父节点”。\n\t}\n}\n\n\n\n//这里的n传入的是个数，不是数组下标最大值\nvoid heapSort(int arr[], int n){\n\tint i ;\n\t//建立一个初始堆，这个堆是一个原始的序列\n\t//此循环从n/2开始，是要从中间部分向上逐渐调整。\n\t//循环最终得到一个完整的大根堆/小根堆\n\tfor(i=n/2;i>=0;i--){//这里i有=0，是因为根节点也要和左右调整\n\t\tadjustHeap(arr,i,n-1);\n\t}\n\n\n\t//每次取出根节点，放置序列的尾部，空间复杂度o1\n\t//这样的话，在大根堆输出的序列就是一个递增的序列\n\tfor(i=n-1;i>0;i--){//这里i没有=0，是因为下边一直在和arr[0]换，arr[0]不需要和本身换。\n\t\tint tmp = arr[0];\n\t\tarr[0] = arr[i];\n\t\tarr[i] = tmp;\n\t\t//交换完之后还要调整剩下的堆，这个堆从上往下调整，直到再次选出其余节点中最值\n\t\tadjustHeap(arr,0,i-1);//i-1是因为每次交换的都是最后一个和第一个，所以需要从0调整到倒数第二个。\n\t}\n}\n```\n#### 5.二分查找(复杂度log2n，最大次数为log2n+1)\n在给定的一个有序递增序列中，拿指定值和中间值进行比较，如果相等，那么返回中间值，如果不等，则需要判断指定值和中间值的大小情况，如果小于中间值，那么要找的值在左边，所以递归调用本身，但是参数的上界变为mid-1.大于中间值，同理。需要注意的地方是循环的条件是Low<=high，因为相等的情况还是有一个节点的。\n\n```\n//查找的出是序列必须是连续存储，比如数组，链表不适合。另外被查找的序列应该有序，如递增\n\n//递归查找\nint binSearch(int arr[],int mete,int start,int end){\n\tint n = (start+end)/2;//key\n\tif(start > end) return -1;//递归要有退出\n\tif(arr == NULL) return -1;\n\tif(arr[n] == mete) return n;\n\tif(arr[n] < mete)\n\t\treturn binSearch(arr,mete,n+1,end);\n\telse\n\t\treturn binSearch(arr,mete,0,n-1);\n\treturn -1;\n}\n\n//循环查找\nint binSearchOut(int arr[],int mete,int start,int end){\n\tif(arr == NULL) return -1;\n\n\twhile(start <= end){\n\t\tint n = (start+end)/2;\n\t\tif(mete == arr[n])\n\t\t\treturn n;\n\t\telse if(mete > arr[n])\n\t\t\tstart = n+1;\n\t\telse\n\t\t\tend = n-1;\n\t}\n\treturn -1;\n}\n```\n\n#### 6.二叉树的遍历\n\n```\ntypedef struct BiTree {\n    int data;\n    struct BiTree *lchild,*rchild;\n}treenode,*BiTree;\n```\n\n- 前序遍历：根-》左-》右  \n- 中序遍历：左-》根-》右  \n- 后序遍历：左-》右-》根  \n> 以上的均代表一个节点的情况，例如根左右说的就是treenode中的，data(根)，lchild（左)，rchild(右)。\n\n```\nvoid zhongxu(BiTree T){\n    zhongxu(T->lchild);\n    T->data;\n    zhongxu(T->rchild);\n}x\n```\n由左、中序列或者中、右序列 均可以推出二叉树，但是只知道左右并不能推出二叉树。\n##### 6.1[线索化二叉树](http://blog.chinaunix.net/uid-26548237-id-3476920.html)\n#### 7.图——深度优先搜索遍历\n任取一个顶点，找出刚访问过的顶点的第一个未被访问的邻接点，然后这个邻接点为新的节点，重复上述过程，直到没有邻接点为止。这时候往上层回退，一直到访问完所有的顶点。每个节点仅访问一次。\n\n算法：\n需要一个数组，该数组记录节点是否被访问，如果被访问，则值为1，初始值为0.\n#### 8.图——广度优先搜索遍历\n类似于树的按层次遍历\n任取一个顶点，依次访问这个顶点的所有邻接点。然后再分别从这些邻接点出发依次访问每个“邻接点”的邻接点。并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”。\n#### 9.赫夫曼编码\n官方定义：以N种字符出现的频率作权计算来设计一颗赫夫曼树，由此得到的二进制前缀编码便成为赫夫曼编码。\n\n前缀编码：任何一个字符都不是另一个字符的编码的前缀，满足这个关系就是前缀编码。\n\n二叉树设计前缀编码，规定左分支标记为0，右分支标记为1.这样每个字符的最终编码就是从根节点到字符的所走的路径。\n\n赫夫曼树的构建：\n首先我们必须要知道的是每个字符的权值（如概率、出现的次数等等，这些都可以作为权值）\n\n然后我们在给出的字符权值组成一个序列，从这个序列中先选两个最小的（比如1和2），然后作为左右孩子节点\n\n接着，算出左右孩子节点的父节点权值（左右孩子权值相加）。\n\n算出过后，把（1和2）从原来的序列中删除，把新的父节点权值加入到序列中（把1+2=3加入到序列中）\n\n最后就重复做选小的，然后相加，然后删除，在继续做，直到序列中没有为止。\n\n[（例子）](http://www.cnblogs.com/Jezze/archive/2011/12/23/2299884.html)\n\n赫夫曼树的定义：哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树\n\n权值大的离根越近，权值小的离根越远。也就是权值大的，编码位数少。\n\n每个字符的编码值并不是唯一的，因为在上述构建过程中，左右孩子节点的选取就不是固定的，所以编码值不唯一。\n但是字符所在的层次是固定的。也就是说位数是确定的。\n#### 10.哈希表\n无顺序、基于数组\n优点，查找速度相当快，O1\n缺点，无法遍历，扩展性差（数组无法扩展）。\n#### 10.[平衡二叉树AVL与红黑树](http://www.cnblogs.com/BeyondAnyTime/archive/2012/08/27/2659163.html)\nhttp://www.bbniu.com/matrix/ShowApplication.aspx?id=149   \n红黑树的应用：\n> 红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。\n> 例如，Java中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。\n> 这里大致介绍下，红黑树和AVL树的差异。AVL树也是特殊的二叉树，它的特性是“任何节点的左右子树的高度之差不超过1”。基本上，用到红黑树的地方都可以用AVL树(自平衡二叉查找树)去替换。但是一般情况下，在执行添加、删除节点时，AVL树比红黑树执行的操作更多一些，效率更低一些；而且红黑树也是相对平衡的二叉树(从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点)。因此，红黑树的效率会高更一点。 \nhttp://www.csdn123.com/html/itweb/20130813/57700_57702_57699.htm\n\n#### 11.[左旋和右旋](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/71866125.jpg)\n\n#### 12.再说 树\n\n{二叉树：二叉树，（二叉排序树，AVL，红黑树），二叉堆，哈夫曼树}\n\n{多叉树：B树、B+树}\n#### 13.[红黑树](http://www.csdn123.com/html/itweb/20130813/57700_57702_57699.htm)\n> 查找、插入、删除 时间复杂度为log N。\n\n红黑树的特性：（属于二叉排序树的一种，包含其特性）\n- a。树中的节点，要么是黑色的，要么是红色的。\n- b。根节点一定是黑色的。\n- c。红色节点的孩子节点一定为黑色的。\n- d。每个叶子节点都是黑色的。\n- e。任意一个节点到所有该节点的子孙节点的路径中包含相同数量的黑色节点\n\n对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/37266332.jpg)\n#### 14.[二叉排序树](http://www.cnblogs.com/zhuyf87/archive/2012/11/09/2763113.html)（查找时间复杂度为On，BST）\n\n左子树小于父亲节点、右子树大于父亲节点。左右子树依然有序。\n#### 15.平衡二叉查找树（AVL，时间复杂度O（logN）  ）\n要求对于每个节点来说，它的左右子树的高度之差不能超过1，否则就要进行节点之间的旋转，使之达到平衡状态。\n#### 16.为什么需要AVL或者R.B Tree\nAVL和红黑树都为二叉排序树的一种，想象如果只有二叉排序树，极端情况下，二叉排序树只有1，2,3,4,5，这五个数字组成了一个单方向的二叉树，仔细看可以看出，其实成为了一个链表，链表的查找效率低下，需要一个高效的查找数据结构，AVL和红黑树可以实现。\n#### 17.二叉堆分为大根堆和小根堆，大根堆中父节点的值永远大于子节点的值。\n#### 18.string实现\n\n\n```\n\n\n#include \"MyString.h\"\n\n\nMyString::MyString(){\n string = new char[1];\n *string = '\\0';\n}\n\nMyString::MyString(const char* str){\n if(str == NULL){\n  string = new char[1];\n  *string = '\\0';\n }else{\n  int len = strlen(str);\n  string = new char[len+1];\n  strcpy(string,str);\n }\n}\n\nMyString::MyString(const MyString& ms){\n int len = strlen(ms.string);\n this->string = new char[len+1];\n strcpy(this->string,ms.string);\n}\n\nMyString::~MyString(){\n delete[] this->string;\n}\n\nMyString& MyString::operator=(const char* str){\n int len = strlen(str);\n this->string = new char[len+1];\n strcpy(this->string,str);\n return *this;\n}\n\nMyString MyString::operator+(const MyString& ms){\n int len = strlen(ms.string);\n MyString str;\n str.string = new char[len+strlen(this->string)+1];\n strcpy(str.string,this->string);\n strcat(str.string,ms.string);\n return str;\n}\n\nchar MyString::operator[](unsigned int index){\n char chr;\n chr = this->string[index];\n return chr;\n}\n\nbool MyString::operator==(const MyString &ms){\n int res = strcmp(ms.string,this->string);\n if (!res){\n  return true;\n }else{\n  return false;\n }\n}\n\nostream& operator<<(ostream& out,const MyString& ms){\n out<<ms.string;\n return out;\n}\n```\n#### 19.atoi 实现\n\n```\nint my_atoi(const char* str){ \nint res = 0; \nint flag = 1; \nif(!str) return 0;\n\nwhile(*str == ' ') str++;\n\nif(*str == '-') { \nflag = -1; \nstr++; \n}\n\nwhile(*str >= '0' && *str <= '9'){ \nres = *str-'0'+res*10; \nstr++; \n}\n\nreturn res*flag; \n} \n```\n\n\n\n#### 20.itoa 实现\n\n```\nchar* reverse(char* str){ \n\tchar tmp; \n\tchar* p = str; \n\tchar* q = str; \n\twhile(*p) p++; \n\tp--; \n\n\n\twhile(p>q){ \n\t\ttmp = *p; \n\t\t*p = *q; \n\t\t*q = tmp; \n\t\tp--; \n\t\tq++; \n\t} \n\treturn str; \n} \n\n\n\n\nchar* my_itoa(int val){ \n\tchar flag = 0; \n\tint i = 0; \n\tstatic char str[100] = \"\\0\"; \n\tif(!val) return 0; \n\tif(val < 0) { \n\t\tflag = '-'; \n\t\tval = val*(-1); \n\t} \n\twhile(val){ \n\t\tstr[i++] = val%10+'0'; \n\t\tval /= 10; \n\t} \n\tstr[i] = flag; \n\treturn reverse(str); \n} \n```\n","source":"_posts/gerenbijidata.md","raw":"title: 复习笔记-数据结构  \ndate: 2015-3-29 15:31:49\ncategories: 总结复习\ntags: [知识点整理,数据结构] \n---\n总结复习，数据结构\n<!--more-->\n#### 1.[可视化演示](http://blog.csdn.net/bigleo/article/details/41219647)\n> [可视化数据结构](http://www.cs.usfca.edu/~galles/visualization/Algorithms.html )   \n> [C++实现的各种算法演示](http://people.cs.pitt.edu/~kirk/cs1501/animations/)   \n> [很酷的各种排序演示](http://sorting.at/)   \n> [很有创意的排序比较（匈牙利 Sapientia 大学的 6 种排序算法舞蹈视频](http://top.jobbole.com/1539/)）  \n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/33611161.jpg)\n\n#### 快速排序所谓的最好情况和最坏情况不一样，如何才是最好，如何才是最坏？\n最好情况是，选取到那个基准正好为比较中间的值，比如一个序列，10，23，45，8，9，这样就比较好，彼此到次数少，所以时间复杂度会变小，为nlog2n，\n最坏情况是，选取到这个序列有一定到顺序，这样再排序到时候，就会使得比较次数增加（每一轮比上次少1个），时间复杂度o(n2)\n####  所谓的稳定与不稳定是什么意思？\n假如待排序的一个序列中有A和B两个元素相等，如果在排序的过程中，有可能交换两个元素到位置，那么说这个排序算法不稳定。如果没有交换次序，那么就说这个排序算法是稳定的。\n#### 1.冒泡排序：O（n2），稳定。\n从前往后依次比较两个数的大小，如果按递减的顺序排序的话，那么比较一趟下来，最小的数应该位于最后一个数上。然后再从第一个继续比较，第二趟完了，会把次小的放在倒数第二个，以此类推。\n#### 2.选择排序：O（n2），不稳定。\n首先应选择第一个为基准，开始第一堂排序，之后的所有值与这个基准进行比较，如果a[i]小于基准，那么把a[i]定位新的基准，在用新的基准比较后边的值，一直到最后为止，这时候，把新的基准和第一个交换为止，第一趟结束。然后同理进入第二趟。\n#### 3.快速排序：好的时候是O（nlogn）,坏的时候是O（n2），不稳定\n任取一个值，一般取第一个，然后定义两个游标，一个游标指向最左边，另一个游标指向最右边，然后右边的游标先动，从右往左查找比第一个数小的值，找到就停止。然后左边的开始往右边查找一个比第一个大的数，找到为止，然后开始交换两个游标指向的值，直到左右游标相遇了。这时候再把第一个值与游标目前为止的值互换一下，进入下一次递归调用。\n在算法实现的过程中需要注意的问题：\n- a.由于进行的是递归调用，下边还需要使用right和left，所以right和left不能直接参与本次循环，需要引入r和l，如r=right,l=left\n- b.第一层循环while(l<r)，这时候不能在下边的设置为if(arr[r] >= arr[index]) 因为如果是if判断，只是简单判断第一次是否成立，并不能保证找到了比基准小的值，所以需要把条件变为while(arr[r] >= arr[index]) \n- c.由b改成while()之后，需要再条件中添加一个条件l<r，因为如果不添加那么就会一直减下去。\n- d.在递归调用的时候，必须要有一个判断退出的，不然会无线循环。if(l>r) return;\n\n```\n#include \"General.h\"\n/*\n *  快速排序所谓的最好情况和最坏情况不一样，如何才是最好，如何才是最坏？\n *\t最好情况是，选取到那个基准正好为比较中间的值，比如一个序列，10，23，45，8，9，这样就比较好，彼此到次数少，所以时间复杂度会变小，为nlog2n，\n *\t最坏情况是，选取到这个序列有一定到顺序，这样再排序到时候，就会使得比较次数增加（每一轮比上次少1个），时间复杂度o(n2)\n */\nvoid quickSort(int arr[], int left, int right){\n\n\tif(left > right) return;//递归必须要有退出的语句！\n\tint index = left;\n\tint l = left, r = right;\n\twhile(l < r){\n\t\twhile(arr[r]>arr[index] && l<r) r--;\n\t\twhile(arr[l]<arr[index] && l<r) l++;\n\t\tint tmp = arr[r];\n\t\tarr[r] = arr[l];\n\t\tarr[l] = tmp;\n\t}\n\tint temp = arr[l];\n\tarr[l] = arr[index];\n\tarr[index] = temp;\n\n\n\tquickSort(arr,left,l-1);\n\tquickSort(arr,l+1,right);\n}\n\n```\n\n#### 4.[堆排序](http://www.cnblogs.com/mengdd/archive/2012/11/30/2796845.html)：O（nlogn），不稳定\n分为两个过程，一个是建立堆的过程，一个是拿出祖先节点后，重新调整堆的过程。d\n建立堆之后，祖先节点就是一个最值了，把这个最值拷贝到另外一个数组的第一个位置，然后在原来的数组上（即堆上），删除根节点，然后现在的数组就需要重新调整为一个新的堆，在把这个堆的第一个元素取出，放到另外一个数组的第二个位置。以此类推。\n\n\n```\n#include \"General.h\"\n\n\nvoid adjustHeap(int arr[],int start,int end){\n\t//int tmp = arr[start];\n\tint i;\n\t//每次调整3个，如果传入进来的节点start,i,i+1，已经是一个有序的序列，那么循环执行一次就会结束。\n\t//如果传入进来的三个节点顺序不对，那么先调整这三个节点，然后再进入下一次循环以i或者i+1作为新的父节点进行调整，有可能调整到叶子节点，直到满足break。\n\t//NOTICE:for中一定要i<=end，而下边第一条执行if一定要有i<end，\n\t//考虑叶子节点只有一个左孩子的情况，此时也需要判断父亲和左孩子的大小，因为左孩子没有兄弟，所以不能跟i+1比较，会出现不可预料的后果。\n\tfor(i=2*start+1;i<=end;i*=2){\n\t\tif(arr[i] < arr[i+1] && i<end) i++;//选择大的子节点//这里的大于小于就确定了是大根堆还是小根堆\n\t\tif(arr[i] < arr[start]) break;//选择子节点和父节点中较大的一个\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[start];\n\t\tarr[start] = temp;\n\t\tstart = i;//为下一次节点调整做准备，下次循环中start就是“父节点”。\n\t}\n}\n\n\n\n//这里的n传入的是个数，不是数组下标最大值\nvoid heapSort(int arr[], int n){\n\tint i ;\n\t//建立一个初始堆，这个堆是一个原始的序列\n\t//此循环从n/2开始，是要从中间部分向上逐渐调整。\n\t//循环最终得到一个完整的大根堆/小根堆\n\tfor(i=n/2;i>=0;i--){//这里i有=0，是因为根节点也要和左右调整\n\t\tadjustHeap(arr,i,n-1);\n\t}\n\n\n\t//每次取出根节点，放置序列的尾部，空间复杂度o1\n\t//这样的话，在大根堆输出的序列就是一个递增的序列\n\tfor(i=n-1;i>0;i--){//这里i没有=0，是因为下边一直在和arr[0]换，arr[0]不需要和本身换。\n\t\tint tmp = arr[0];\n\t\tarr[0] = arr[i];\n\t\tarr[i] = tmp;\n\t\t//交换完之后还要调整剩下的堆，这个堆从上往下调整，直到再次选出其余节点中最值\n\t\tadjustHeap(arr,0,i-1);//i-1是因为每次交换的都是最后一个和第一个，所以需要从0调整到倒数第二个。\n\t}\n}\n```\n#### 5.二分查找(复杂度log2n，最大次数为log2n+1)\n在给定的一个有序递增序列中，拿指定值和中间值进行比较，如果相等，那么返回中间值，如果不等，则需要判断指定值和中间值的大小情况，如果小于中间值，那么要找的值在左边，所以递归调用本身，但是参数的上界变为mid-1.大于中间值，同理。需要注意的地方是循环的条件是Low<=high，因为相等的情况还是有一个节点的。\n\n```\n//查找的出是序列必须是连续存储，比如数组，链表不适合。另外被查找的序列应该有序，如递增\n\n//递归查找\nint binSearch(int arr[],int mete,int start,int end){\n\tint n = (start+end)/2;//key\n\tif(start > end) return -1;//递归要有退出\n\tif(arr == NULL) return -1;\n\tif(arr[n] == mete) return n;\n\tif(arr[n] < mete)\n\t\treturn binSearch(arr,mete,n+1,end);\n\telse\n\t\treturn binSearch(arr,mete,0,n-1);\n\treturn -1;\n}\n\n//循环查找\nint binSearchOut(int arr[],int mete,int start,int end){\n\tif(arr == NULL) return -1;\n\n\twhile(start <= end){\n\t\tint n = (start+end)/2;\n\t\tif(mete == arr[n])\n\t\t\treturn n;\n\t\telse if(mete > arr[n])\n\t\t\tstart = n+1;\n\t\telse\n\t\t\tend = n-1;\n\t}\n\treturn -1;\n}\n```\n\n#### 6.二叉树的遍历\n\n```\ntypedef struct BiTree {\n    int data;\n    struct BiTree *lchild,*rchild;\n}treenode,*BiTree;\n```\n\n- 前序遍历：根-》左-》右  \n- 中序遍历：左-》根-》右  \n- 后序遍历：左-》右-》根  \n> 以上的均代表一个节点的情况，例如根左右说的就是treenode中的，data(根)，lchild（左)，rchild(右)。\n\n```\nvoid zhongxu(BiTree T){\n    zhongxu(T->lchild);\n    T->data;\n    zhongxu(T->rchild);\n}x\n```\n由左、中序列或者中、右序列 均可以推出二叉树，但是只知道左右并不能推出二叉树。\n##### 6.1[线索化二叉树](http://blog.chinaunix.net/uid-26548237-id-3476920.html)\n#### 7.图——深度优先搜索遍历\n任取一个顶点，找出刚访问过的顶点的第一个未被访问的邻接点，然后这个邻接点为新的节点，重复上述过程，直到没有邻接点为止。这时候往上层回退，一直到访问完所有的顶点。每个节点仅访问一次。\n\n算法：\n需要一个数组，该数组记录节点是否被访问，如果被访问，则值为1，初始值为0.\n#### 8.图——广度优先搜索遍历\n类似于树的按层次遍历\n任取一个顶点，依次访问这个顶点的所有邻接点。然后再分别从这些邻接点出发依次访问每个“邻接点”的邻接点。并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”。\n#### 9.赫夫曼编码\n官方定义：以N种字符出现的频率作权计算来设计一颗赫夫曼树，由此得到的二进制前缀编码便成为赫夫曼编码。\n\n前缀编码：任何一个字符都不是另一个字符的编码的前缀，满足这个关系就是前缀编码。\n\n二叉树设计前缀编码，规定左分支标记为0，右分支标记为1.这样每个字符的最终编码就是从根节点到字符的所走的路径。\n\n赫夫曼树的构建：\n首先我们必须要知道的是每个字符的权值（如概率、出现的次数等等，这些都可以作为权值）\n\n然后我们在给出的字符权值组成一个序列，从这个序列中先选两个最小的（比如1和2），然后作为左右孩子节点\n\n接着，算出左右孩子节点的父节点权值（左右孩子权值相加）。\n\n算出过后，把（1和2）从原来的序列中删除，把新的父节点权值加入到序列中（把1+2=3加入到序列中）\n\n最后就重复做选小的，然后相加，然后删除，在继续做，直到序列中没有为止。\n\n[（例子）](http://www.cnblogs.com/Jezze/archive/2011/12/23/2299884.html)\n\n赫夫曼树的定义：哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树\n\n权值大的离根越近，权值小的离根越远。也就是权值大的，编码位数少。\n\n每个字符的编码值并不是唯一的，因为在上述构建过程中，左右孩子节点的选取就不是固定的，所以编码值不唯一。\n但是字符所在的层次是固定的。也就是说位数是确定的。\n#### 10.哈希表\n无顺序、基于数组\n优点，查找速度相当快，O1\n缺点，无法遍历，扩展性差（数组无法扩展）。\n#### 10.[平衡二叉树AVL与红黑树](http://www.cnblogs.com/BeyondAnyTime/archive/2012/08/27/2659163.html)\nhttp://www.bbniu.com/matrix/ShowApplication.aspx?id=149   \n红黑树的应用：\n> 红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。\n> 例如，Java中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。\n> 这里大致介绍下，红黑树和AVL树的差异。AVL树也是特殊的二叉树，它的特性是“任何节点的左右子树的高度之差不超过1”。基本上，用到红黑树的地方都可以用AVL树(自平衡二叉查找树)去替换。但是一般情况下，在执行添加、删除节点时，AVL树比红黑树执行的操作更多一些，效率更低一些；而且红黑树也是相对平衡的二叉树(从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点)。因此，红黑树的效率会高更一点。 \nhttp://www.csdn123.com/html/itweb/20130813/57700_57702_57699.htm\n\n#### 11.[左旋和右旋](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/71866125.jpg)\n\n#### 12.再说 树\n\n{二叉树：二叉树，（二叉排序树，AVL，红黑树），二叉堆，哈夫曼树}\n\n{多叉树：B树、B+树}\n#### 13.[红黑树](http://www.csdn123.com/html/itweb/20130813/57700_57702_57699.htm)\n> 查找、插入、删除 时间复杂度为log N。\n\n红黑树的特性：（属于二叉排序树的一种，包含其特性）\n- a。树中的节点，要么是黑色的，要么是红色的。\n- b。根节点一定是黑色的。\n- c。红色节点的孩子节点一定为黑色的。\n- d。每个叶子节点都是黑色的。\n- e。任意一个节点到所有该节点的子孙节点的路径中包含相同数量的黑色节点\n\n对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/37266332.jpg)\n#### 14.[二叉排序树](http://www.cnblogs.com/zhuyf87/archive/2012/11/09/2763113.html)（查找时间复杂度为On，BST）\n\n左子树小于父亲节点、右子树大于父亲节点。左右子树依然有序。\n#### 15.平衡二叉查找树（AVL，时间复杂度O（logN）  ）\n要求对于每个节点来说，它的左右子树的高度之差不能超过1，否则就要进行节点之间的旋转，使之达到平衡状态。\n#### 16.为什么需要AVL或者R.B Tree\nAVL和红黑树都为二叉排序树的一种，想象如果只有二叉排序树，极端情况下，二叉排序树只有1，2,3,4,5，这五个数字组成了一个单方向的二叉树，仔细看可以看出，其实成为了一个链表，链表的查找效率低下，需要一个高效的查找数据结构，AVL和红黑树可以实现。\n#### 17.二叉堆分为大根堆和小根堆，大根堆中父节点的值永远大于子节点的值。\n#### 18.string实现\n\n\n```\n\n\n#include \"MyString.h\"\n\n\nMyString::MyString(){\n string = new char[1];\n *string = '\\0';\n}\n\nMyString::MyString(const char* str){\n if(str == NULL){\n  string = new char[1];\n  *string = '\\0';\n }else{\n  int len = strlen(str);\n  string = new char[len+1];\n  strcpy(string,str);\n }\n}\n\nMyString::MyString(const MyString& ms){\n int len = strlen(ms.string);\n this->string = new char[len+1];\n strcpy(this->string,ms.string);\n}\n\nMyString::~MyString(){\n delete[] this->string;\n}\n\nMyString& MyString::operator=(const char* str){\n int len = strlen(str);\n this->string = new char[len+1];\n strcpy(this->string,str);\n return *this;\n}\n\nMyString MyString::operator+(const MyString& ms){\n int len = strlen(ms.string);\n MyString str;\n str.string = new char[len+strlen(this->string)+1];\n strcpy(str.string,this->string);\n strcat(str.string,ms.string);\n return str;\n}\n\nchar MyString::operator[](unsigned int index){\n char chr;\n chr = this->string[index];\n return chr;\n}\n\nbool MyString::operator==(const MyString &ms){\n int res = strcmp(ms.string,this->string);\n if (!res){\n  return true;\n }else{\n  return false;\n }\n}\n\nostream& operator<<(ostream& out,const MyString& ms){\n out<<ms.string;\n return out;\n}\n```\n#### 19.atoi 实现\n\n```\nint my_atoi(const char* str){ \nint res = 0; \nint flag = 1; \nif(!str) return 0;\n\nwhile(*str == ' ') str++;\n\nif(*str == '-') { \nflag = -1; \nstr++; \n}\n\nwhile(*str >= '0' && *str <= '9'){ \nres = *str-'0'+res*10; \nstr++; \n}\n\nreturn res*flag; \n} \n```\n\n\n\n#### 20.itoa 实现\n\n```\nchar* reverse(char* str){ \n\tchar tmp; \n\tchar* p = str; \n\tchar* q = str; \n\twhile(*p) p++; \n\tp--; \n\n\n\twhile(p>q){ \n\t\ttmp = *p; \n\t\t*p = *q; \n\t\t*q = tmp; \n\t\tp--; \n\t\tq++; \n\t} \n\treturn str; \n} \n\n\n\n\nchar* my_itoa(int val){ \n\tchar flag = 0; \n\tint i = 0; \n\tstatic char str[100] = \"\\0\"; \n\tif(!val) return 0; \n\tif(val < 0) { \n\t\tflag = '-'; \n\t\tval = val*(-1); \n\t} \n\twhile(val){ \n\t\tstr[i++] = val%10+'0'; \n\t\tval /= 10; \n\t} \n\tstr[i] = flag; \n\treturn reverse(str); \n} \n```\n","slug":"gerenbijidata","published":1,"updated":"2015-08-10T14:46:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j530021o9d38jgm35ck"},{"title":"复习笔记-C++","date":"2015-03-10T16:31:49.000Z","_content":"总结复习，C/C++知识点\n<!--more-->\n#### 1.volatile 容易改变的变量\n修饰的是易变的变量，如果没有加volatile，则编译器可能会优化变量，之后程序可能读取的时候会直接读寄存器而不去读内存，导致读到的数据有问题。\n如果修饰之后，程序每次读数据都直接从内存上读，而不是从寄存器读。\n\n#### 2.C++迭代器失效（防止失效办法：获取返回值）\nhttp://blog.csdn.net/vipvipvip/article/details/6295973\nhttp://blog.csdn.net/damenhanter/article/details/8770076  \nhttp://wenku.baidu.com/link?url=VP4ObGLGIBeyyb8Pa125Nq-2mlrx6qoJgd3Jxbhvxkh7CDJ6NVhKQV-k-1Db2uHisqvtVtsyxBFfwa8vDPF53xOfm0UBEloN7D_Q4XPyKam  \n> a。在往vector添加一个新的成员时，vector会重新申请内存，然后把原来的值全部复制到新的内存上，这时候迭代器还指向原来的 位置，成为野指针，所以失效。  \n> b。删除元素也可能导致迭代器失效。\n\n#### 3. STL容器应用场景\n> 【序列性容器：vector，deque，list】  \n> 【关联性容器：map，set】   \n\n- vector实现了动态数组的功能，内部实现为数组，空间不够用时申请内存效率相对较低（中间插入，删除要移动内存）  \n- deque数组实现。类似于vector，两端插入和删除。  \n- list是双向链表实现。  \n- map底层为红黑树实现，效率logN,速度很快，而且基于key-value，自动排序。  \n- set底层实现为AVL，速度logN，功能上与vector类似，但是所存储内容不能包含相同的。。  \n\n ![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/37959742.jpg)\n \n #### 4.inline函数\n>  【内联函数是以代码的复制为代价，减少了函数调用（压栈，出栈开销大）的开销，从而提高代码的执行效率】\n\n- 内联函数和宏的区别是，前者是真正的函数，是由编译器去检查和展开的，而宏只是预处理器做的一个简单替换。  \n- inline关键字应该放在函数的定义处，而不是声明处。  \n- C++中类的成员函数，如果在类中直接定义函数，那么此函数不管加没加inline关键字，都会自动变为内联函数。所以说C++中，类中只是声明，定义要放在类外。  \n- 多用在短小的函数，且此函数经常被调用。一般在C++中，内联函数的定义和声明都是放在头文件中，因为其他的源文件也需要使用内联。  \n- 从inline的原理，我们可以看出，inline的原理，是用空间换取时间的做法，是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少\n#### 5. [浅拷贝、深拷贝](http://blog.csdn.net/bluescorpio/article/details/4322682)\n> 浅拷贝：在C++中在对对象复制时，只对对象中的成员数据进行简单的赋值操作称为浅拷贝。（默认为浅拷贝）。\n> \n> 深拷贝：在C++中对对象复制时，如果对象所属类中的成员变量有在堆中申请的内存时（如指针new一块内存），就不能简单的复制一下值就可以了，因为在之后的析构函数中，每个对象都会调用一次，这时候删除对象中的堆内存就会删除两次。导致不可预测的结果。这时候需要自己去写拷贝构造函数（例如也同时申请了一块内存，把值拷贝到这一块内存中），不要用默认的。这样做后，再程序到析构的时候就会释放各自申请的内存，不会导致内存归属不明问题。\n\n#### 6. [C++引用](http://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html)\n> 引用存在的意义：是为了解决在函数参数传递过程中，传递一大块数据如果以值传递的方式，那么函数调用的开销会增大，效率降低。\n\n##### 特点\n> a.如果是值传递的话，那么最好在形参前加一个const，这样就保证了引用的安全性。\n> b.C++中&不是取地址，而是一个引用的表示符。一般来说引用多用在对象，对普通的数据类型，用引用没有什么意义。\n> c.【【声明引用的同时，必须要初始化】】\n> d。引用本身不占用内存，但是用sizeof引用的时候，返回的是引用代表的那块内存的大小。\n> e。取引用的地址 &a，就是取目标变量（对象）的地址。\n\n##### 应用\n\n> a。传递参数。int test(A &a){}，提高效率，因为函数中操作的是实际的内存。并不是一个副本。   \n> b.返回值。 int & test() { } 里边的返回值应该是一个全局的变量。这样就不会产生副本了，同时也能从函数中传出来，但不能是局部变量（栈区，调用结束就销毁了），也不能是函数内部new的变量（因为返回之后我如何销毁这块内存呢？引用又不是内存地址，不能用free的。）\n\n#### 7.多态、虚函数、纯虚函数、重载\n> http://blog.csdn.net/memewry/article/details/7983267\n> http://blog.csdn.net/braveyly/article/details/5549978\n\n- 多态是指向不同的对象发送相同的消息，返回不同的结果。这里的消息是调用函数的意思。   \n- 虚函数与多态就是说基类中定义一个虚函数，然后用基类定义一个指针对象，这个对象指向子类的实例，这时候再调用相同的函数就会有不同的实现。具体说的话基类指针指向子类的实例地址，在这个指针调用虚函数的，并不会调用基类中的函数，而是根据这个虚函数表里的映射关系来找到相关对象的地址的函数入口。   \n- 纯虚函数：函数没有实现，只有一个声明。用virtual void func()= 0;这种方式声明的就叫纯虚函数。类中只要含有纯虚函数，那么这个类就变成了抽象类。   \n- 重载是一种函数实现，和多态没有关系。【重载的几个函数必须在同一个类中，而多态与它完全不同，多态是覆盖的一种表现形式，覆盖在基类中必须要有关键字virtual。】   \n- virtual关键字的作用就是为了实现动态绑定，而动态绑定的表现形式就是为多态。动态绑定有两个要求，第一个，指定为虚函数，第二个，用基类声明的指针或者引用指向派生类的对象，一般都是放在基类的函数前，派生类函数前并不需要加virtual。\n\n> 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。所以基本的一条是：无故的声明虚析构函数和永远不去声明一样是错误的。实际上，很多人这样总结：当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数。一般在多太的基类中都把xigou函数生命为virtual\n\n```\n//A为父类，B、C为子类\nA* a= new B();\na->DoSomething();\ndelete a;\na = NULL;\nA* a = new C();\na->DoSomething();\ndelete a;\na = NULL;\n\n```\n\n\n#### 8.sizeof\n\n```\ntypedef struct A{\n     int a;\n     short b;\n     double c;\n     float d;\n     int *aa;\n     char *bb;\n     char cc;\n} structA;\n\nint main(void) {\n    printf(\"%d\\n\",sizeof(structA));\n    return 0;\n}\n```\n> 以上运行结果为32.考的知识点为字节对齐和指针的大小。\n\n注意的地方：\n- a.结构体A中的顺序变化也能影响结果的不同。\n- b.结构体总大小 为 结构体中最宽的数据类型的整数倍，这里是double型，所以为8的整数倍\n- c.结构体中如果还有结构体，那么把内置的结构体顺序展开，计算大小。d.注意结构体内有数组的情况，要注意数组的类型为宽度。\n- d.如果结构体或者类中有static静态变量，那么计算结构体大小的时候，是不包含static变量的\n\n附：\n- 1.在类中，一个空类的大小也需要占用一个字节。因为空类也需要实例化。\n\n- 2.类中如果有虚函数，那么类到大小为一个指针的大小，有多少个虚函数都只有一个指针大小。。普通函数不占用内存。。。。。\n\n- 3.派生类的大小受到基类的影响，如果派生类继承两个基类，两个基类各有虚函数，那么派生类就有两个虚函数指针。\n\n\n#### 9.static\n##### 静态全局变量、静态局部变量、全局变量、局部变量\n\n- 静态局部变量：在全局数据区分配内存。第一次初始化的值会一直保存在全局数据区，之后再调用这个静态局部变量所在的函数，就不会再初始化了。如果第一次没有初始化，那么编译器会初始化为0，他的生存期是程序的整个运行周期，但是他的作用域只在函数中。\n- 局部变量：在栈中申请内存，作用域和生命期都为函数，函数结束，内存释放，且不再有效。\n- 全局变量：在所有函数中都有效。\n- 静态全局变量：与全局变量一样，唯一的不同就是作用域变小了，原来的全局变量可以在所有源文件中共享内存的，比如A文件和B文件中都要用同一个int a ，则在A中用int a，B中用extern a。但是对静态全局变量来说，A中用static int a，B中又定义int a，这个时候是无影响的，是两个不同的内存空间。\n\n##### 静态函数、普通函数\n- 静态函数与普通函数的区别只在于作用域，类似于静态全局变量和全局变量。\n- 还有一个类中的静态成员函数和类中的成员函数，前者static成员函数后，他没有this指针，他属于类，而不属于某个实例。与类中的static成员函数对应的为类中的static成员变量，静态成员函数只能访问静态成员变量，而不能访问类的其他成员变量，但是普通函数是可以访问类中的静态成员变量的。静态成员函数在类中只是声明，同时，她的赋值放在其他源文件中。用类：：static变量 访问它。另外，成员变量到定义是在进入main函数前就已经存在于内存中了，这时候如果构造函数去改变它到值，当类被实例化了，那么值就改变了。\n\n#### 10.C++命名空间\n> 存在的意义：C++函数库及其复杂和繁多，为了解决命名冲突的问题，这样就可以命名相同的函数名。\n\n\n\n#### 11.template模板\n\nC++中模板分为两种，一个是模板函数，一个是模板类\n##### 函数模板\n```\ntemplate <class T>\nT min(T x,T y)\n{ return(x<y)?x:y;}\n\nvoid main( )\n{\n     int n1=2,n2=10;\n     double d1=1.5,d2=5.6;\n     cout<< \"较小整数:\"<<min(n1,n2)<<endl;\n     cout<< \"较小实数:\"<<min(d1,d2)<<endl;\n}\n```\n\n##### 12.模板类\n> 一定要注意模板类的声明和实现一定要都放在头文件中，不然编译无法通过.\n\n```\ntemplate <class T>\nclass test{\nprivate:\n T value;\npublic:\n test(T val);\n\n void show();\n};\n\ntemplate <class T>\ntest<T>::test(T val){\n this->value = val; \n cout<<\"fffffff\"<<this->value<<endl;\n}\n\ntemplate <class T>\nvoid test<T>::show(){\n cout<<value<<endl;\n}\n//使用时：\nint main(){\n     test<MyString>  s(\"stringdddd\");\n     s.show();\n}\n```\n\n#### 13.初始化成员列表和构造函数里赋值\n> 如果是一般情况下，在构造函数里赋值就可以里，但是如果类中到成员属性 有const常量或者是对象到引用时候，这时候一定要用初始化成员列表。因为const常量只能初始化，不能赋值。\n> 第二点是因为效率。\n\n\n#### 14.语法分析器和词法分析器作用\n> （在编译器中）\n\n- 顾名思义，词法分析器检查的是词法，语法分析器分析的是语法（并不分析语义，因为语义强调的是你的逻辑），什么是词法，什么是语法你弄明白就知道了。\n- 所谓词法，源代码由字符流组成，字符流中包括关键字，变量名，方法名，括号等等符号，其中变量名要满足不能包括标点符号，不能以数字开头的数字与字母的字符串这个条件，对于括号要成对出现等等，这就是词法;\n- 而语法，词法没有问题才能进入语法分析，语法就是词排列的方法，字面意义，比如一句中文：我吃萝卜，里面有三个词我 吃 萝卜，除了“我吃萝卜”外，这三个词还可以组成，“萝卜吃我”“萝卜我吃”等，显然按照中文文法，后面的两句话是不对的，语法分析器就是分析类似这样的语法的。\n\n#### 15.如何判断一个系统是大段模式还是小端模式。\n```\ntypedef struct A{\nunsigned char a;\nunsigned char b;\nunsigned char c;\nunsigned char d;\n}a;\nint main(){\na aa;\n*((int*)&aa) = 0X01020304;\nprintf(\"%d,%d,%d,%d\\n\",aa.a,aa.b,aa.c,aa.d);\n}\n```\n详细请看：[大端模式和小端模式](http://blog.csdn.net/hackbuteer1/article/details/7722667)  \n在所有的介绍字节序的文章中都会提到字 节序分为两类：Big-Endian和Little-Endian，引用标准的Big-Endian和Little-Endian的定义如下：\n- a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。\n- b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。\n- c) 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。\n#### 16.[类和结构体的区别](http://www.cnblogs.com/vace/archive/2011/04/14/2015754.html)\n\n#### 17.类的对象 和 类的指针\n\n```\n#include <iostream> \n#include <string> \nusing namespace std; \n\nclass Student \n{ \npublic: \nstatic int number;  \nstring name; \n\npublic: \nStudent() \n{ \n} \n\nvoid set(string str) \n{ \nname = str; \nnumber++;    // 调用静态数据成员 \n} \n\nvoid print()  // 态成员函数 print() \n{ \nstd::cout < < name < <\" : The number of the students is \" < < number < < \" numbers.\" < < std::endl; // 调用静态数据成员 \n} \n}; \n\nint Student::number = 0;  // 静态数据成员初始化 \n\nint main(int argc, char** argv) \n{ \n\nStudent* s1; \ns1 = new Student(); \ns1->set(\"111\"); \n\nStudent s2; \ns2.set(\"222\"); \n\ns1->print(); \ns2.print(); \n\nreturn 0; \n} \n\n```\n对于类student ，定义了一个对象 和一个指针。  \n- 类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).   \n- 对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).  \n\n\n在应用时:   \n> \n> 1.引用成员:   对象用\"   .   \"操作符;   指针用\"   ->   \"操作符.   \n> 2.生命期:     若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete   在相应的地方释放分配的内存块.   \n\n[用new   ,一定要delete..【为何要用delete】?](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/16/2593754.html)\n\n\n- 1.malloc/free 是库函数，而new/delete是C++操作符，后者有编译器检查。\n\n- 2.前者只申请了内存，后者是申请内存和构造函数等等。用delete调用了析构函数，而free只释放内存。\n\n类的对象:用的是内存栈,是个局部的临时变量.   \n  类的指针:用的是内存堆,是个永久变量,除非你释放它.   \n    \n  当类是有虚函数的基类,Func是它的一个虚函数,则调用Func时:   \n  类的对象:调用的是它自己的Func;   \n  类的指针:调用的是分配给它空间时那种类的Func;  \n对于一个类的对象和这个类的指针（用new运算符分配内存）在应用时有何区别   \n  1.类和对象是两回事,对象是类的实例;   \n  2.对象是在栈中分配的,使用new生成的对象是在堆中分配的;   \n  3.要发挥虚函数的强大作用,必须使用指针来访问对象.  \n  \n  \n  指针可以实现多态，直接用对象不行   \n执行定义对象，在栈空间   \nnew处的在堆  \n注意名字的类型.  \n一个是Student   \n一个是Student\\*    \nStudent是直接访问一个对象   \nStudent\\*是间接访问一个对象,因为通过了一个指针作媒介.  \n类型决定了你能做什么.  \n其实作用基本一样 都是为了调用类的成员变量 和成员函数用的   \n当你希望明确使用这个类的时候，最好使用对象，如果你希望使用C++中的动态绑定，则最好使用指针或者引用 \n指针和引用用起来更灵活，容易实现多态等 \n\n类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).    \n对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).     \n在应用时:     \n1.引用成员:  对象用\"  .  \"操作符;  指针用\"  ->  \"操作符.  \n2.生命期:    若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete  在相应的地方释放分配的内存块.  \n注意:用new 一定要delete.. \n当类是有虚函数的基类,f是它的一个虚函数,则调用f时:  \n类的对象:调用的是它自己的f;  \n类的指针:调用的是分配给它空间时那种类的f; \n1.在类的声明尚未完成的情况下，可以声明指向该类的指针，但是不可声明该类的对象... \n2.父类的指针可以指向子类的对象..\n定义对象实例时，分配了内存。指针变量则未分配类对象所需内存\n指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。 \n直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。 \n至于那个效率高要看程序调用过程而定。\nC++的精髓之一就是多态性，只有指针或者引用可以达到多态。 【【【对象不行？为何不行？？？】】】】\n用指针： \n第一实现多态。 \n第二，在函数调用，传指针参数。不管你的对象或结构参数多么庞大，你用指针，传过去的就是4个字节。如果用对象，参数传递占用的资源就太大了\n\n一般来说，可以定义为对象，在如下情况考虑把数据成员定义成指针，\n- 1）有多态的情况；会用到虚函数，基类指针\n- 2）可能和别的类共享，或者只是引用别的类里的某个对象，所以生命周期不是很确定（这个可以考虑智能指针）\n- 3）大数据类，如果定义成对象，会导致当前对象无法在栈内创建","source":"_posts/gerenbijicpp.md","raw":"title: 复习笔记-C++   \ndate: 2015-3-10 12:31:49\ncategories: 总结复习\ntags: [知识点整理,C++] \n---\n总结复习，C/C++知识点\n<!--more-->\n#### 1.volatile 容易改变的变量\n修饰的是易变的变量，如果没有加volatile，则编译器可能会优化变量，之后程序可能读取的时候会直接读寄存器而不去读内存，导致读到的数据有问题。\n如果修饰之后，程序每次读数据都直接从内存上读，而不是从寄存器读。\n\n#### 2.C++迭代器失效（防止失效办法：获取返回值）\nhttp://blog.csdn.net/vipvipvip/article/details/6295973\nhttp://blog.csdn.net/damenhanter/article/details/8770076  \nhttp://wenku.baidu.com/link?url=VP4ObGLGIBeyyb8Pa125Nq-2mlrx6qoJgd3Jxbhvxkh7CDJ6NVhKQV-k-1Db2uHisqvtVtsyxBFfwa8vDPF53xOfm0UBEloN7D_Q4XPyKam  \n> a。在往vector添加一个新的成员时，vector会重新申请内存，然后把原来的值全部复制到新的内存上，这时候迭代器还指向原来的 位置，成为野指针，所以失效。  \n> b。删除元素也可能导致迭代器失效。\n\n#### 3. STL容器应用场景\n> 【序列性容器：vector，deque，list】  \n> 【关联性容器：map，set】   \n\n- vector实现了动态数组的功能，内部实现为数组，空间不够用时申请内存效率相对较低（中间插入，删除要移动内存）  \n- deque数组实现。类似于vector，两端插入和删除。  \n- list是双向链表实现。  \n- map底层为红黑树实现，效率logN,速度很快，而且基于key-value，自动排序。  \n- set底层实现为AVL，速度logN，功能上与vector类似，但是所存储内容不能包含相同的。。  \n\n ![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/37959742.jpg)\n \n #### 4.inline函数\n>  【内联函数是以代码的复制为代价，减少了函数调用（压栈，出栈开销大）的开销，从而提高代码的执行效率】\n\n- 内联函数和宏的区别是，前者是真正的函数，是由编译器去检查和展开的，而宏只是预处理器做的一个简单替换。  \n- inline关键字应该放在函数的定义处，而不是声明处。  \n- C++中类的成员函数，如果在类中直接定义函数，那么此函数不管加没加inline关键字，都会自动变为内联函数。所以说C++中，类中只是声明，定义要放在类外。  \n- 多用在短小的函数，且此函数经常被调用。一般在C++中，内联函数的定义和声明都是放在头文件中，因为其他的源文件也需要使用内联。  \n- 从inline的原理，我们可以看出，inline的原理，是用空间换取时间的做法，是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少\n#### 5. [浅拷贝、深拷贝](http://blog.csdn.net/bluescorpio/article/details/4322682)\n> 浅拷贝：在C++中在对对象复制时，只对对象中的成员数据进行简单的赋值操作称为浅拷贝。（默认为浅拷贝）。\n> \n> 深拷贝：在C++中对对象复制时，如果对象所属类中的成员变量有在堆中申请的内存时（如指针new一块内存），就不能简单的复制一下值就可以了，因为在之后的析构函数中，每个对象都会调用一次，这时候删除对象中的堆内存就会删除两次。导致不可预测的结果。这时候需要自己去写拷贝构造函数（例如也同时申请了一块内存，把值拷贝到这一块内存中），不要用默认的。这样做后，再程序到析构的时候就会释放各自申请的内存，不会导致内存归属不明问题。\n\n#### 6. [C++引用](http://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html)\n> 引用存在的意义：是为了解决在函数参数传递过程中，传递一大块数据如果以值传递的方式，那么函数调用的开销会增大，效率降低。\n\n##### 特点\n> a.如果是值传递的话，那么最好在形参前加一个const，这样就保证了引用的安全性。\n> b.C++中&不是取地址，而是一个引用的表示符。一般来说引用多用在对象，对普通的数据类型，用引用没有什么意义。\n> c.【【声明引用的同时，必须要初始化】】\n> d。引用本身不占用内存，但是用sizeof引用的时候，返回的是引用代表的那块内存的大小。\n> e。取引用的地址 &a，就是取目标变量（对象）的地址。\n\n##### 应用\n\n> a。传递参数。int test(A &a){}，提高效率，因为函数中操作的是实际的内存。并不是一个副本。   \n> b.返回值。 int & test() { } 里边的返回值应该是一个全局的变量。这样就不会产生副本了，同时也能从函数中传出来，但不能是局部变量（栈区，调用结束就销毁了），也不能是函数内部new的变量（因为返回之后我如何销毁这块内存呢？引用又不是内存地址，不能用free的。）\n\n#### 7.多态、虚函数、纯虚函数、重载\n> http://blog.csdn.net/memewry/article/details/7983267\n> http://blog.csdn.net/braveyly/article/details/5549978\n\n- 多态是指向不同的对象发送相同的消息，返回不同的结果。这里的消息是调用函数的意思。   \n- 虚函数与多态就是说基类中定义一个虚函数，然后用基类定义一个指针对象，这个对象指向子类的实例，这时候再调用相同的函数就会有不同的实现。具体说的话基类指针指向子类的实例地址，在这个指针调用虚函数的，并不会调用基类中的函数，而是根据这个虚函数表里的映射关系来找到相关对象的地址的函数入口。   \n- 纯虚函数：函数没有实现，只有一个声明。用virtual void func()= 0;这种方式声明的就叫纯虚函数。类中只要含有纯虚函数，那么这个类就变成了抽象类。   \n- 重载是一种函数实现，和多态没有关系。【重载的几个函数必须在同一个类中，而多态与它完全不同，多态是覆盖的一种表现形式，覆盖在基类中必须要有关键字virtual。】   \n- virtual关键字的作用就是为了实现动态绑定，而动态绑定的表现形式就是为多态。动态绑定有两个要求，第一个，指定为虚函数，第二个，用基类声明的指针或者引用指向派生类的对象，一般都是放在基类的函数前，派生类函数前并不需要加virtual。\n\n> 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。所以基本的一条是：无故的声明虚析构函数和永远不去声明一样是错误的。实际上，很多人这样总结：当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数。一般在多太的基类中都把xigou函数生命为virtual\n\n```\n//A为父类，B、C为子类\nA* a= new B();\na->DoSomething();\ndelete a;\na = NULL;\nA* a = new C();\na->DoSomething();\ndelete a;\na = NULL;\n\n```\n\n\n#### 8.sizeof\n\n```\ntypedef struct A{\n     int a;\n     short b;\n     double c;\n     float d;\n     int *aa;\n     char *bb;\n     char cc;\n} structA;\n\nint main(void) {\n    printf(\"%d\\n\",sizeof(structA));\n    return 0;\n}\n```\n> 以上运行结果为32.考的知识点为字节对齐和指针的大小。\n\n注意的地方：\n- a.结构体A中的顺序变化也能影响结果的不同。\n- b.结构体总大小 为 结构体中最宽的数据类型的整数倍，这里是double型，所以为8的整数倍\n- c.结构体中如果还有结构体，那么把内置的结构体顺序展开，计算大小。d.注意结构体内有数组的情况，要注意数组的类型为宽度。\n- d.如果结构体或者类中有static静态变量，那么计算结构体大小的时候，是不包含static变量的\n\n附：\n- 1.在类中，一个空类的大小也需要占用一个字节。因为空类也需要实例化。\n\n- 2.类中如果有虚函数，那么类到大小为一个指针的大小，有多少个虚函数都只有一个指针大小。。普通函数不占用内存。。。。。\n\n- 3.派生类的大小受到基类的影响，如果派生类继承两个基类，两个基类各有虚函数，那么派生类就有两个虚函数指针。\n\n\n#### 9.static\n##### 静态全局变量、静态局部变量、全局变量、局部变量\n\n- 静态局部变量：在全局数据区分配内存。第一次初始化的值会一直保存在全局数据区，之后再调用这个静态局部变量所在的函数，就不会再初始化了。如果第一次没有初始化，那么编译器会初始化为0，他的生存期是程序的整个运行周期，但是他的作用域只在函数中。\n- 局部变量：在栈中申请内存，作用域和生命期都为函数，函数结束，内存释放，且不再有效。\n- 全局变量：在所有函数中都有效。\n- 静态全局变量：与全局变量一样，唯一的不同就是作用域变小了，原来的全局变量可以在所有源文件中共享内存的，比如A文件和B文件中都要用同一个int a ，则在A中用int a，B中用extern a。但是对静态全局变量来说，A中用static int a，B中又定义int a，这个时候是无影响的，是两个不同的内存空间。\n\n##### 静态函数、普通函数\n- 静态函数与普通函数的区别只在于作用域，类似于静态全局变量和全局变量。\n- 还有一个类中的静态成员函数和类中的成员函数，前者static成员函数后，他没有this指针，他属于类，而不属于某个实例。与类中的static成员函数对应的为类中的static成员变量，静态成员函数只能访问静态成员变量，而不能访问类的其他成员变量，但是普通函数是可以访问类中的静态成员变量的。静态成员函数在类中只是声明，同时，她的赋值放在其他源文件中。用类：：static变量 访问它。另外，成员变量到定义是在进入main函数前就已经存在于内存中了，这时候如果构造函数去改变它到值，当类被实例化了，那么值就改变了。\n\n#### 10.C++命名空间\n> 存在的意义：C++函数库及其复杂和繁多，为了解决命名冲突的问题，这样就可以命名相同的函数名。\n\n\n\n#### 11.template模板\n\nC++中模板分为两种，一个是模板函数，一个是模板类\n##### 函数模板\n```\ntemplate <class T>\nT min(T x,T y)\n{ return(x<y)?x:y;}\n\nvoid main( )\n{\n     int n1=2,n2=10;\n     double d1=1.5,d2=5.6;\n     cout<< \"较小整数:\"<<min(n1,n2)<<endl;\n     cout<< \"较小实数:\"<<min(d1,d2)<<endl;\n}\n```\n\n##### 12.模板类\n> 一定要注意模板类的声明和实现一定要都放在头文件中，不然编译无法通过.\n\n```\ntemplate <class T>\nclass test{\nprivate:\n T value;\npublic:\n test(T val);\n\n void show();\n};\n\ntemplate <class T>\ntest<T>::test(T val){\n this->value = val; \n cout<<\"fffffff\"<<this->value<<endl;\n}\n\ntemplate <class T>\nvoid test<T>::show(){\n cout<<value<<endl;\n}\n//使用时：\nint main(){\n     test<MyString>  s(\"stringdddd\");\n     s.show();\n}\n```\n\n#### 13.初始化成员列表和构造函数里赋值\n> 如果是一般情况下，在构造函数里赋值就可以里，但是如果类中到成员属性 有const常量或者是对象到引用时候，这时候一定要用初始化成员列表。因为const常量只能初始化，不能赋值。\n> 第二点是因为效率。\n\n\n#### 14.语法分析器和词法分析器作用\n> （在编译器中）\n\n- 顾名思义，词法分析器检查的是词法，语法分析器分析的是语法（并不分析语义，因为语义强调的是你的逻辑），什么是词法，什么是语法你弄明白就知道了。\n- 所谓词法，源代码由字符流组成，字符流中包括关键字，变量名，方法名，括号等等符号，其中变量名要满足不能包括标点符号，不能以数字开头的数字与字母的字符串这个条件，对于括号要成对出现等等，这就是词法;\n- 而语法，词法没有问题才能进入语法分析，语法就是词排列的方法，字面意义，比如一句中文：我吃萝卜，里面有三个词我 吃 萝卜，除了“我吃萝卜”外，这三个词还可以组成，“萝卜吃我”“萝卜我吃”等，显然按照中文文法，后面的两句话是不对的，语法分析器就是分析类似这样的语法的。\n\n#### 15.如何判断一个系统是大段模式还是小端模式。\n```\ntypedef struct A{\nunsigned char a;\nunsigned char b;\nunsigned char c;\nunsigned char d;\n}a;\nint main(){\na aa;\n*((int*)&aa) = 0X01020304;\nprintf(\"%d,%d,%d,%d\\n\",aa.a,aa.b,aa.c,aa.d);\n}\n```\n详细请看：[大端模式和小端模式](http://blog.csdn.net/hackbuteer1/article/details/7722667)  \n在所有的介绍字节序的文章中都会提到字 节序分为两类：Big-Endian和Little-Endian，引用标准的Big-Endian和Little-Endian的定义如下：\n- a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。\n- b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。\n- c) 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。\n#### 16.[类和结构体的区别](http://www.cnblogs.com/vace/archive/2011/04/14/2015754.html)\n\n#### 17.类的对象 和 类的指针\n\n```\n#include <iostream> \n#include <string> \nusing namespace std; \n\nclass Student \n{ \npublic: \nstatic int number;  \nstring name; \n\npublic: \nStudent() \n{ \n} \n\nvoid set(string str) \n{ \nname = str; \nnumber++;    // 调用静态数据成员 \n} \n\nvoid print()  // 态成员函数 print() \n{ \nstd::cout < < name < <\" : The number of the students is \" < < number < < \" numbers.\" < < std::endl; // 调用静态数据成员 \n} \n}; \n\nint Student::number = 0;  // 静态数据成员初始化 \n\nint main(int argc, char** argv) \n{ \n\nStudent* s1; \ns1 = new Student(); \ns1->set(\"111\"); \n\nStudent s2; \ns2.set(\"222\"); \n\ns1->print(); \ns2.print(); \n\nreturn 0; \n} \n\n```\n对于类student ，定义了一个对象 和一个指针。  \n- 类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).   \n- 对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).  \n\n\n在应用时:   \n> \n> 1.引用成员:   对象用\"   .   \"操作符;   指针用\"   ->   \"操作符.   \n> 2.生命期:     若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete   在相应的地方释放分配的内存块.   \n\n[用new   ,一定要delete..【为何要用delete】?](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/16/2593754.html)\n\n\n- 1.malloc/free 是库函数，而new/delete是C++操作符，后者有编译器检查。\n\n- 2.前者只申请了内存，后者是申请内存和构造函数等等。用delete调用了析构函数，而free只释放内存。\n\n类的对象:用的是内存栈,是个局部的临时变量.   \n  类的指针:用的是内存堆,是个永久变量,除非你释放它.   \n    \n  当类是有虚函数的基类,Func是它的一个虚函数,则调用Func时:   \n  类的对象:调用的是它自己的Func;   \n  类的指针:调用的是分配给它空间时那种类的Func;  \n对于一个类的对象和这个类的指针（用new运算符分配内存）在应用时有何区别   \n  1.类和对象是两回事,对象是类的实例;   \n  2.对象是在栈中分配的,使用new生成的对象是在堆中分配的;   \n  3.要发挥虚函数的强大作用,必须使用指针来访问对象.  \n  \n  \n  指针可以实现多态，直接用对象不行   \n执行定义对象，在栈空间   \nnew处的在堆  \n注意名字的类型.  \n一个是Student   \n一个是Student\\*    \nStudent是直接访问一个对象   \nStudent\\*是间接访问一个对象,因为通过了一个指针作媒介.  \n类型决定了你能做什么.  \n其实作用基本一样 都是为了调用类的成员变量 和成员函数用的   \n当你希望明确使用这个类的时候，最好使用对象，如果你希望使用C++中的动态绑定，则最好使用指针或者引用 \n指针和引用用起来更灵活，容易实现多态等 \n\n类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).    \n对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).     \n在应用时:     \n1.引用成员:  对象用\"  .  \"操作符;  指针用\"  ->  \"操作符.  \n2.生命期:    若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete  在相应的地方释放分配的内存块.  \n注意:用new 一定要delete.. \n当类是有虚函数的基类,f是它的一个虚函数,则调用f时:  \n类的对象:调用的是它自己的f;  \n类的指针:调用的是分配给它空间时那种类的f; \n1.在类的声明尚未完成的情况下，可以声明指向该类的指针，但是不可声明该类的对象... \n2.父类的指针可以指向子类的对象..\n定义对象实例时，分配了内存。指针变量则未分配类对象所需内存\n指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。 \n直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。 \n至于那个效率高要看程序调用过程而定。\nC++的精髓之一就是多态性，只有指针或者引用可以达到多态。 【【【对象不行？为何不行？？？】】】】\n用指针： \n第一实现多态。 \n第二，在函数调用，传指针参数。不管你的对象或结构参数多么庞大，你用指针，传过去的就是4个字节。如果用对象，参数传递占用的资源就太大了\n\n一般来说，可以定义为对象，在如下情况考虑把数据成员定义成指针，\n- 1）有多态的情况；会用到虚函数，基类指针\n- 2）可能和别的类共享，或者只是引用别的类里的某个对象，所以生命周期不是很确定（这个可以考虑智能指针）\n- 3）大数据类，如果定义成对象，会导致当前对象无法在栈内创建","slug":"gerenbijicpp","published":1,"updated":"2015-08-10T12:26:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j5h0026o9d34cry1u0c"},{"title":"复习笔记-操作系统","date":"2015-05-17T23:11:44.000Z","_content":"- 进程管理\n- 内存管理\n- 文件管理\n- 设备管理\n<!--more-->\n\n#### [linux复习推荐博客](http://blog.csdn.net/zjf280441589 )\n\n### 一.进程管理\n#### 1.进程分为五种状态：就绪、运行、等待、暂停、僵死。\n进程调度实际上是就绪和运行的来回切换。等待状态是进程在等待IO操作完成，这时系统就会给等待的进程一个中断，使之释放cpu变为等待状态。暂停状态与等待状态类似。僵死状态是因为进程运行结束，释放了除PCB之外的所有资源。\n#### 2.PCB，进程控制块。\n进程调度和进程控制实际上靠的就是PCB来标识的。系统每创建新的进程，就会创建一个PCB，这个PCB分为两部分，一部分放在内核栈中，可以理解为一个指针，另一部分放在用户进程栈中。\n它包括：\n控制信息：记录了当前的状态，调度策略，优先级，时间片。\n现场信息：时间片用完后，要把目前的现场状态记录下来，简单说就是把当前cpu的寄存器值存储起来。以便下次调度的时候，cpu能够迅速找到上次的地方。\n其他资源：进程的地址空间，文件系统等。\n#### 3.系统调用\n实际上是一个从用户态-》内核态-》用户态的过程。\n#### 4.进程控制。\n进程控制就是管理进程的其他几种状态的转换，当然这个过程不包括就绪--------运行的转换。跟PCB关系密切。比如创建进程，销毁进程，阻塞进程，唤醒进程。\n#### 5.进程调度常见的算法\n（这些算法都是综合使用的，没有只用其中的一种）\nFIFO，时间片轮转法（这个过程包括时间片和优先级的综合使用），普通调度算法（与时间片轮转法类似，只不过时间片耗尽完之后，要放到过期队列中）\n#### 6.进程通信\n> 管道：同步的，一个进程做为输入端，另一个进程作为输出端，中间用管道传送，相关函数为系统调用pipe().在linux下ps x|grep ping 就是一个典型的进程间通信的例子。  \n\n> 信号量：同步的，其实信号量更多的是解决两个进程间的同步问题，两个进程同时访问一块内存的数据时，这时候要采取一些措施对这块内存保护，p,v就是解决这个问题的。s为信号量。p为-，v为+\n> sem_wait(&sem); 临界区；sem_post(&sem);\n\n> \n> 信号：linux系统下由很多都是由信号作为通信的标志，比如kill pid\n> \n> 消息队列：与管道类似，只不过这个是异步的。传递的信息多。\n\n> 套接字：socket套接字利用了网络通信的port，实际上用127.0.0.1的两个端口就可以相互之间传送数据，此时并没有通过网络出去，而是在进程间传送数据。\n\n> 共享内存：见9\n\n\n——————\n> ##### 常见的IPC通信原理图：\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/77923111.jpg)\n> ##### 共享内存通信原理图如下：\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/48069999.jpg)\n\n#### 7.进程与线程的比较\n在创建线程和销毁线程的过程中，系统开销比进程要小的多。\n线程可以充分利用多核CPU的优势。因为无论有几核的cpu，只能有一个进程被调入cpu运行，线程则不同。\n多个线程共享同一内存地址空间，所以线程间的通信要简单的多，也安全的多。\n\n#### 8.线程同步的方式（unix网络编程：进程间通信 127-188页）\n- 条件变量\n- 互斥锁（pthread_mutex_lock,pthread_mutex_unlock）：临界区锁上，不允许读写。\n- 信号量(sem_wait，sem_post)：有名信号量更多用于进程间通信，无名信号量更多用于线程间通信。\n- 读写锁：在临界区被锁上，只有读可以。临界区没有被锁上，则读写都可以。比互斥锁并发性强。\n\n##### 条件变量，互斥锁，信号量区别\n(截图在unix网络编程：进程间通信 178页)\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/59197613.jpg)\n#### 9.共享内存【同步的、需要配合有名信号量使用】\n> **（ 动态库实际上就是很多个进程都共同享有，它存在于同一块物理内存中，如math.so）**： 共享内存是进程间通信中最简单的方式之一。\n共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。\n> 共享内存效率高，并不需要内核去做中转。\n> 由于没有内核的管理，所以多进程同时访问的这块内存的同步工作就由用户自己去完成，这时候可以采用信号量进行同步。\n> 共享内存段到最大限制为32M。它本身存在于物理内存中，每个进程都可以访问的到，在用户的进程空间中，位于堆和zhan之间到部分，可以称为内存共享映射区。\n\n### 二.内存管理\nlinux内存分布图：\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/84552973.jpg)\n- 上图是进程的虚拟地址空间，每个进程都有。通过页面与物理内存对应，物理内存到位置和存储情况无法获知，只有内核知道。\n- 栈在高地址位置，并从高往下增长栈空间，最大默认为8MB\n- 堆在内存到低地址处，从低往高增长，最大为3G。\n- 中间到为共享内存或者动态库到存储区域。最大默认为32MB。\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/37937918.jpg)\n上图与linux内存分布图相比少了地址到走向正好相反。这张是C/C++的内存分布图。\n#### 1.包括：内存的分配和回收、地址空间转换、存储空间的保护、内存的扩容。\nhttp://blog.chinaunix.net/uid-27052262-id-3237894.html\n#### 2.地址空间转换：\n其实我们应用程序用的内存都是逻辑地址，并不是真正的物理内存地址。这样做的目的是为了提高内存使用率。虚拟地址->物理地址，这个过程是靠内存管理模块（操作系统提供的分页技术）和硬件单元（MMU）共同完成的。\n#### 3.分页技术\n逻辑地址高20位为页号，低12位为空间内偏移量。页帧为物理地址中的一页。操作系统采用页表来构建页号与页帧的映射关系。\n转换过程：讲逻辑地址分成页号和页内偏移量，再用页号为检索去页表中查找对应的页帧，再用MMU去换算成真正的物理地址，cpu根据此地址进行内存寻址，然后运算。\n#### 4.内存扩容（虚拟内存）\n缘何存在：由于现在的应用程序内存占用较大，所以单纯靠物理内存来提供寻址显然不够。虚拟内存就是为了解决物理内存不足的问题。\n现在的程序运行，cpu在一个时间段内只访问程序的一部分，并不是全部，所以调入到内存中的好多内存空间都不会再短期内使用，这时候需要把这一部分内存放入到速度稍微慢一些的外存上，使内存空间增大一些。虚拟内存技术就是这样的条件下诞生的。这块内存区域也叫交换分区。\n过程应该是：进程调入到内存中，有很多不用的内存将会放入到虚拟内存中。当要访问的页面对应的页帧并没有在页表中标识为有效时，这时候MMU就会发出一个缺页中断，CPU接收到中断后，阻塞原进程，然后进入中断处理程序把swap分区缺页信息调入到内存中，并修改相应的页表，此时中断处理程序结束，cpu开始执行原进程。\n#### 5.FIFO 和LRU算法\n参考:\n\nhttp://baike.baidu.com/link?url=V6QOR5RFyL7r952PDCnpscF0A9e6a3shpx9Vkf41WGjzeHA3jY0nZtX0i0Av4CjvPFNBPfdNIMuKyG6VCQkKKq\n\n  \nhttp://flychao88.iteye.com/blog/1977653\n\n\nhttp://yinzhezq.blog.163.com/blog/static/1648628902010112961039187/\n\n首先说缺页请求：\n缺页是说进程要操作某块内存的时候，就会进行压入队列的操作，他会检查现有的页面是不是存在，如果不存在，那么就发出缺页中断，这时候要么直接插入到内存块中，要么从虚拟内存中拿出。\n\nLRU算法：需要一个队列，这个队列做了一些策略，就是把那些之后立刻又用到的内存页面 再换到对尾的位置。\n\n\nFIFO算法：同样需要一个队列，与LRU不同的是，如果内存块中有这个页面，并不置换顺序。\n\n#### 6.内存泄漏\n也称作“存储渗漏”\n\n用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。即所谓内存泄漏。\n### 三.文件管理\n- 1.FCB 文件控制块\n类似于PCB，每个文件都有一个FCB，FCB块在EXT3中目前有两个部分组成，一个是目录项（存储文件名和索引值，这个为次部），另一个是索引节点（这个是主部，包含除文件名之外的所有信息）。\n- 2.文件系统层次\n由上到下：虚拟文件系统--------磁盘文件系统映射层（实际文件系统）---------通用块层--------驱动-----------磁盘\n除了最后一个，前边的这几个都是内核去操作和管理的。\n VFS：【它为用户进程和内核提供一个使用的统一接口。为用户隐藏不同文件系统的差异。】收到系统调用请求，利用实际文件系统和IO来处理请求，然后返回结果。 通用块层：为内核隐藏不同的硬件差异。提供统一的接口去操作硬件\n\n### 四.设备管理 \n- 1.关键技术：中断技术、缓冲与缓存技术、DMA技术\n- 2.缓冲技术\n> 为了解决设备和CPU之间传输速度不匹配的问题。cpu的速度相当快，而大多数的IO设备速度较慢，这样传输的过程中，cpu总是在等待设备的IO。对cpu来说造成了浪费，同时其他进程也分配不到cpu，效率低下。\n> 这时候进程控制程序会把等待IO完成的进程设置为等待状态。具体过程如下：当进程要输出给设备的时候，cpu把需要的数据传送给“缓冲区”，由于缓冲区在内存中，速度也很快，传送完之后，进程接着干其他事情。至于真正发送给设备是靠内核去做，把缓冲区的数据发送给设备。当进程要读设备数据的时候，也是同理，先是告诉内核要读设备，然后内核就从设备中读数据到缓冲区，读好之后把缓冲区的数据拷贝到用户空间，这时候用户进程就可以读了。【内核管理的，应用进程触碰不到的。】\n- 3.缓存技术 \n> 为了解决cpu频繁访问设备的次数。比如cpu总是要访问一个设备，每次访问设备，都要去读设备，这样总体来说还是很慢，如果设备把常用的数据放在缓存区，由于缓存区的速度和内存是一样的，这样读取速度就提高了。\n\n- 4.DMA 为了减少外设与内存的通信依赖cpu的次数。\n","source":"_posts/caozuoxitong.md","raw":"title: 复习笔记-操作系统  \ndate: 2015-5-17 19:11:44\ncategories: 操作系统\ntags: [复习笔记,操作系统,linux,进程线程] \n---\n- 进程管理\n- 内存管理\n- 文件管理\n- 设备管理\n<!--more-->\n\n#### [linux复习推荐博客](http://blog.csdn.net/zjf280441589 )\n\n### 一.进程管理\n#### 1.进程分为五种状态：就绪、运行、等待、暂停、僵死。\n进程调度实际上是就绪和运行的来回切换。等待状态是进程在等待IO操作完成，这时系统就会给等待的进程一个中断，使之释放cpu变为等待状态。暂停状态与等待状态类似。僵死状态是因为进程运行结束，释放了除PCB之外的所有资源。\n#### 2.PCB，进程控制块。\n进程调度和进程控制实际上靠的就是PCB来标识的。系统每创建新的进程，就会创建一个PCB，这个PCB分为两部分，一部分放在内核栈中，可以理解为一个指针，另一部分放在用户进程栈中。\n它包括：\n控制信息：记录了当前的状态，调度策略，优先级，时间片。\n现场信息：时间片用完后，要把目前的现场状态记录下来，简单说就是把当前cpu的寄存器值存储起来。以便下次调度的时候，cpu能够迅速找到上次的地方。\n其他资源：进程的地址空间，文件系统等。\n#### 3.系统调用\n实际上是一个从用户态-》内核态-》用户态的过程。\n#### 4.进程控制。\n进程控制就是管理进程的其他几种状态的转换，当然这个过程不包括就绪--------运行的转换。跟PCB关系密切。比如创建进程，销毁进程，阻塞进程，唤醒进程。\n#### 5.进程调度常见的算法\n（这些算法都是综合使用的，没有只用其中的一种）\nFIFO，时间片轮转法（这个过程包括时间片和优先级的综合使用），普通调度算法（与时间片轮转法类似，只不过时间片耗尽完之后，要放到过期队列中）\n#### 6.进程通信\n> 管道：同步的，一个进程做为输入端，另一个进程作为输出端，中间用管道传送，相关函数为系统调用pipe().在linux下ps x|grep ping 就是一个典型的进程间通信的例子。  \n\n> 信号量：同步的，其实信号量更多的是解决两个进程间的同步问题，两个进程同时访问一块内存的数据时，这时候要采取一些措施对这块内存保护，p,v就是解决这个问题的。s为信号量。p为-，v为+\n> sem_wait(&sem); 临界区；sem_post(&sem);\n\n> \n> 信号：linux系统下由很多都是由信号作为通信的标志，比如kill pid\n> \n> 消息队列：与管道类似，只不过这个是异步的。传递的信息多。\n\n> 套接字：socket套接字利用了网络通信的port，实际上用127.0.0.1的两个端口就可以相互之间传送数据，此时并没有通过网络出去，而是在进程间传送数据。\n\n> 共享内存：见9\n\n\n——————\n> ##### 常见的IPC通信原理图：\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/77923111.jpg)\n> ##### 共享内存通信原理图如下：\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/48069999.jpg)\n\n#### 7.进程与线程的比较\n在创建线程和销毁线程的过程中，系统开销比进程要小的多。\n线程可以充分利用多核CPU的优势。因为无论有几核的cpu，只能有一个进程被调入cpu运行，线程则不同。\n多个线程共享同一内存地址空间，所以线程间的通信要简单的多，也安全的多。\n\n#### 8.线程同步的方式（unix网络编程：进程间通信 127-188页）\n- 条件变量\n- 互斥锁（pthread_mutex_lock,pthread_mutex_unlock）：临界区锁上，不允许读写。\n- 信号量(sem_wait，sem_post)：有名信号量更多用于进程间通信，无名信号量更多用于线程间通信。\n- 读写锁：在临界区被锁上，只有读可以。临界区没有被锁上，则读写都可以。比互斥锁并发性强。\n\n##### 条件变量，互斥锁，信号量区别\n(截图在unix网络编程：进程间通信 178页)\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/59197613.jpg)\n#### 9.共享内存【同步的、需要配合有名信号量使用】\n> **（ 动态库实际上就是很多个进程都共同享有，它存在于同一块物理内存中，如math.so）**： 共享内存是进程间通信中最简单的方式之一。\n共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。\n> 共享内存效率高，并不需要内核去做中转。\n> 由于没有内核的管理，所以多进程同时访问的这块内存的同步工作就由用户自己去完成，这时候可以采用信号量进行同步。\n> 共享内存段到最大限制为32M。它本身存在于物理内存中，每个进程都可以访问的到，在用户的进程空间中，位于堆和zhan之间到部分，可以称为内存共享映射区。\n\n### 二.内存管理\nlinux内存分布图：\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/84552973.jpg)\n- 上图是进程的虚拟地址空间，每个进程都有。通过页面与物理内存对应，物理内存到位置和存储情况无法获知，只有内核知道。\n- 栈在高地址位置，并从高往下增长栈空间，最大默认为8MB\n- 堆在内存到低地址处，从低往高增长，最大为3G。\n- 中间到为共享内存或者动态库到存储区域。最大默认为32MB。\n\n![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-11/37937918.jpg)\n上图与linux内存分布图相比少了地址到走向正好相反。这张是C/C++的内存分布图。\n#### 1.包括：内存的分配和回收、地址空间转换、存储空间的保护、内存的扩容。\nhttp://blog.chinaunix.net/uid-27052262-id-3237894.html\n#### 2.地址空间转换：\n其实我们应用程序用的内存都是逻辑地址，并不是真正的物理内存地址。这样做的目的是为了提高内存使用率。虚拟地址->物理地址，这个过程是靠内存管理模块（操作系统提供的分页技术）和硬件单元（MMU）共同完成的。\n#### 3.分页技术\n逻辑地址高20位为页号，低12位为空间内偏移量。页帧为物理地址中的一页。操作系统采用页表来构建页号与页帧的映射关系。\n转换过程：讲逻辑地址分成页号和页内偏移量，再用页号为检索去页表中查找对应的页帧，再用MMU去换算成真正的物理地址，cpu根据此地址进行内存寻址，然后运算。\n#### 4.内存扩容（虚拟内存）\n缘何存在：由于现在的应用程序内存占用较大，所以单纯靠物理内存来提供寻址显然不够。虚拟内存就是为了解决物理内存不足的问题。\n现在的程序运行，cpu在一个时间段内只访问程序的一部分，并不是全部，所以调入到内存中的好多内存空间都不会再短期内使用，这时候需要把这一部分内存放入到速度稍微慢一些的外存上，使内存空间增大一些。虚拟内存技术就是这样的条件下诞生的。这块内存区域也叫交换分区。\n过程应该是：进程调入到内存中，有很多不用的内存将会放入到虚拟内存中。当要访问的页面对应的页帧并没有在页表中标识为有效时，这时候MMU就会发出一个缺页中断，CPU接收到中断后，阻塞原进程，然后进入中断处理程序把swap分区缺页信息调入到内存中，并修改相应的页表，此时中断处理程序结束，cpu开始执行原进程。\n#### 5.FIFO 和LRU算法\n参考:\n\nhttp://baike.baidu.com/link?url=V6QOR5RFyL7r952PDCnpscF0A9e6a3shpx9Vkf41WGjzeHA3jY0nZtX0i0Av4CjvPFNBPfdNIMuKyG6VCQkKKq\n\n  \nhttp://flychao88.iteye.com/blog/1977653\n\n\nhttp://yinzhezq.blog.163.com/blog/static/1648628902010112961039187/\n\n首先说缺页请求：\n缺页是说进程要操作某块内存的时候，就会进行压入队列的操作，他会检查现有的页面是不是存在，如果不存在，那么就发出缺页中断，这时候要么直接插入到内存块中，要么从虚拟内存中拿出。\n\nLRU算法：需要一个队列，这个队列做了一些策略，就是把那些之后立刻又用到的内存页面 再换到对尾的位置。\n\n\nFIFO算法：同样需要一个队列，与LRU不同的是，如果内存块中有这个页面，并不置换顺序。\n\n#### 6.内存泄漏\n也称作“存储渗漏”\n\n用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。即所谓内存泄漏。\n### 三.文件管理\n- 1.FCB 文件控制块\n类似于PCB，每个文件都有一个FCB，FCB块在EXT3中目前有两个部分组成，一个是目录项（存储文件名和索引值，这个为次部），另一个是索引节点（这个是主部，包含除文件名之外的所有信息）。\n- 2.文件系统层次\n由上到下：虚拟文件系统--------磁盘文件系统映射层（实际文件系统）---------通用块层--------驱动-----------磁盘\n除了最后一个，前边的这几个都是内核去操作和管理的。\n VFS：【它为用户进程和内核提供一个使用的统一接口。为用户隐藏不同文件系统的差异。】收到系统调用请求，利用实际文件系统和IO来处理请求，然后返回结果。 通用块层：为内核隐藏不同的硬件差异。提供统一的接口去操作硬件\n\n### 四.设备管理 \n- 1.关键技术：中断技术、缓冲与缓存技术、DMA技术\n- 2.缓冲技术\n> 为了解决设备和CPU之间传输速度不匹配的问题。cpu的速度相当快，而大多数的IO设备速度较慢，这样传输的过程中，cpu总是在等待设备的IO。对cpu来说造成了浪费，同时其他进程也分配不到cpu，效率低下。\n> 这时候进程控制程序会把等待IO完成的进程设置为等待状态。具体过程如下：当进程要输出给设备的时候，cpu把需要的数据传送给“缓冲区”，由于缓冲区在内存中，速度也很快，传送完之后，进程接着干其他事情。至于真正发送给设备是靠内核去做，把缓冲区的数据发送给设备。当进程要读设备数据的时候，也是同理，先是告诉内核要读设备，然后内核就从设备中读数据到缓冲区，读好之后把缓冲区的数据拷贝到用户空间，这时候用户进程就可以读了。【内核管理的，应用进程触碰不到的。】\n- 3.缓存技术 \n> 为了解决cpu频繁访问设备的次数。比如cpu总是要访问一个设备，每次访问设备，都要去读设备，这样总体来说还是很慢，如果设备把常用的数据放在缓存区，由于缓存区的速度和内存是一样的，这样读取速度就提高了。\n\n- 4.DMA 为了减少外设与内存的通信依赖cpu的次数。\n","slug":"caozuoxitong","published":1,"updated":"2015-08-11T04:41:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j5r002bo9d34g8snari"},{"title":"移植busybox到开发板","date":"2015-04-11T18:01:01.000Z","_content":"\n折腾了两天，终于把这个做好，移植的工作还是很辛苦的，目前自己对/etc/下的配置文件的逻辑关系还不是太清晰，这还需要后续的努力，一些心得，更多的是备忘，把这些东西记录下来。\n\n<!--more-->\n## 1.我的需求\n\n由于目前的实验平台没有telnet和ftp，所以在软件调试过程中，只能用串口和SD卡来交互和传送文件。于是就想到自己定制一个文件系统，此文件系统包含这两个功能，另外由于项目的需求为一个演示系统，所以还需要在主板自带的屏幕上输出 程序的打印信息。\n\n## 2.实验环境\n1.PC机位ubuntu 12.04 , 交叉编译工具gcc version 4.4.1 (Sourcery G++ Lite 2009q3-67)\n\n2.嵌入式主板为：DevKit 8000 \n\n3.busybox版本为：1.13.1\n\n4.vsftp 版本为：2.0.5\n### 3.实验过程\n1.首先需要编译busybox，编译的过程网上有很多的教程。telnet就再busybox中编译。\n\nmake install 之后会在 当前目前下的_install/目录下生成所需要的几个目录。\nbin sbin linuxrc usr(这个我并没有编译)\n\n2.把上边的三个文件夹放到一个新建的rootfs/下，剩下的文件我并没有自己去建。 把原来devkit8000的文件系统解压之后，我放到了rootfs下，（需要注意的是，/etc目录下的文件我没有拷贝，因为之前拷贝过很多次，会出 现各种各样的问题，所以/etc下的文件，我用的是天嵌的板子tq335x文件系统中的/etc/）\n\n3.值得注意的是，profile和init.d/rcS中的文件要进行一些调整，以下是调整之后的。\n```\n/etc/profile  \n```\n\n```\n# Ash profile   \n# vim: syntax=sh  \n  \n# No core files by default  \n#ulimit -S -c 0 > /dev/null 2>&1  \n  \nexport set HOME=/root  \nexport set QTDIR=/opt/PDA  \nexport set QPEDIR=/opt/PDA  \nexport set QWS_DISPLAY=\"LinuxFB:/dev/fb0\"  \nexport set QWS_KEYBOARD=\"TTY:/dev/tty1\"  \nif [ -f /sys/devices/virtual/input/mice/subsystem/input$ts/uevent ] ; then  \n        export set TSLIB_CONFFILE=/etc/ts.conf  \n        if [ -n \"$pointer\" ] ; then  \n                export set TSLIB_CALIBFILE=$pointer  \n        fi  \n        export set TSLIB_TSDEVICE=/dev/event$ts  \n        export set TSLIB_PLUGINDIR=/lib/ts  \n        export set QWS_MOUSE_PROTO=\"TSLIB:/dev/event$ts MouseMan:/dev/mice\"  \nfi  \nexport set QT_PLUGIN_PATH=$QTDIR/plugins/  \nexport set QT_QWS_FONTDIR=$QTDIR/lib/fonts/  \nexport set PATH=$QPEDIR/bin:$PATH  \nexport set LD_LIBRARY_PATH=$QTDIR/lib:$QPEDIR/plugins/imageformats:$QPEDIR/plugins/accessible:$LD_LIBRARY_PATH  \n  \n#USER=\"`id -un`\"  \n#LOGNAME=$USER  \n#PS1='[\\u@\\h \\W]# '  \n#PATH=$PATH  \n  \n#HOSTNAME=`/bin/hostname`  \n  \n/bin/hostname FlyingGames  \nPS1=\"[\"\"$(whoami)\"@\"$(hostname): \"'$PWD'\"]# \"  \n  \n  \nexport USER LOGNAME PS1 PATH  \n\n[cpp] view plaincopyprint?\n/etc/init.d/rcS  \n[cpp] view plaincopyprint?\n#!/bin/sh  \n  \n  \nPATH=/sbin:/bin:/usr/sbin:/usr/bin  \nrunlevel=S  \nprevlevel=N  \numask 022  \nexport PATH runlevel prevlevel  \n  \n#  \n#       Trap CTRL-C &c only in this shell so we can interrupt subprocesses.  \n#  \n  \nmount -a  \nmkdir -p /dev/pts  \nmount -t devpts devpts /dev/pts  \nmount -n -t usbfs none /proc/bus/usb  \necho /sbin/mdev > /proc/sys/kernel/hotplug  \nmdev -s  \nmkdir -p /var/lock  \n  \n#modprobe rt5370sta  \n  \nhwclock -s  \n#EmbedSky_wdg &  \n  \n  \nifconfig lo 127.0.0.1  \nnet_set &  \n  \n/etc/rc.d/init.d/netd start  \n/etc/rc.d/init.d/httpd start  \n/etc/rc.d/init.d/leds start  \n  \nInputAdapter  \n#pda &  \n#/bin/hostname -F /etc/sysconfig/HOSTNAME  \n  \n#telnet  stream  tcp     nowait  root    /usr/sbin/telnetd       /usr/sbin/telnetd -i  \n/usr/sbin/telnetd &  \n/usr/sbin/vsftpd &  \n  \n  \ninsmod /usr/lib/rt3070sta.ko  \nsleep 1  \n```\n至此，telnet已经做完。\n\n4.接下来要做的是vsftp的移植，vsftp不同于telnetd，telnetd是在busybox自带的就有了，但是ftpd我在make menuconfig后找了好半天，都找不到有ftpd，无奈，只能用vsftp这个第三方的程序。[参考](http://blog.163.com/sunshine_linting/blog/static/44893323201391010522601/)\n\n5.接下来要做的是把文件系统打包，拷贝到主板上。\n\n```\n/home/embest/work/tools/mkfs.ubifs -r rootfs -m 2048 -e 129024 -c 812 -o ubifs.img\n/home/embest/work/tools/ubinize -o ubi.img -m 2048 -p 128KiB -s 512 /home/embest/work/tools/ubinize.cfg\ncp ubi.img /media/LABEL1\n```\n6.把sd卡插到主板上\n\n\n```\nmmcinit\nfatload mmc 0:1 81000000 ubi.img\nnand unlock\nnand ecc sw\nnand erase 680000\nband write.i 81000000 680000 $(file size)\n//开机即可。\n```\n**附：开机之后在主板的屏幕上是没有任何登陆信息的。这时候需要通过登陆telnet然后启动程序。启动程序的时候记得加个重定向 。**\n\n```\nxxxx > /dev/tty0\n\nWifi-Module-804  /   WifiModule\n```\n","source":"_posts/busybox.md","raw":"title: 移植busybox到开发板   \ndate: 2015-4-11 14:01:01\ncategories: 嵌入式linux \ntags: [文件系统,busybox,移植] \n\n---\n\n折腾了两天，终于把这个做好，移植的工作还是很辛苦的，目前自己对/etc/下的配置文件的逻辑关系还不是太清晰，这还需要后续的努力，一些心得，更多的是备忘，把这些东西记录下来。\n\n<!--more-->\n## 1.我的需求\n\n由于目前的实验平台没有telnet和ftp，所以在软件调试过程中，只能用串口和SD卡来交互和传送文件。于是就想到自己定制一个文件系统，此文件系统包含这两个功能，另外由于项目的需求为一个演示系统，所以还需要在主板自带的屏幕上输出 程序的打印信息。\n\n## 2.实验环境\n1.PC机位ubuntu 12.04 , 交叉编译工具gcc version 4.4.1 (Sourcery G++ Lite 2009q3-67)\n\n2.嵌入式主板为：DevKit 8000 \n\n3.busybox版本为：1.13.1\n\n4.vsftp 版本为：2.0.5\n### 3.实验过程\n1.首先需要编译busybox，编译的过程网上有很多的教程。telnet就再busybox中编译。\n\nmake install 之后会在 当前目前下的_install/目录下生成所需要的几个目录。\nbin sbin linuxrc usr(这个我并没有编译)\n\n2.把上边的三个文件夹放到一个新建的rootfs/下，剩下的文件我并没有自己去建。 把原来devkit8000的文件系统解压之后，我放到了rootfs下，（需要注意的是，/etc目录下的文件我没有拷贝，因为之前拷贝过很多次，会出 现各种各样的问题，所以/etc下的文件，我用的是天嵌的板子tq335x文件系统中的/etc/）\n\n3.值得注意的是，profile和init.d/rcS中的文件要进行一些调整，以下是调整之后的。\n```\n/etc/profile  \n```\n\n```\n# Ash profile   \n# vim: syntax=sh  \n  \n# No core files by default  \n#ulimit -S -c 0 > /dev/null 2>&1  \n  \nexport set HOME=/root  \nexport set QTDIR=/opt/PDA  \nexport set QPEDIR=/opt/PDA  \nexport set QWS_DISPLAY=\"LinuxFB:/dev/fb0\"  \nexport set QWS_KEYBOARD=\"TTY:/dev/tty1\"  \nif [ -f /sys/devices/virtual/input/mice/subsystem/input$ts/uevent ] ; then  \n        export set TSLIB_CONFFILE=/etc/ts.conf  \n        if [ -n \"$pointer\" ] ; then  \n                export set TSLIB_CALIBFILE=$pointer  \n        fi  \n        export set TSLIB_TSDEVICE=/dev/event$ts  \n        export set TSLIB_PLUGINDIR=/lib/ts  \n        export set QWS_MOUSE_PROTO=\"TSLIB:/dev/event$ts MouseMan:/dev/mice\"  \nfi  \nexport set QT_PLUGIN_PATH=$QTDIR/plugins/  \nexport set QT_QWS_FONTDIR=$QTDIR/lib/fonts/  \nexport set PATH=$QPEDIR/bin:$PATH  \nexport set LD_LIBRARY_PATH=$QTDIR/lib:$QPEDIR/plugins/imageformats:$QPEDIR/plugins/accessible:$LD_LIBRARY_PATH  \n  \n#USER=\"`id -un`\"  \n#LOGNAME=$USER  \n#PS1='[\\u@\\h \\W]# '  \n#PATH=$PATH  \n  \n#HOSTNAME=`/bin/hostname`  \n  \n/bin/hostname FlyingGames  \nPS1=\"[\"\"$(whoami)\"@\"$(hostname): \"'$PWD'\"]# \"  \n  \n  \nexport USER LOGNAME PS1 PATH  \n\n[cpp] view plaincopyprint?\n/etc/init.d/rcS  \n[cpp] view plaincopyprint?\n#!/bin/sh  \n  \n  \nPATH=/sbin:/bin:/usr/sbin:/usr/bin  \nrunlevel=S  \nprevlevel=N  \numask 022  \nexport PATH runlevel prevlevel  \n  \n#  \n#       Trap CTRL-C &c only in this shell so we can interrupt subprocesses.  \n#  \n  \nmount -a  \nmkdir -p /dev/pts  \nmount -t devpts devpts /dev/pts  \nmount -n -t usbfs none /proc/bus/usb  \necho /sbin/mdev > /proc/sys/kernel/hotplug  \nmdev -s  \nmkdir -p /var/lock  \n  \n#modprobe rt5370sta  \n  \nhwclock -s  \n#EmbedSky_wdg &  \n  \n  \nifconfig lo 127.0.0.1  \nnet_set &  \n  \n/etc/rc.d/init.d/netd start  \n/etc/rc.d/init.d/httpd start  \n/etc/rc.d/init.d/leds start  \n  \nInputAdapter  \n#pda &  \n#/bin/hostname -F /etc/sysconfig/HOSTNAME  \n  \n#telnet  stream  tcp     nowait  root    /usr/sbin/telnetd       /usr/sbin/telnetd -i  \n/usr/sbin/telnetd &  \n/usr/sbin/vsftpd &  \n  \n  \ninsmod /usr/lib/rt3070sta.ko  \nsleep 1  \n```\n至此，telnet已经做完。\n\n4.接下来要做的是vsftp的移植，vsftp不同于telnetd，telnetd是在busybox自带的就有了，但是ftpd我在make menuconfig后找了好半天，都找不到有ftpd，无奈，只能用vsftp这个第三方的程序。[参考](http://blog.163.com/sunshine_linting/blog/static/44893323201391010522601/)\n\n5.接下来要做的是把文件系统打包，拷贝到主板上。\n\n```\n/home/embest/work/tools/mkfs.ubifs -r rootfs -m 2048 -e 129024 -c 812 -o ubifs.img\n/home/embest/work/tools/ubinize -o ubi.img -m 2048 -p 128KiB -s 512 /home/embest/work/tools/ubinize.cfg\ncp ubi.img /media/LABEL1\n```\n6.把sd卡插到主板上\n\n\n```\nmmcinit\nfatload mmc 0:1 81000000 ubi.img\nnand unlock\nnand ecc sw\nnand erase 680000\nband write.i 81000000 680000 $(file size)\n//开机即可。\n```\n**附：开机之后在主板的屏幕上是没有任何登陆信息的。这时候需要通过登陆telnet然后启动程序。启动程序的时候记得加个重定向 。**\n\n```\nxxxx > /dev/tty0\n\nWifi-Module-804  /   WifiModule\n```\n","slug":"busybox","published":1,"updated":"2015-08-09T06:28:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j65002jo9d3xud8ojew"},{"title":"良心DNS","date":"2015-07-16T00:10:29.000Z","description":"提供可替换的DNS","_content":"## 比较好用的dns\n### 国内DNS\n<!--more-->\n```\n1.aliDNS：223.5.5.5；223.6.6.6\n\n2.114DNS：114.114.114.114；114.114.115.115\n\n3.oneDNS：112.124.47.27\n```\n### 国外DNS\n```\n1.V2EX DNS：199.91.73.222；178.79.131.110\n\n2.Google DNS：8.8.8.8；8.8.4.4\n\n3.OpenDNS：208.67.222.222；208.67.220.220\n```","source":"_posts/Liangxindns.md","raw":"title: 良心DNS \ndate: 2015-7-15 20:10:29\ncategories: 网络技术 \ntags: [DNS，第三方DNS] \ndescription: 提供可替换的DNS\n---\n## 比较好用的dns\n### 国内DNS\n<!--more-->\n```\n1.aliDNS：223.5.5.5；223.6.6.6\n\n2.114DNS：114.114.114.114；114.114.115.115\n\n3.oneDNS：112.124.47.27\n```\n### 国外DNS\n```\n1.V2EX DNS：199.91.73.222；178.79.131.110\n\n2.Google DNS：8.8.8.8；8.8.4.4\n\n3.OpenDNS：208.67.222.222；208.67.220.220\n```","slug":"Liangxindns","published":1,"updated":"2015-08-09T06:53:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cid6v2j6e002ro9d3n6ft2hrz"}],"PostAsset":[],"PostCategory":[{"post_id":"cid6v2j0w0003o9d3q7kj59lh","category_id":"cid6v2j160004o9d3sry0eplh","_id":"cid6v2j1f0007o9d3vmbfttm0"},{"post_id":"cid6v2j1s000eo9d3vxz0u4ft","category_id":"cid6v2j1v000fo9d3ahkmlabb","_id":"cid6v2j20000io9d35krteka7"},{"post_id":"cid6v2j27000lo9d3jp8n5d05","category_id":"cid6v2j2c000mo9d3hwtokbgm","_id":"cid6v2j2d000po9d310b9y0ba"},{"post_id":"cid6v2j2p000uo9d3khvd4p9d","category_id":"cid6v2j30000vo9d36zbghrk4","_id":"cid6v2j33000yo9d34tivc0ti"},{"post_id":"cid6v2j390011o9d3wnqelb8o","category_id":"cid6v2j3a0012o9d37n406px5","_id":"cid6v2j3g0015o9d3fgcllwh3"},{"post_id":"cid6v2j3p0018o9d3vo8way2b","category_id":"cid6v2j3q0019o9d3p76r52uc","_id":"cid6v2j3w001co9d3er0f7lnp"},{"post_id":"cid6v2j3z001jo9d3tx5v8nh3","category_id":"cid6v2j44001ko9d3lbeq98z7","_id":"cid6v2j46001no9d3wk44xg77"},{"post_id":"cid6v2j4f001so9d3mlk0h0m0","category_id":"cid6v2j4m001to9d3f9rd50ja","_id":"cid6v2j4u001wo9d3nog24glu"},{"post_id":"cid6v2j530021o9d38jgm35ck","category_id":"cid6v2j1v000fo9d3ahkmlabb","_id":"cid6v2j590022o9d307biwrvf"},{"post_id":"cid6v2j5h0026o9d34cry1u0c","category_id":"cid6v2j1v000fo9d3ahkmlabb","_id":"cid6v2j5j0027o9d39cr13763"},{"post_id":"cid6v2j5r002bo9d34g8snari","category_id":"cid6v2j160004o9d3sry0eplh","_id":"cid6v2j5w002co9d3fh85xjrc"},{"post_id":"cid6v2j65002jo9d3xud8ojew","category_id":"cid6v2j3q0019o9d3p76r52uc","_id":"cid6v2j66002ko9d3674ilo6o"},{"post_id":"cid6v2j6e002ro9d3n6ft2hrz","category_id":"cid6v2j2c000mo9d3hwtokbgm","_id":"cid6v2j6l002so9d32aul0g3v"}],"PostTag":[{"post_id":"cid6v2j0w0003o9d3q7kj59lh","tag_id":"cid6v2j160005o9d3ywgzaq95","_id":"cid6v2j1g000ao9d3mwqcqmrt"},{"post_id":"cid6v2j0w0003o9d3q7kj59lh","tag_id":"cid6v2j1e0006o9d3tmcx7n4g","_id":"cid6v2j1g000bo9d322wbz0qh"},{"post_id":"cid6v2j0w0003o9d3q7kj59lh","tag_id":"cid6v2j1f0008o9d357pvs4q8","_id":"cid6v2j1k000co9d3ueag8lxq"},{"post_id":"cid6v2j0w0003o9d3q7kj59lh","tag_id":"cid6v2j1g0009o9d3kx16rt75","_id":"cid6v2j1k000do9d3c2uz6dtf"},{"post_id":"cid6v2j1s000eo9d3vxz0u4ft","tag_id":"cid6v2j1v000go9d38lf9i4gw","_id":"cid6v2j20000jo9d3uta0lc5z"},{"post_id":"cid6v2j1s000eo9d3vxz0u4ft","tag_id":"cid6v2j1w000ho9d3svcwz7gt","_id":"cid6v2j20000ko9d3brjbxets"},{"post_id":"cid6v2j27000lo9d3jp8n5d05","tag_id":"cid6v2j2c000no9d3rwx3mrjd","_id":"cid6v2j2m000ro9d37aq1hd3h"},{"post_id":"cid6v2j27000lo9d3jp8n5d05","tag_id":"cid6v2j2d000oo9d3tt8sc3rc","_id":"cid6v2j2m000so9d30dagd4os"},{"post_id":"cid6v2j27000lo9d3jp8n5d05","tag_id":"cid6v2j2k000qo9d3em9tikw5","_id":"cid6v2j2m000to9d3uobdt0hz"},{"post_id":"cid6v2j2p000uo9d3khvd4p9d","tag_id":"cid6v2j30000wo9d3oshsogcn","_id":"cid6v2j33000zo9d3hyhoiwn1"},{"post_id":"cid6v2j2p000uo9d3khvd4p9d","tag_id":"cid6v2j32000xo9d31q23iens","_id":"cid6v2j340010o9d3d16ny30k"},{"post_id":"cid6v2j390011o9d3wnqelb8o","tag_id":"cid6v2j3b0013o9d32p4aipcn","_id":"cid6v2j3g0016o9d3992jlbfr"},{"post_id":"cid6v2j390011o9d3wnqelb8o","tag_id":"cid6v2j3b0014o9d3cvpg75tc","_id":"cid6v2j3h0017o9d3gxzn60nu"},{"post_id":"cid6v2j3p0018o9d3vo8way2b","tag_id":"cid6v2j3q001ao9d3s5vwr2by","_id":"cid6v2j3x001fo9d3g6xlqnxe"},{"post_id":"cid6v2j3p0018o9d3vo8way2b","tag_id":"cid6v2j3w001bo9d3k7yf5943","_id":"cid6v2j3x001go9d3nyji1ue2"},{"post_id":"cid6v2j3p0018o9d3vo8way2b","tag_id":"cid6v2j3w001do9d3x5p3qs6m","_id":"cid6v2j3x001ho9d3i08p2xfs"},{"post_id":"cid6v2j3p0018o9d3vo8way2b","tag_id":"cid6v2j3x001eo9d3vsyaisk4","_id":"cid6v2j3y001io9d39qoyamy2"},{"post_id":"cid6v2j3z001jo9d3tx5v8nh3","tag_id":"cid6v2j45001lo9d3uf24zegh","_id":"cid6v2j47001po9d3zqoa1mco"},{"post_id":"cid6v2j3z001jo9d3tx5v8nh3","tag_id":"cid6v2j46001mo9d3vc8tht4h","_id":"cid6v2j4c001qo9d3qjsx7ijw"},{"post_id":"cid6v2j3z001jo9d3tx5v8nh3","tag_id":"cid6v2j47001oo9d3d5jp3imd","_id":"cid6v2j4d001ro9d3nlcwhgmx"},{"post_id":"cid6v2j4f001so9d3mlk0h0m0","tag_id":"cid6v2j4n001uo9d3d0xtwtbx","_id":"cid6v2j51001yo9d3lnkn1hfp"},{"post_id":"cid6v2j4f001so9d3mlk0h0m0","tag_id":"cid6v2j4t001vo9d33p9pyw63","_id":"cid6v2j51001zo9d3knr6spwo"},{"post_id":"cid6v2j4f001so9d3mlk0h0m0","tag_id":"cid6v2j4v001xo9d3tc3or97k","_id":"cid6v2j510020o9d3llfvfe1t"},{"post_id":"cid6v2j530021o9d38jgm35ck","tag_id":"cid6v2j1v000go9d38lf9i4gw","_id":"cid6v2j5a0024o9d38x3gv6vp"},{"post_id":"cid6v2j530021o9d38jgm35ck","tag_id":"cid6v2j5a0023o9d3pvxobsz0","_id":"cid6v2j5b0025o9d3ioxfl0j2"},{"post_id":"cid6v2j5h0026o9d34cry1u0c","tag_id":"cid6v2j1v000go9d38lf9i4gw","_id":"cid6v2j5o0029o9d356mkx09q"},{"post_id":"cid6v2j5h0026o9d34cry1u0c","tag_id":"cid6v2j5j0028o9d3wai3ilp2","_id":"cid6v2j5p002ao9d3cnpzvgpg"},{"post_id":"cid6v2j5r002bo9d34g8snari","tag_id":"cid6v2j5x002do9d3z8urx1p9","_id":"cid6v2j5z002fo9d3f2fwdtk1"},{"post_id":"cid6v2j5r002bo9d34g8snari","tag_id":"cid6v2j1g0009o9d3kx16rt75","_id":"cid6v2j5z002go9d3snm9jv8t"},{"post_id":"cid6v2j5r002bo9d34g8snari","tag_id":"cid6v2j45001lo9d3uf24zegh","_id":"cid6v2j5z002ho9d38wd3c08f"},{"post_id":"cid6v2j5r002bo9d34g8snari","tag_id":"cid6v2j5y002eo9d3g835fvo3","_id":"cid6v2j64002io9d302tzc5cq"},{"post_id":"cid6v2j65002jo9d3xud8ojew","tag_id":"cid6v2j67002lo9d3qb29ehza","_id":"cid6v2j6c002oo9d3nhub73dq"},{"post_id":"cid6v2j65002jo9d3xud8ojew","tag_id":"cid6v2j67002mo9d3o81srnq6","_id":"cid6v2j6d002po9d3fb5zk0mv"},{"post_id":"cid6v2j65002jo9d3xud8ojew","tag_id":"cid6v2j6c002no9d3febt6rbg","_id":"cid6v2j6d002qo9d3byv9sxu6"},{"post_id":"cid6v2j6e002ro9d3n6ft2hrz","tag_id":"cid6v2j6l002to9d3zap6sui9","_id":"cid6v2j6m002uo9d34diwferi"}],"Tag":[{"name":"异步","_id":"cid6v2j160005o9d3ywgzaq95"},{"name":"同步","_id":"cid6v2j1e0006o9d3tmcx7n4g"},{"name":"IO模型","_id":"cid6v2j1f0008o9d357pvs4q8"},{"name":"操作系统","_id":"cid6v2j1g0009o9d3kx16rt75"},{"name":"知识点整理","_id":"cid6v2j1v000go9d38lf9i4gw"},{"name":"计算机网络","_id":"cid6v2j1w000ho9d3svcwz7gt"},{"name":"ssh反向代理","_id":"cid6v2j2c000no9d3rwx3mrjd"},{"name":"ssh","_id":"cid6v2j2d000oo9d3tt8sc3rc"},{"name":"穿越内网","_id":"cid6v2j2k000qo9d3em9tikw5"},{"name":"设计模式","_id":"cid6v2j30000wo9d3oshsogcn"},{"name":"C++实现","_id":"cid6v2j32000xo9d31q23iens"},{"name":"excel","_id":"cid6v2j3b0013o9d32p4aipcn"},{"name":"phpmyadmin","_id":"cid6v2j3b0014o9d3cvpg75tc"},{"name":"uboot定制","_id":"cid6v2j3q001ao9d3s5vwr2by"},{"name":"内核编译","_id":"cid6v2j3w001bo9d3k7yf5943"},{"name":"打印机共享","_id":"cid6v2j3w001do9d3x5p3qs6m"},{"name":"openwrt","_id":"cid6v2j3x001eo9d3vsyaisk4"},{"name":"linux","_id":"cid6v2j45001lo9d3uf24zegh"},{"name":"内存管理","_id":"cid6v2j46001mo9d3vc8tht4h"},{"name":"分页技术","_id":"cid6v2j47001oo9d3d5jp3imd"},{"name":"hadoop","_id":"cid6v2j4n001uo9d3d0xtwtbx"},{"name":"n2n","_id":"cid6v2j4t001vo9d33p9pyw63"},{"name":"vpn","_id":"cid6v2j4v001xo9d3tc3or97k"},{"name":"数据结构","_id":"cid6v2j5a0023o9d3pvxobsz0"},{"name":"C++","_id":"cid6v2j5j0028o9d3wai3ilp2"},{"name":"复习笔记","_id":"cid6v2j5x002do9d3z8urx1p9"},{"name":"进程线程","_id":"cid6v2j5y002eo9d3g835fvo3"},{"name":"文件系统","_id":"cid6v2j67002lo9d3qb29ehza"},{"name":"busybox","_id":"cid6v2j67002mo9d3o81srnq6"},{"name":"移植","_id":"cid6v2j6c002no9d3febt6rbg"},{"name":"DNS，第三方DNS","_id":"cid6v2j6l002to9d3zap6sui9"}]}}