<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>复习笔记-C++ | 宋志诚的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总结复习，C/C++知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="复习笔记-C++">
<meta property="og:url" content="http://nfeat.com/2015/03/10/gerenbijicpp/index.html">
<meta property="og:site_name" content="宋志诚的博客">
<meta property="og:description" content="总结复习，C/C++知识点">
<meta property="og:image" content="http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/37959742.jpg">
<meta property="og:updated_time" content="2015-08-10T12:26:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="复习笔记-C++">
<meta name="twitter:description" content="总结复习，C/C++知识点">
  
    <link rel="alternative" href="/atom.xml" title="宋志诚的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkz95.com1.z0.glb.clouddn.com/15-8-9/75980830.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">宋志诚</a></h1>
		</hgroup>

		
		<p class="header-subtitle">爱折腾，瞎捣鼓，也是一个伪极客</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/featman" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/nfeat" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:songzhicheng2007@gmail.com" title="mail">mail</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/lorne0506" title="twitter">twitter</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/C-实现/" style="font-size: 10px;">C++实现</a> <a href="/tags/DNS，第三方DNS/" style="font-size: 10px;">DNS，第三方DNS</a> <a href="/tags/busybox/" style="font-size: 10px;">busybox</a> <a href="/tags/excel/" style="font-size: 10px;">excel</a> <a href="/tags/hadoop/" style="font-size: 10px;">hadoop</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/n2n/" style="font-size: 10px;">n2n</a> <a href="/tags/openwrt/" style="font-size: 10px;">openwrt</a> <a href="/tags/phpmyadmin/" style="font-size: 10px;">phpmyadmin</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/ssh反向代理/" style="font-size: 10px;">ssh反向代理</a> <a href="/tags/uboot定制/" style="font-size: 10px;">uboot定制</a> <a href="/tags/vpn/" style="font-size: 10px;">vpn</a> <a href="/tags/内存管理/" style="font-size: 10px;">内存管理</a> <a href="/tags/内核编译/" style="font-size: 10px;">内核编译</a> <a href="/tags/分页技术/" style="font-size: 10px;">分页技术</a> <a href="/tags/打印机共享/" style="font-size: 10px;">打印机共享</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/知识点整理/" style="font-size: 20px;">知识点整理</a> <a href="/tags/移植/" style="font-size: 10px;">移植</a> <a href="/tags/穿越内网/" style="font-size: 10px;">穿越内网</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Geeker, New Hardware, OS, C/C++, Cloud Computing, BigData, and like thinking too.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">宋志诚</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkz95.com1.z0.glb.clouddn.com/15-8-9/75980830.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">宋志诚</h1>
			</hgroup>
			
			<p class="header-subtitle">爱折腾，瞎捣鼓，也是一个伪极客</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/featman" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/nfeat" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:songzhicheng2007@gmail.com" title="mail">mail</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/lorne0506" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-gerenbijicpp" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/10/gerenbijicpp/" class="article-date">
  	<time datetime="2015-03-10T16:31:49.000Z" itemprop="datePublished">2015-03-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      复习笔记-C++
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/知识点整理/">知识点整理</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/总结复习/">总结复习</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>总结复习，C/C++知识点<br><a id="more"></a></p>
<h4 id="1-volatile_容易改变的变量">1.volatile 容易改变的变量</h4><p>修饰的是易变的变量，如果没有加volatile，则编译器可能会优化变量，之后程序可能读取的时候会直接读寄存器而不去读内存，导致读到的数据有问题。<br>如果修饰之后，程序每次读数据都直接从内存上读，而不是从寄存器读。</p>
<h4 id="2-C++迭代器失效（防止失效办法：获取返回值）">2.C++迭代器失效（防止失效办法：获取返回值）</h4><p><a href="http://blog.csdn.net/vipvipvip/article/details/6295973" target="_blank" rel="external">http://blog.csdn.net/vipvipvip/article/details/6295973</a><br><a href="http://blog.csdn.net/damenhanter/article/details/8770076" target="_blank" rel="external">http://blog.csdn.net/damenhanter/article/details/8770076</a><br><a href="http://wenku.baidu.com/link?url=VP4ObGLGIBeyyb8Pa125Nq-2mlrx6qoJgd3Jxbhvxkh7CDJ6NVhKQV-k-1Db2uHisqvtVtsyxBFfwa8vDPF53xOfm0UBEloN7D_Q4XPyKam" target="_blank" rel="external">http://wenku.baidu.com/link?url=VP4ObGLGIBeyyb8Pa125Nq-2mlrx6qoJgd3Jxbhvxkh7CDJ6NVhKQV-k-1Db2uHisqvtVtsyxBFfwa8vDPF53xOfm0UBEloN7D_Q4XPyKam</a>  </p>
<blockquote>
<p>a。在往vector添加一个新的成员时，vector会重新申请内存，然后把原来的值全部复制到新的内存上，这时候迭代器还指向原来的 位置，成为野指针，所以失效。<br>b。删除元素也可能导致迭代器失效。</p>
</blockquote>
<h4 id="3-_STL容器应用场景">3. STL容器应用场景</h4><blockquote>
<p>【序列性容器：vector，deque，list】<br>【关联性容器：map，set】   </p>
</blockquote>
<ul>
<li>vector实现了动态数组的功能，内部实现为数组，空间不够用时申请内存效率相对较低（中间插入，删除要移动内存）  </li>
<li>deque数组实现。类似于vector，两端插入和删除。  </li>
<li>list是双向链表实现。  </li>
<li>map底层为红黑树实现，效率logN,速度很快，而且基于key-value，自动排序。  </li>
<li><p>set底层实现为AVL，速度logN，功能上与vector类似，但是所存储内容不能包含相同的。。  </p>
<p><img src="http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/37959742.jpg" alt="image description"></p>
<h4 id="4-inline函数">4.inline函数</h4><blockquote>
<p> 【内联函数是以代码的复制为代价，减少了函数调用（压栈，出栈开销大）的开销，从而提高代码的执行效率】</p>
</blockquote>
</li>
<li><p>内联函数和宏的区别是，前者是真正的函数，是由编译器去检查和展开的，而宏只是预处理器做的一个简单替换。  </p>
</li>
<li>inline关键字应该放在函数的定义处，而不是声明处。  </li>
<li>C++中类的成员函数，如果在类中直接定义函数，那么此函数不管加没加inline关键字，都会自动变为内联函数。所以说C++中，类中只是声明，定义要放在类外。  </li>
<li>多用在短小的函数，且此函数经常被调用。一般在C++中，内联函数的定义和声明都是放在头文件中，因为其他的源文件也需要使用内联。  </li>
<li>从inline的原理，我们可以看出，inline的原理，是用空间换取时间的做法，是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少<h4 id="5-_浅拷贝、深拷贝">5. <a href="http://blog.csdn.net/bluescorpio/article/details/4322682" target="_blank" rel="external">浅拷贝、深拷贝</a></h4><blockquote>
<p>浅拷贝：在C++中在对对象复制时，只对对象中的成员数据进行简单的赋值操作称为浅拷贝。（默认为浅拷贝）。</p>
<p>深拷贝：在C++中对对象复制时，如果对象所属类中的成员变量有在堆中申请的内存时（如指针new一块内存），就不能简单的复制一下值就可以了，因为在之后的析构函数中，每个对象都会调用一次，这时候删除对象中的堆内存就会删除两次。导致不可预测的结果。这时候需要自己去写拷贝构造函数（例如也同时申请了一块内存，把值拷贝到这一块内存中），不要用默认的。这样做后，再程序到析构的时候就会释放各自申请的内存，不会导致内存归属不明问题。</p>
</blockquote>
</li>
</ul>
<h4 id="6-_C++引用">6. <a href="http://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html" target="_blank" rel="external">C++引用</a></h4><blockquote>
<p>引用存在的意义：是为了解决在函数参数传递过程中，传递一大块数据如果以值传递的方式，那么函数调用的开销会增大，效率降低。</p>
</blockquote>
<h5 id="特点">特点</h5><blockquote>
<p>a.如果是值传递的话，那么最好在形参前加一个const，这样就保证了引用的安全性。<br>b.C++中&amp;不是取地址，而是一个引用的表示符。一般来说引用多用在对象，对普通的数据类型，用引用没有什么意义。<br>c.【【声明引用的同时，必须要初始化】】<br>d。引用本身不占用内存，但是用sizeof引用的时候，返回的是引用代表的那块内存的大小。<br>e。取引用的地址 &amp;a，就是取目标变量（对象）的地址。</p>
</blockquote>
<h5 id="应用">应用</h5><blockquote>
<p>a。传递参数。int test(A &amp;a){}，提高效率，因为函数中操作的是实际的内存。并不是一个副本。<br>b.返回值。 int &amp; test() { } 里边的返回值应该是一个全局的变量。这样就不会产生副本了，同时也能从函数中传出来，但不能是局部变量（栈区，调用结束就销毁了），也不能是函数内部new的变量（因为返回之后我如何销毁这块内存呢？引用又不是内存地址，不能用free的。）</p>
</blockquote>
<h4 id="7-多态、虚函数、纯虚函数、重载">7.多态、虚函数、纯虚函数、重载</h4><blockquote>
<p><a href="http://blog.csdn.net/memewry/article/details/7983267" target="_blank" rel="external">http://blog.csdn.net/memewry/article/details/7983267</a><br><a href="http://blog.csdn.net/braveyly/article/details/5549978" target="_blank" rel="external">http://blog.csdn.net/braveyly/article/details/5549978</a></p>
</blockquote>
<ul>
<li>多态是指向不同的对象发送相同的消息，返回不同的结果。这里的消息是调用函数的意思。   </li>
<li>虚函数与多态就是说基类中定义一个虚函数，然后用基类定义一个指针对象，这个对象指向子类的实例，这时候再调用相同的函数就会有不同的实现。具体说的话基类指针指向子类的实例地址，在这个指针调用虚函数的，并不会调用基类中的函数，而是根据这个虚函数表里的映射关系来找到相关对象的地址的函数入口。   </li>
<li>纯虚函数：函数没有实现，只有一个声明。用virtual void func()= 0;这种方式声明的就叫纯虚函数。类中只要含有纯虚函数，那么这个类就变成了抽象类。   </li>
<li>重载是一种函数实现，和多态没有关系。【重载的几个函数必须在同一个类中，而多态与它完全不同，多态是覆盖的一种表现形式，覆盖在基类中必须要有关键字virtual。】   </li>
<li>virtual关键字的作用就是为了实现动态绑定，而动态绑定的表现形式就是为多态。动态绑定有两个要求，第一个，指定为虚函数，第二个，用基类声明的指针或者引用指向派生类的对象，一般都是放在基类的函数前，派生类函数前并不需要加virtual。</li>
</ul>
<blockquote>
<p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。所以基本的一条是：无故的声明虚析构函数和永远不去声明一样是错误的。实际上，很多人这样总结：当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数。一般在多太的基类中都把xigou函数生命为virtual</p>
</blockquote>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//<span class="literal">A</span>为父类，B、C为子类</span><br><span class="line"><span class="literal">A</span>* <span class="literal">a</span>= new B()<span class="comment">;</span></span><br><span class="line"><span class="literal">a</span>-&gt;DoSomething()<span class="comment">;</span></span><br><span class="line">delete <span class="literal">a</span><span class="comment">;</span></span><br><span class="line"><span class="literal">a</span> = NULL<span class="comment">;</span></span><br><span class="line"><span class="literal">A</span>* <span class="literal">a</span> = new C()<span class="comment">;</span></span><br><span class="line"><span class="literal">a</span>-&gt;DoSomething()<span class="comment">;</span></span><br><span class="line">delete <span class="literal">a</span><span class="comment">;</span></span><br><span class="line"><span class="literal">a</span> = NULL<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="8-sizeof">8.sizeof</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> A&#123;</span><br><span class="line">     <span class="keyword">int</span> a;</span><br><span class="line">     <span class="keyword">short</span> b;</span><br><span class="line">     <span class="keyword">double</span> c;</span><br><span class="line">     <span class="keyword">float</span> d;</span><br><span class="line">     <span class="keyword">int</span> *aa;</span><br><span class="line">     <span class="keyword">char</span> *bb;</span><br><span class="line">     <span class="keyword">char</span> cc;</span><br><span class="line">&#125; structA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(structA));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上运行结果为32.考的知识点为字节对齐和指针的大小。</p>
</blockquote>
<p>注意的地方：</p>
<ul>
<li>a.结构体A中的顺序变化也能影响结果的不同。</li>
<li>b.结构体总大小 为 结构体中最宽的数据类型的整数倍，这里是double型，所以为8的整数倍</li>
<li>c.结构体中如果还有结构体，那么把内置的结构体顺序展开，计算大小。d.注意结构体内有数组的情况，要注意数组的类型为宽度。</li>
<li>d.如果结构体或者类中有static静态变量，那么计算结构体大小的时候，是不包含static变量的</li>
</ul>
<p>附：</p>
<ul>
<li><p>1.在类中，一个空类的大小也需要占用一个字节。因为空类也需要实例化。</p>
</li>
<li><p>2.类中如果有虚函数，那么类到大小为一个指针的大小，有多少个虚函数都只有一个指针大小。。普通函数不占用内存。。。。。</p>
</li>
<li><p>3.派生类的大小受到基类的影响，如果派生类继承两个基类，两个基类各有虚函数，那么派生类就有两个虚函数指针。</p>
</li>
</ul>
<h4 id="9-static">9.static</h4><h5 id="静态全局变量、静态局部变量、全局变量、局部变量">静态全局变量、静态局部变量、全局变量、局部变量</h5><ul>
<li>静态局部变量：在全局数据区分配内存。第一次初始化的值会一直保存在全局数据区，之后再调用这个静态局部变量所在的函数，就不会再初始化了。如果第一次没有初始化，那么编译器会初始化为0，他的生存期是程序的整个运行周期，但是他的作用域只在函数中。</li>
<li>局部变量：在栈中申请内存，作用域和生命期都为函数，函数结束，内存释放，且不再有效。</li>
<li>全局变量：在所有函数中都有效。</li>
<li>静态全局变量：与全局变量一样，唯一的不同就是作用域变小了，原来的全局变量可以在所有源文件中共享内存的，比如A文件和B文件中都要用同一个int a ，则在A中用int a，B中用extern a。但是对静态全局变量来说，A中用static int a，B中又定义int a，这个时候是无影响的，是两个不同的内存空间。</li>
</ul>
<h5 id="静态函数、普通函数">静态函数、普通函数</h5><ul>
<li>静态函数与普通函数的区别只在于作用域，类似于静态全局变量和全局变量。</li>
<li>还有一个类中的静态成员函数和类中的成员函数，前者static成员函数后，他没有this指针，他属于类，而不属于某个实例。与类中的static成员函数对应的为类中的static成员变量，静态成员函数只能访问静态成员变量，而不能访问类的其他成员变量，但是普通函数是可以访问类中的静态成员变量的。静态成员函数在类中只是声明，同时，她的赋值放在其他源文件中。用类：：static变量 访问它。另外，成员变量到定义是在进入main函数前就已经存在于内存中了，这时候如果构造函数去改变它到值，当类被实例化了，那么值就改变了。</li>
</ul>
<h4 id="10-C++命名空间">10.C++命名空间</h4><blockquote>
<p>存在的意义：C++函数库及其复杂和繁多，为了解决命名冲突的问题，这样就可以命名相同的函数名。</p>
</blockquote>
<h4 id="11-template模板">11.template模板</h4><p>C++中模板分为两种，一个是模板函数，一个是模板类</p>
<h5 id="函数模板">函数模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T x,T y)</span></span><br><span class="line"></span>&#123; <span class="keyword">return</span>(x&lt;y)?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n1=<span class="number">2</span>,n2=<span class="number">10</span>;</span><br><span class="line">     <span class="keyword">double</span> d1=<span class="number">1.5</span>,d2=<span class="number">5.6</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt; <span class="string">"较小整数:"</span>&lt;&lt;min(n1,n2)&lt;&lt;endl;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt; <span class="string">"较小实数:"</span>&lt;&lt;min(d1,d2)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="12-模板类">12.模板类</h5><blockquote>
<p>一定要注意模板类的声明和实现一定要都放在头文件中，不然编译无法通过.</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">class test&#123;</span><br><span class="line">private:</span><br><span class="line"> T value;</span><br><span class="line">public:</span><br><span class="line"> test(T val);</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> show();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">test&lt;T&gt;::test(T val)&#123;</span><br><span class="line"> this-&gt;value = val; </span><br><span class="line"> cout&lt;&lt;<span class="string">"fffffff"</span>&lt;&lt;this-&gt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line"><span class="type">void</span> test&lt;T&gt;::show()&#123;</span><br><span class="line"> cout&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//使用时：</span><br><span class="line"><span class="type">int</span> main()&#123;</span><br><span class="line">     test&lt;<span class="type">MyString</span>&gt;  s(<span class="string">"stringdddd"</span>);</span><br><span class="line">     s.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-初始化成员列表和构造函数里赋值">13.初始化成员列表和构造函数里赋值</h4><blockquote>
<p>如果是一般情况下，在构造函数里赋值就可以里，但是如果类中到成员属性 有const常量或者是对象到引用时候，这时候一定要用初始化成员列表。因为const常量只能初始化，不能赋值。<br>第二点是因为效率。</p>
</blockquote>
<h4 id="14-语法分析器和词法分析器作用">14.语法分析器和词法分析器作用</h4><blockquote>
<p>（在编译器中）</p>
</blockquote>
<ul>
<li>顾名思义，词法分析器检查的是词法，语法分析器分析的是语法（并不分析语义，因为语义强调的是你的逻辑），什么是词法，什么是语法你弄明白就知道了。</li>
<li>所谓词法，源代码由字符流组成，字符流中包括关键字，变量名，方法名，括号等等符号，其中变量名要满足不能包括标点符号，不能以数字开头的数字与字母的字符串这个条件，对于括号要成对出现等等，这就是词法;</li>
<li>而语法，词法没有问题才能进入语法分析，语法就是词排列的方法，字面意义，比如一句中文：我吃萝卜，里面有三个词我 吃 萝卜，除了“我吃萝卜”外，这三个词还可以组成，“萝卜吃我”“萝卜我吃”等，显然按照中文文法，后面的两句话是不对的，语法分析器就是分析类似这样的语法的。</li>
</ul>
<h4 id="15-如何判断一个系统是大段模式还是小端模式。">15.如何判断一个系统是大段模式还是小端模式。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> A&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> d;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a aa;</span><br><span class="line">*((<span class="keyword">int</span>*)&amp;aa) = <span class="number">0X01020304</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d,%d,%d\n"</span>,aa.a,aa.b,aa.c,aa.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细请看：<a href="http://blog.csdn.net/hackbuteer1/article/details/7722667" target="_blank" rel="external">大端模式和小端模式</a><br>在所有的介绍字节序的文章中都会提到字 节序分为两类：Big-Endian和Little-Endian，引用标准的Big-Endian和Little-Endian的定义如下：</p>
<ul>
<li>a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</li>
<li>b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li>
<li>c) 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。<h4 id="16-类和结构体的区别">16.<a href="http://www.cnblogs.com/vace/archive/2011/04/14/2015754.html" target="_blank" rel="external">类和结构体的区别</a></h4></li>
</ul>
<h4 id="17-类的对象_和_类的指针">17.类的对象 和 类的指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> number;  </span><br><span class="line"><span class="built_in">string</span> name; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">Student() </span><br><span class="line">&#123; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> str)</span> </span><br><span class="line"></span>&#123; </span><br><span class="line">name = str; </span><br><span class="line">number++;    <span class="comment">// 调用静态数据成员 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>  <span class="comment">// 态成员函数 print() </span></span><br><span class="line"></span>&#123; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt; &lt; name &lt; &lt;<span class="string">" : The number of the students is "</span> &lt; &lt; number &lt; &lt; <span class="string">" numbers."</span> &lt; &lt; <span class="built_in">std</span>::endl; <span class="comment">// 调用静态数据成员 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::number = <span class="number">0</span>;  <span class="comment">// 静态数据成员初始化 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span><br><span class="line"></span>&#123; </span><br><span class="line"></span><br><span class="line">Student* s1; </span><br><span class="line">s1 = <span class="keyword">new</span> Student(); </span><br><span class="line">s1-&gt;<span class="built_in">set</span>(<span class="string">"111"</span>); </span><br><span class="line"></span><br><span class="line">Student s2; </span><br><span class="line">s2.<span class="built_in">set</span>(<span class="string">"222"</span>); </span><br><span class="line"></span><br><span class="line">s1-&gt;print(); </span><br><span class="line">s2.print(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于类student ，定义了一个对象 和一个指针。  </p>
<ul>
<li>类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).   </li>
<li>对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).  </li>
</ul>
<p>在应用时:   </p>
<blockquote>
<p>1.引用成员:   对象用”   .   “操作符;   指针用”   -&gt;   “操作符.<br>2.生命期:     若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete   在相应的地方释放分配的内存块.   </p>
</blockquote>
<p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/16/2593754.html" target="_blank" rel="external">用new   ,一定要delete..【为何要用delete】?</a></p>
<ul>
<li><p>1.malloc/free 是库函数，而new/delete是C++操作符，后者有编译器检查。</p>
</li>
<li><p>2.前者只申请了内存，后者是申请内存和构造函数等等。用delete调用了析构函数，而free只释放内存。</p>
</li>
</ul>
<p>类的对象:用的是内存栈,是个局部的临时变量.<br>  类的指针:用的是内存堆,是个永久变量,除非你释放它.   </p>
<p>  当类是有虚函数的基类,Func是它的一个虚函数,则调用Func时:<br>  类的对象:调用的是它自己的Func;<br>  类的指针:调用的是分配给它空间时那种类的Func;<br>对于一个类的对象和这个类的指针（用new运算符分配内存）在应用时有何区别<br>  1.类和对象是两回事,对象是类的实例;<br>  2.对象是在栈中分配的,使用new生成的对象是在堆中分配的;<br>  3.要发挥虚函数的强大作用,必须使用指针来访问对象.  </p>
<p>  指针可以实现多态，直接用对象不行<br>执行定义对象，在栈空间<br>new处的在堆<br>注意名字的类型.<br>一个是Student<br>一个是Student*<br>Student是直接访问一个对象<br>Student*是间接访问一个对象,因为通过了一个指针作媒介.<br>类型决定了你能做什么.<br>其实作用基本一样 都是为了调用类的成员变量 和成员函数用的<br>当你希望明确使用这个类的时候，最好使用对象，如果你希望使用C++中的动态绑定，则最好使用指针或者引用<br>指针和引用用起来更灵活，容易实现多态等 </p>
<p>类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).<br>对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).<br>在应用时:<br>1.引用成员:  对象用”  .  “操作符;  指针用”  -&gt;  “操作符.<br>2.生命期:    若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete  在相应的地方释放分配的内存块.<br>注意:用new 一定要delete..<br>当类是有虚函数的基类,f是它的一个虚函数,则调用f时:<br>类的对象:调用的是它自己的f;<br>类的指针:调用的是分配给它空间时那种类的f;<br>1.在类的声明尚未完成的情况下，可以声明指向该类的指针，但是不可声明该类的对象…<br>2.父类的指针可以指向子类的对象..<br>定义对象实例时，分配了内存。指针变量则未分配类对象所需内存<br>指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。<br>直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。<br>至于那个效率高要看程序调用过程而定。<br>C++的精髓之一就是多态性，只有指针或者引用可以达到多态。 【【【对象不行？为何不行？？？】】】】<br>用指针：<br>第一实现多态。<br>第二，在函数调用，传指针参数。不管你的对象或结构参数多么庞大，你用指针，传过去的就是4个字节。如果用对象，参数传递占用的资源就太大了</p>
<p>一般来说，可以定义为对象，在如下情况考虑把数据成员定义成指针，</p>
<ul>
<li>1）有多态的情况；会用到虚函数，基类指针</li>
<li>2）可能和别的类共享，或者只是引用别的类里的某个对象，所以生命周期不是很确定（这个可以考虑智能指针）</li>
<li>3）大数据类，如果定义成对象，会导致当前对象无法在栈内创建</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/03/29/gerenbijidata/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          复习笔记-数据结构
        
      </div>
    </a>
  
  
    <a href="/2015/01/11/hadoop/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">基于Hadoop平台的局域网和广域网环境下的处理性能比较</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="gerenbijicpp" data-title="复习笔记-C++" data-url="http://nfeat.com/2015/03/10/gerenbijicpp/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 宋志诚
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>