title: 复习笔记-C++   
date: 2015-3-10 12:31:49
categories: 总结复习
tags: [知识点整理,C++] 
---
总结复习，C/C++知识点
<!--more-->
#### 1.volatile 容易改变的变量
修饰的是易变的变量，如果没有加volatile，则编译器可能会优化变量，之后程序可能读取的时候会直接读寄存器而不去读内存，导致读到的数据有问题。
如果修饰之后，程序每次读数据都直接从内存上读，而不是从寄存器读。

#### 2.C++迭代器失效（防止失效办法：获取返回值）
http://blog.csdn.net/vipvipvip/article/details/6295973
http://blog.csdn.net/damenhanter/article/details/8770076  
http://wenku.baidu.com/link?url=VP4ObGLGIBeyyb8Pa125Nq-2mlrx6qoJgd3Jxbhvxkh7CDJ6NVhKQV-k-1Db2uHisqvtVtsyxBFfwa8vDPF53xOfm0UBEloN7D_Q4XPyKam  
> a。在往vector添加一个新的成员时，vector会重新申请内存，然后把原来的值全部复制到新的内存上，这时候迭代器还指向原来的 位置，成为野指针，所以失效。  
> b。删除元素也可能导致迭代器失效。

#### 3. STL容器应用场景
> 【序列性容器：vector，deque，list】  
> 【关联性容器：map，set】   

- vector实现了动态数组的功能，内部实现为数组，空间不够用时申请内存效率相对较低（中间插入，删除要移动内存）  
- deque数组实现。类似于vector，两端插入和删除。  
- list是双向链表实现。  
- map底层为红黑树实现，效率logN,速度很快，而且基于key-value，自动排序。  
- set底层实现为AVL，速度logN，功能上与vector类似，但是所存储内容不能包含相同的。。  

 ![image description](http://7xkz95.com1.z0.glb.clouddn.com/15-8-10/37959742.jpg)
 
 #### 4.inline函数
>  【内联函数是以代码的复制为代价，减少了函数调用（压栈，出栈开销大）的开销，从而提高代码的执行效率】

- 内联函数和宏的区别是，前者是真正的函数，是由编译器去检查和展开的，而宏只是预处理器做的一个简单替换。  
- inline关键字应该放在函数的定义处，而不是声明处。  
- C++中类的成员函数，如果在类中直接定义函数，那么此函数不管加没加inline关键字，都会自动变为内联函数。所以说C++中，类中只是声明，定义要放在类外。  
- 多用在短小的函数，且此函数经常被调用。一般在C++中，内联函数的定义和声明都是放在头文件中，因为其他的源文件也需要使用内联。  
- 从inline的原理，我们可以看出，inline的原理，是用空间换取时间的做法，是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少
#### 5. [浅拷贝、深拷贝](http://blog.csdn.net/bluescorpio/article/details/4322682)
> 浅拷贝：在C++中在对对象复制时，只对对象中的成员数据进行简单的赋值操作称为浅拷贝。（默认为浅拷贝）。
> 
> 深拷贝：在C++中对对象复制时，如果对象所属类中的成员变量有在堆中申请的内存时（如指针new一块内存），就不能简单的复制一下值就可以了，因为在之后的析构函数中，每个对象都会调用一次，这时候删除对象中的堆内存就会删除两次。导致不可预测的结果。这时候需要自己去写拷贝构造函数（例如也同时申请了一块内存，把值拷贝到这一块内存中），不要用默认的。这样做后，再程序到析构的时候就会释放各自申请的内存，不会导致内存归属不明问题。

#### 6. [C++引用](http://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html)
> 引用存在的意义：是为了解决在函数参数传递过程中，传递一大块数据如果以值传递的方式，那么函数调用的开销会增大，效率降低。

##### 特点
> a.如果是值传递的话，那么最好在形参前加一个const，这样就保证了引用的安全性。
> b.C++中&不是取地址，而是一个引用的表示符。一般来说引用多用在对象，对普通的数据类型，用引用没有什么意义。
> c.【【声明引用的同时，必须要初始化】】
> d。引用本身不占用内存，但是用sizeof引用的时候，返回的是引用代表的那块内存的大小。
> e。取引用的地址 &a，就是取目标变量（对象）的地址。

##### 应用

> a。传递参数。int test(A &a){}，提高效率，因为函数中操作的是实际的内存。并不是一个副本。   
> b.返回值。 int & test() { } 里边的返回值应该是一个全局的变量。这样就不会产生副本了，同时也能从函数中传出来，但不能是局部变量（栈区，调用结束就销毁了），也不能是函数内部new的变量（因为返回之后我如何销毁这块内存呢？引用又不是内存地址，不能用free的。）

#### 多态、虚函数、纯虚函数、重载
> http://blog.csdn.net/memewry/article/details/7983267
> http://blog.csdn.net/braveyly/article/details/5549978

- 多态是指向不同的对象发送相同的消息，返回不同的结果。这里的消息是调用函数的意思。   
- 虚函数与多态就是说基类中定义一个虚函数，然后用基类定义一个指针对象，这个对象指向子类的实例，这时候再调用相同的函数就会有不同的实现。具体说的话基类指针指向子类的实例地址，在这个指针调用虚函数的，并不会调用基类中的函数，而是根据这个虚函数表里的映射关系来找到相关对象的地址的函数入口。   
- 纯虚函数：函数没有实现，只有一个声明。用virtual void func()= 0;这种方式声明的就叫纯虚函数。类中只要含有纯虚函数，那么这个类就变成了抽象类。   
- 重载是一种函数实现，和多态没有关系。【重载的几个函数必须在同一个类中，而多态与它完全不同，多态是覆盖的一种表现形式，覆盖在基类中必须要有关键字virtual。】   
- virtual关键字的作用就是为了实现动态绑定，而动态绑定的表现形式就是为多态。动态绑定有两个要求，第一个，指定为虚函数，第二个，用基类声明的指针或者引用指向派生类的对象，一般都是放在基类的函数前，派生类函数前并不需要加virtual。

> 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。所以基本的一条是：无故的声明虚析构函数和永远不去声明一样是错误的。实际上，很多人这样总结：当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数。一般在多太的基类中都把xigou函数生命为virtual

```
//A为父类，B、C为子类
A* a= new B();
a->DoSomething();
delete a;
a = NULL;
A* a = new C();
a->DoSomething();
delete a;
a = NULL;

```
#### 类的对象 和 类的指针

```
#include <iostream> 
#include <string> 
using namespace std; 

class Student 
{ 
public: 
static int number;  
string name; 

public: 
Student() 
{ 
} 

void set(string str) 
{ 
name = str; 
number++;    // 调用静态数据成员 
} 

void print()  // 态成员函数 print() 
{ 
std::cout < < name < <" : The number of the students is " < < number < < " numbers." < < std::endl; // 调用静态数据成员 
} 
}; 

int Student::number = 0;  // 静态数据成员初始化 

int main(int argc, char** argv) 
{ 

Student* s1; 
s1 = new Student(); 
s1->set("111"); 

Student s2; 
s2.set("222"); 

s1->print(); 
s2.print(); 

return 0; 
} 

```
对于类student ，定义了一个对象 和一个指针。  
- 类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).   
- 对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).  


在应用时:   
> 
> 1.引用成员:   对象用"   .   "操作符;   指针用"   ->   "操作符.   
> 2.生命期:     若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete   在相应的地方释放分配的内存块.   

[用new   ,一定要delete..【为何要用delete】?](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/16/2593754.html)


- 1.malloc/free 是库函数，而new/delete是C++操作符，后者有编译器检查。

- 2.前者只申请了内存，后者是申请内存和构造函数等等。用delete调用了析构函数，而free只释放内存。

类的对象:用的是内存栈,是个局部的临时变量.   
  类的指针:用的是内存堆,是个永久变量,除非你释放它.   
    
  当类是有虚函数的基类,Func是它的一个虚函数,则调用Func时:   
  类的对象:调用的是它自己的Func;   
  类的指针:调用的是分配给它空间时那种类的Func;  
对于一个类的对象和这个类的指针（用new运算符分配内存）在应用时有何区别   
  1.类和对象是两回事,对象是类的实例;   
  2.对象是在栈中分配的,使用new生成的对象是在堆中分配的;   
  3.要发挥虚函数的强大作用,必须使用指针来访问对象.  
  
  
  指针可以实现多态，直接用对象不行   
执行定义对象，在栈空间   
new处的在堆  
注意名字的类型.  
一个是Student   
一个是Student\*    
Student是直接访问一个对象   
Student\*是间接访问一个对象,因为通过了一个指针作媒介.  
类型决定了你能做什么.  
其实作用基本一样 都是为了调用类的成员变量 和成员函数用的   
当你希望明确使用这个类的时候，最好使用对象，如果你希望使用C++中的动态绑定，则最好使用指针或者引用 
指针和引用用起来更灵活，容易实现多态等 

类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值).    
对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值).     
在应用时:     
1.引用成员:  对象用"  .  "操作符;  指针用"  ->  "操作符.  
2.生命期:    若是成员变量,则是类的析构函数来释放空间;若是函数中的临时变量,则作用域是该函数体内.而指针,则需利用delete  在相应的地方释放分配的内存块.  
注意:用new 一定要delete.. 
当类是有虚函数的基类,f是它的一个虚函数,则调用f时:  
类的对象:调用的是它自己的f;  
类的指针:调用的是分配给它空间时那种类的f; 
1.在类的声明尚未完成的情况下，可以声明指向该类的指针，但是不可声明该类的对象... 
2.父类的指针可以指向子类的对象..
定义对象实例时，分配了内存。指针变量则未分配类对象所需内存
指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。 
直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。 
至于那个效率高要看程序调用过程而定。
C++的精髓之一就是多态性，只有指针或者引用可以达到多态。 【【【对象不行？为何不行？？？】】】】
用指针： 
第一实现多态。 
第二，在函数调用，传指针参数。不管你的对象或结构参数多么庞大，你用指针，传过去的就是4个字节。如果用对象，参数传递占用的资源就太大了

一般来说，可以定义为对象，在如下情况考虑把数据成员定义成指针，
- 1）有多态的情况；会用到虚函数，基类指针
- 2）可能和别的类共享，或者只是引用别的类里的某个对象，所以生命周期不是很确定（这个可以考虑智能指针）
- 3）大数据类，如果定义成对象，会导致当前对象无法在栈内创建

#### sizeof

```
typedef struct A{
     int a;
     short b;
     double c;
     float d;
     int *aa;
     char *bb;
     char cc;
} structA;

int main(void) {
    printf("%d\n",sizeof(structA));
    return 0;
}
```
> 以上运行结果为32.考的知识点为字节对齐和指针的大小。

注意的地方：
- a.结构体A中的顺序变化也能影响结果的不同。
- b.结构体总大小 为 结构体中最宽的数据类型的整数倍，这里是double型，所以为8的整数倍
- c.结构体中如果还有结构体，那么把内置的结构体顺序展开，计算大小。d.注意结构体内有数组的情况，要注意数组的类型为宽度。
- d.如果结构体或者类中有static静态变量，那么计算结构体大小的时候，是不包含static变量的

附：
- 1.在类中，一个空类的大小也需要占用一个字节。因为空类也需要实例化。

- 2.类中如果有虚函数，那么类到大小为一个指针的大小，有多少个虚函数都只有一个指针大小。。普通函数不占用内存。。。。。

- 3.派生类的大小受到基类的影响，如果派生类继承两个基类，两个基类各有虚函数，那么派生类就有两个虚函数指针。


#### static
##### 静态全局变量、静态局部变量、全局变量、局部变量

- 静态局部变量：在全局数据区分配内存。第一次初始化的值会一直保存在全局数据区，之后再调用这个静态局部变量所在的函数，就不会再初始化了。如果第一次没有初始化，那么编译器会初始化为0，他的生存期是程序的整个运行周期，但是他的作用域只在函数中。
- 局部变量：在栈中申请内存，作用域和生命期都为函数，函数结束，内存释放，且不再有效。
- 全局变量：在所有函数中都有效。
- 静态全局变量：与全局变量一样，唯一的不同就是作用域变小了，原来的全局变量可以在所有源文件中共享内存的，比如A文件和B文件中都要用同一个int a ，则在A中用int a，B中用extern a。但是对静态全局变量来说，A中用static int a，B中又定义int a，这个时候是无影响的，是两个不同的内存空间。

##### 静态函数、普通函数
- 静态函数与普通函数的区别只在于作用域，类似于静态全局变量和全局变量。
- 还有一个类中的静态成员函数和类中的成员函数，前者static成员函数后，他没有this指针，他属于类，而不属于某个实例。与类中的static成员函数对应的为类中的static成员变量，静态成员函数只能访问静态成员变量，而不能访问类的其他成员变量，但是普通函数是可以访问类中的静态成员变量的。静态成员函数在类中只是声明，同时，她的赋值放在其他源文件中。用类：：static变量 访问它。另外，成员变量到定义是在进入main函数前就已经存在于内存中了，这时候如果构造函数去改变它到值，当类被实例化了，那么值就改变了。

#### C++命名空间
> 存在的意义：C++函数库及其复杂和繁多，为了解决命名冲突的问题，这样就可以命名相同的函数名。



#### template模板

C++中模板分为两种，一个是模板函数，一个是模板类
##### 函数模板
```
template <class T>
T min(T x,T y)
{ return(x<y)?x:y;}

void main( )
{
     int n1=2,n2=10;
     double d1=1.5,d2=5.6;
     cout<< "较小整数:"<<min(n1,n2)<<endl;
     cout<< "较小实数:"<<min(d1,d2)<<endl;
}
```

##### 模板类
> 一定要注意模板类的声明和实现一定要都放在头文件中，不然编译无法通过.

```
template <class T>
class test{
private:
 T value;
public:
 test(T val);

 void show();
};

template <class T>
test<T>::test(T val){
 this->value = val; 
 cout<<"fffffff"<<this->value<<endl;
}

template <class T>
void test<T>::show(){
 cout<<value<<endl;
}
//使用时：
int main(){
     test<MyString>  s("stringdddd");
     s.show();
}
```

#### 初始化成员列表和构造函数里赋值
> 如果是一般情况下，在构造函数里赋值就可以里，但是如果类中到成员属性 有const常量或者是对象到引用时候，这时候一定要用初始化成员列表。因为const常量只能初始化，不能赋值。
> 第二点是因为效率。


#### 语法分析器和词法分析器作用
> （在编译器中）

- 顾名思义，词法分析器检查的是词法，语法分析器分析的是语法（并不分析语义，因为语义强调的是你的逻辑），什么是词法，什么是语法你弄明白就知道了。
- 所谓词法，源代码由字符流组成，字符流中包括关键字，变量名，方法名，括号等等符号，其中变量名要满足不能包括标点符号，不能以数字开头的数字与字母的字符串这个条件，对于括号要成对出现等等，这就是词法;
- 而语法，词法没有问题才能进入语法分析，语法就是词排列的方法，字面意义，比如一句中文：我吃萝卜，里面有三个词我 吃 萝卜，除了“我吃萝卜”外，这三个词还可以组成，“萝卜吃我”“萝卜我吃”等，显然按照中文文法，后面的两句话是不对的，语法分析器就是分析类似这样的语法的。

#### 如何判断一个系统是大段模式还是小端模式。
```
typedef struct A{
unsigned char a;
unsigned char b;
unsigned char c;
unsigned char d;
}a;
int main(){
a aa;
*((int*)&aa) = 0X01020304;
printf("%d,%d,%d,%d\n",aa.a,aa.b,aa.c,aa.d);
}
```
#### [类和结构体的区别](http://www.cnblogs.com/vace/archive/2011/04/14/2015754.html)